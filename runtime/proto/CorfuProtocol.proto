syntax = "proto3";

package org.corfudb.runtime;

import "google/protobuf/any.proto";

option java_package = "org.corfudb.runtime.protocol.proto";

/**
 * Common Definitions
 **/

enum ProtocolVersion {
  v0 = 0;
}

enum MessageType {
  // Base Message Types
  PING = 0;
  AUTHENTICATE = 1;
  RESTART = 2;
  RESET = 3;
  SEAL = 4;

  // Layout Message Types
  GET_LAYOUT = 10;
  PREPARE_LAYOUT = 11;
  PROPOSE_LAYOUT = 12;
  COMMIT_LAYOUT = 13;
  BOOTSTRAP_LAYOUT = 14;

  // Sequencer Message Types
  TOKEN = 20;
  BOOTSTRAP_SEQUENCER = 21;
  SEQUENCER_TRIM = 22;
  SEQUENCER_METRICS = 23;
  STREAMS_ADDRESS = 24;

  // LogUnit Message Types
  WRITE_LOG = 30;
  READ_LOG = 31;
  INSPECT_ADDRESSES = 32;
  TRIM_LOG = 33;
  TRIM_MARK = 34;
  TAIL = 35;
  COMPACT_LOG = 36;
  FLUSH_CACHE = 37;
  LOG_ADDRESS_SPACE = 38;
  KNOWN_ADDRESS = 39;
  COMMITTED_TAIL = 40;
  UPDATE_COMMITTED_TAIL = 41;
  RESET_LOG_UNIT = 42;

  // Management Message Types
  QUERY_NODE = 50;
  REPORT_FAILURE = 51;
  HEAL_FAILURE = 52;
  ORCHESTRATOR = 53;
  BOOTSTRAP_MANAGEMENT = 54;
  GET_MANAGEMENT_LAYOUT = 55;
}

enum ERROR {
  OK = 0;
  UNKNOWN = 1;
  WRONG_EPOCH = 2;
  NOT_READY = 3;
  WRONG_CLUSTER = 4;
  TRIMMED = 5;
  OVERWRITE = 6;
  IO = 7;
  BOOTSTRAPPED = 8;
  NOT_BOOTSTRAPPED = 9;
}

enum Priority {
  NORMAL = 0;
  HIGH = 1;
}

message UUID {
  int64 lsb = 1;
  int64 msb = 2;
}

message Entries {
  repeated google.protobuf.Any items = 1;
}

// Payload for ERROR type WRONG_CLUSTER
message WrongClusterPayload {
  UUID serverClusterId = 1;
  UUID clientClusterId = 2;
}

message ServerError {
  ERROR code = 1;
  string message = 2;

  oneof payload {
    int64 wrongEpochPayload = 11;
    WrongClusterPayload wrongClusterPayload = 12;
  }
}

/**
 * Base Definitions
 **/

message PingRequest {
}

message PingResponse {
}

message AuthenticateRequest {

}

message AuthenticateResponse {

}

message RestartRequest {
}

message RestartResponse {
}

message ResetRequest {
}

message ResetResponse {
}

message SealRequest {
  int64 epoch = 1;
}

message SealResponse {
}

/**
 * Layout Definitions
 **/

// Represent a Layout in Protobuf as JSON string
message Layout {
  string layoutJSON = 1;
}

// Retrieve layout
message GetLayoutRequest {
  int64 epoch = 1;
}

message GetLayoutResponse {
  Layout layout = 1;
}

// Request in first phase of Paxos
message PrepareLayoutRequest {
  int64 epoch = 1;
  int64 rank = 2;
}

message PrepareLayoutResponse {
  enum Type {
    ACK = 0;
    REJECT = 1;
  }

  Type respType = 1;
  int64 rank = 2;
  Layout layout = 3;
}

// Request in second phase of Paxos
message ProposeLayoutRequest {
  int64 epoch = 1;
  int64 rank = 2;
  Layout layout = 3;
}

message ProposeLayoutResponse {
  enum Type {
    ACK = 0;
    REJECT = 1;
  }

  Type respType = 1;
  int64 rank = 2;
}

// If the first two phases (prepare and propose) of Paxos have been accepted, the
// proposer sends a Committed message to commit the proposed Layout
message CommitLayoutRequest {
  bool forced = 1;
  int64 epoch = 2;
  Layout layout = 3;
}

message CommitLayoutResponse {
  enum Type {
    ACK = 0;
    NACK = 1;
  }

  Type respType = 1;
}

// Request sent to bootstrap the server with a Layout
message BootstrapLayoutRequest {
  Layout layout = 1;
}

message BootstrapLayoutResponse {
  enum Type {
    ACK = 0;
    NACK = 1;
  }

  Type respType = 1;
}

/**
 * Sequencer Definitions
 **/

message Token {
  int64 epoch = 1;
  int64 sequence = 2;
}

/**
  proto3 does not support non integer or string keys.
  This message contains a map of UUID to an array of bytes.
  The bytes array can be further parsed into a Set of bytes.
 */
message UUIDToListOfBytesPair {
  UUID key = 1;
  repeated bytes value = 2;
}
message UUIDToListOfBytesMap {
  repeated UUIDToListOfBytesPair entries = 1;
}

enum TokenType {
  // Standard token issue by sequencer or a tail-query response
  TX_NORMAL = 0;

  // Token request for optimistic TX-commit rejected due to conflict
  TX_ABORT_CONFLICT = 1;

  // Token request for optimistic TX-commit rejected due to a
  // failover-sequencer lacking conflict-resolution info
  TX_ABORT_NEWSEQ = 2;

  // Sent when a transaction aborts a transaction due to missing information
  // (required data evicted from cache)
  TX_ABORT_SEQ_OVERFLOW = 3;

  // Sent when a transaction aborts because it has an old version (i.e. older than
  // the trim mark). This is to detect slow transactions
  TX_ABORT_SEQ_TRIM = 4;
}

message TxResolutionResponse {
  /* Response type from the sequencer.*/
  TokenType tokenType = 1;

  /* Optional. In case of a conflict, what was the address at which that conflict occurred. */
  int64 address = 2;

  /* Optional. In case of a conflict, what was the key that triggered a negative response. */
  bytes conflictingKey = 3;

  /* Optional. In case of a conflict, what was the stream ID that triggered a negative response. */
  UUID conflictingStream = 4;
}


message TxResolutionInfo {
  /* transaction ID, mostly for debugging purposes */
  UUID TXid = 1;

  /* snapshot timestamp of the txn. */
  Token snapshotTimestamp = 2;

  /** A set of poisoned streams, which have a conflict against all updates. */
  UUIDToListOfBytesMap conflictSet = 3;

  UUIDToListOfBytesMap writeConflictParamsSet = 4;
}

/**
 * A token request is at the heart of the Corfu log protocol.
 *
 * <p>There are four token request scenarios, designated by the relevant constants :
 * 0. TokenRequestType::TK_QUERY : Query of the current log tail and of specific stream-tails.
 * 1. TokenRequestType::TK_RAW : Ask for raw (global) log token(s).
 *              This extends the global log tail by the requested # of tokens.
 * 2. TokenRequestType::TK_MULTI_STREAM : Ask for token(s) on multiple streams.
 *          This extends both the global log tail, and each of the specified stream tails,
 *          by the requested # of tokens.
 * 3. TokenRequestType::TK_TX :
 *          First, check transaction resolution. If transaction can commit, then behave
 *          like TokenRequestType::TK_MULTI_STREAM.</p>
 */
message TokenRequest {
  enum TokenRequestType {
    TK_QUERY = 0;
    TK_RAW = 1;
    TK_MULTI_STREAM = 2;
    TK_TX = 3;
  }
  TokenRequestType requestType = 11;
  int64 numTokens = 12;
  repeated UUID streams = 13;
  TxResolutionInfo txnResolution = 14;
}

/**
  proto3 does not support non integer or string keys.
  This message contains a map of UUID to an array of bytes.
  The bytes array can be further parsed into a Set of bytes.
 */
message UUIDToLongPair {
  UUID key = 1;
  int64 value = 2;
}

message UUIDToLongMap {
  repeated UUIDToLongPair entries = 1;
}

message TokenResponse {
  /** the cause/type of response. */
  TokenType respType = 1;

  // In case of a conflict, signal to the client which key was responsible for the conflict.
  bytes conflictKey = 2;

  // In case of a conflict, signal to the client which stream was responsible for the conflict.
  UUID conflictStream = 3;

  /** The current token or global log tail in the case of stream tails query */
  Token token = 4;

  /** The backPointer map, if available. */
  UUIDToLongMap backPointerMap = 5;
  UUIDToLongMap streamTails = 6;
}

/**
 * This class represents the space of all addresses belonging to a stream.
 *
 * A stream's address space is defined by:
 *       1. The collection of all addresses that belong to this stream.
 *       2. The trim mark (last trimmed address, i.e., an address that is no longer present and that was subsumed by
 *       a checkpoint).
 */
message StreamAddressSpace {
  int32 NO_ADDRESSES = 1; // For numeric types, the default value is zero.

  // Holds the last trimmed address for this stream.
  // Note: keeping the last trimmed address is required in order to properly set the stream tail on sequencer resets
  // when a stream has been checkpointed and trimmed and there are no further updates to this stream.
  uint64 trimMark = 2;

  // Holds the complete map of addresses for this stream. (of type Roaring64NavigableMap)
  bytes addressMap = 3;

}

message UUIDToStreamAddressPair {
  UUID key = 1;
  StreamAddressSpace value = 2;
}


message UUIDToStreamAddressMap {
  repeated UUIDToStreamAddressPair entries = 1;
}

// SequencerRecoveryMsg
message BootStrapSequencerRequest {
  int64 globalTail = 1;
  UUIDToStreamAddressMap streamsAddressMap = 2;
  int64 sequencerEpoch = 3;

  /**
   * Boolean flag to denote whether this bootstrap message is just updating an existing primary
   * sequencer with the new epoch (if set to true) or bootstrapping a currently NOT_READY
   * sequencer.
   */
  bool bootstrapWithoutTailsUpdate = 4;
}

message BootStrapSequencerResponse {

}

message SequencerTrimRequest {
  int64 trimMark = 1;
}

message SequencerTrimResponse {

}

message SequencerMetricsRequest {

}

/**
 * Sequencer metrics for a node.
 */
message SequencerMetrics {
  enum SequencerStatus {
    // Sequencer is in READY state, and can dispatch tokens.
    READY = 0;
    // Sequencer is in a NOT_READY state.
    NOT_READY = 1;
    // Unknown state.
    UNKNOWN = 2;
  }
  /**
   * Ready state of a sequencer to determine its READY/NOT_READY state.
   */
  SequencerStatus sequencerStatus = 1;
}


message SequencerMetricsResponse {
    SequencerMetrics sequencerMetrics = 1;
}

/**
 * This message represents a range of addresses for a stream.
 *
 * This is used to request the address map of a stream in
 * a given boundary-- limits given by (end, start].
 *
 */
message StreamAddressRange {
  UUID streamID = 1;
  // Start is inclusive
  int64 start = 2;
  // End is exclusive
  int64 end = 3;
}

/**
 * Represents the request sent to the sequencer to retrieve one or several streams address map.
 */
message StreamsAddressRequest {
  enum Type {
    /*To request specific streams*/
    STREAMS = 0;
    /*To request all streams*/
    ALL_STREAMS = 1;
  }
  /** The type of request, one of the above. */
  Type reqType = 1;
  repeated StreamAddressRange streamsRanges = 2;
}

/**
 * Represents the response sent by the sequencer when streams address maps are requested
 * (i.e. StreamsAddressRequest)
 *
 * It contains a per stream map with its corresponding address space
 * (composed of the addresses of this stream and trim mark)
 */
message StreamsAddressResponse {
  uint64 logTail = 1;
  UUIDToStreamAddressMap addressMap = 2;
}

/**
 * LogUnit Definitions
 **/

message WriteLogRequest {

}

message WriteLogResponse {

}

message ReadLogRequest {

}

message ReadLogResponse {

}

message InspectAddressesRequest {

}

message InspectAddressesResponse {

}

message TrimLogRequest {

}

message TrimLogResponse {

}

message TrimMarkRequest {

}

message TrimMarkResponse {

}

message TailRequest {

}

message TailResponse {

}

message CompactRequest {

}

message CompactResponse {

}

message FlushCacheRequest {

}

message FlushCacheResponse {

}

message LogAddressSpaceRequest {

}

message LogAddressSpaceResponse {

}

message KnownAddressRequest {

}

message KnownAddressResponse {

}

message CommittedTailRequest {

}

message CommittedTailResponse {

}

message UpdateCommittedTailRequest {

}

message UpdateCommittedTailResponse {

}

message ResetLogUnitRequest {

}

message ResetLogUnitResponse {

}

/**
 * Management Definitions
 **/

message NodeConnectivity {
  message ConnectivityMapEntry {
    string key = 1;
    string value = 2;
  }

  string endpoint = 1;
  string connectivityType = 2;
  Entries connectivityMap = 3;
  int64 epoch = 4;
}

message QueryNodeRequest {
}

message QueryNodeResponse {
  SequencerMetrics sequencerMetrics = 1;
  NodeConnectivity nodeConnectivity = 2;
}

message ReportFailureRequest {
  int64 detectorEpoch = 1;
  repeated string failedNodes = 2;
}

message ReportFailureResponse {
  enum Type {
    ACK = 0;
    NACK = 1;
  }

  Type respType = 1;
}

message HealFailureRequest {
  int64 detectorEpoch = 1;
  repeated string healedNodes = 2;
}

message HealFailureResponse {
  enum Type {
    ACK = 0;
    NACK  = 1;
  }

  Type respType = 1;
}

message OrchestratorRequest {
  enum Type {
    QUERY_WORKFLOW = 0;
    ADD_NODE = 1;
    REMOVE_NODE = 2;
    HEAL_NODE = 3;
    FORCE_REMOVE_NODE = 4;
    RESTORE_REDUNDANCY_MERGE_SEGMENTS = 5;
  }

  message QueryWorkflow {
    UUID id = 1;
  }

  message ExecuteWorkflow {
    string endpoint = 1;
    int32  stripeIndex = 2;
    bool layoutServer = 3;
    bool sequencerServer = 4;
    bool logUnitServer = 5;
  }

  Type reqType = 1;

  oneof payload {
    QueryWorkflow queryWorkflow = 10;
    ExecuteWorkflow executeWorkflow = 11;
  }
}

message OrchestratorResponse {
  enum Type {
    WORKFLOW_STATUS = 0;
    WORKFLOW_CREATED = 1;
  }

  message QueryWorkflow {
    bool isActive = 1;
  }

  message CreateWorkflow {
    UUID workflowId = 1;
  }

  Type respType = 1;

  oneof payload {
    QueryWorkflow queryWorkflow = 10;
    CreateWorkflow createWorkflow = 11;
  }
}

message BootstrapManagementRequest {
  Layout layout = 1;
}

message BootstrapManagementResponse {
  enum Type {
    ACK = 0;
    NACK = 1;
  }

  Type respType = 1;
}

message GetManagementLayoutRequest {
}

message GetManagementLayoutResponse {
  Layout layout = 1;
}

/**
 * Request & Response Definitions
 **/

message Header {
  ProtocolVersion version = 1;
  int64 request_id = 2;
  Priority priority = 3;
  MessageType type = 4;
  int64 epoch = 5;
  UUID cluster_id = 6;
  UUID client_id = 7;
  bool ignore_cluster_id = 8;
  bool ignore_epoch = 9;
}

message Request {
  Header header = 1;

  oneof payload {
    // Base Requests
    PingRequest pingRequest = 10;
    AuthenticateRequest authenticateRequest = 11;
    RestartRequest restartRequest = 12;
    ResetRequest resetRequest = 13;
    SealRequest sealRequest = 14;

    // Layout Requests
    GetLayoutRequest getLayoutRequest = 20;
    PrepareLayoutRequest prepareLayoutRequest = 21;
    ProposeLayoutRequest proposeLayoutRequest = 22;
    CommitLayoutRequest commitLayoutRequest = 23;
    BootstrapLayoutRequest bootstrapLayoutRequest = 24;

    // Sequencer Requests
    TokenRequest tokenRequest = 30;
    BootStrapSequencerRequest bootStrapSequencerRequest = 31;
    SequencerTrimRequest sequencerTrimRequest = 32;
    SequencerMetricsRequest sequencerMetricsRequest = 33;
    StreamsAddressRequest streamsAddressRequest = 34;

    // LogUnit Requests
    WriteLogRequest writeLogRequest = 40;
    ReadLogRequest readLogRequest = 41;
    InspectAddressesRequest inspectAddressesRequest = 42;
    TrimLogRequest trimLogRequest = 43;
    TrimMarkRequest trimMarkRequest = 44;
    TailRequest tailRequest = 45;
    CompactRequest compactRequest = 46;
    FlushCacheRequest flushCacheRequest = 47;
    LogAddressSpaceRequest logAddressSpaceRequest = 48;
    KnownAddressRequest knownAddressRequest = 49;
    CommittedTailRequest committedTailRequest = 50;
    UpdateCommittedTailRequest updateCommittedTailRequest = 51;
    ResetLogUnitRequest resetLogUnitRequest = 52;

    // Management Requests
    QueryNodeRequest queryNodeRequest = 60;
    ReportFailureRequest reportFailureRequest = 61;
    HealFailureRequest healFailureRequest = 62;
    OrchestratorRequest orchestratorRequest = 63;
    BootstrapManagementRequest bootstrapManagementRequest = 64;
    GetManagementLayoutRequest getManagementLayoutRequest = 65;
  }
}

message Response {
  Header header = 1;
  ServerError error = 2;

  oneof payload {
    // Base Responses
    PingResponse pingResponse = 10;
    AuthenticateResponse authenticateResponse = 11;
    RestartResponse restartResponse = 12;
    ResetResponse resetResponse = 13;
    SealResponse sealResponse = 14;

    // Layout Responses
    GetLayoutResponse getLayoutResponse = 20;
    PrepareLayoutResponse prepareLayoutResponse = 21;
    ProposeLayoutResponse proposeLayoutResponse = 22;
    CommitLayoutResponse commitLayoutResponse = 23;
    BootstrapLayoutResponse bootstrapLayoutResponse = 24;

    // Sequencer Responses
    TokenResponse tokenResponse = 30;
    BootStrapSequencerResponse BootStrapSequencerResponse = 31;
    SequencerTrimResponse sequencerTrimResponse = 32;
    SequencerMetricsResponse sequencerMetricsResponse = 33;
    StreamsAddressResponse streamsAddressResponse = 34;

    // LogUnit Responses
    WriteLogResponse writeLogResponse = 40;
    ReadLogResponse readLogResponse = 41;
    InspectAddressesResponse inspectAddressesResponse = 42;
    TrimLogResponse trimLogResponse = 43;
    TrimMarkResponse trimMarkResponse = 44;
    TailResponse tailResponse = 45;
    CompactResponse compactResponse = 46;
    FlushCacheResponse flushCacheResponse = 47;
    LogAddressSpaceResponse logAddressSpaceResponse = 48;
    KnownAddressResponse knownAddressResponse = 49;
    CommittedTailResponse committedTailResponse = 50;
    UpdateCommittedTailResponse updateCommittedTailResponse = 51;
    ResetLogUnitResponse resetLogUnitResponse = 52;

    // Management Responses
    QueryNodeResponse queryNodeResponse = 60;
    ReportFailureResponse reportFailureResponse = 61;
    HealFailureResponse healFailureResponse = 62;
    OrchestratorResponse orchestratorResponse = 63;
    BootstrapManagementResponse bootstrapManagementResponse = 64;
    GetManagementLayoutResponse getManagementLayoutResponse = 65;
  }
}
