syntax = "proto3";

package org.corfudb.runtime;
option java_package = "org.corfudb.runtime.proto";

import "google/protobuf/any.proto";

//TODO: Reasonable way to determine version?
enum ProtocolVersion {
  PROTOCOL_VERSION_INVALID = 0;
  V0 = 1;
}

enum PriorityLevel {
  PRIORITY_LEVEL_INVALID = 0;
  NORMAL = 1;
  HIGH = 2;
}

message UuidMsg {
  int64 lsb = 1;
  int64 msb = 2;
}

message TokenMsg {
  int64 epoch = 1;
  int64 sequence = 2;
}

/**
 * Sequencer metrics for a node.
 */
message SequencerMetricsMsg {
  enum SequencerStatus {
    INVALID = 0;
    // Sequencer is in READY state, and can dispatch tokens.
    READY = 1;
    // Sequencer is in a NOT_READY state.
    NOT_READY = 2;
    // Unknown state.
    UNKNOWN = 3;
  }

  // Ready state of a sequencer to determine its READY/NOT_READY state.
  SequencerStatus sequencer_status = 1;
}

//TODO: Consider alternate representations of a Layout?
message LayoutMsg {
  string layout_json = 1;
}

/**
 * This class represents the space of all addresses belonging to a stream.
 *
 * A stream's address space is defined by:
 *       1. The collection of all addresses that belong to this stream.
 *       2. The trim mark (last trimmed address, i.e., an address that is no longer present and that was subsumed by
 *       a checkpoint).
 */
message StreamAddressSpaceMsg {
  //TODO: Why do we need NO_ADDRESSES?
  int32 NO_ADDRESSES = 1; // For numeric types, the default value is zero.

  // Holds the last trimmed address for this stream.
  // Note: keeping the last trimmed address is required in order to properly set the stream tail on sequencer resets
  // when a stream has been checkpointed and trimmed and there are no further updates to this stream.
  uint64 trim_mark = 2;

  // Holds the complete map of addresses for this stream. (of type Roaring64NavigableMap)
  bytes address_map = 3;
}

/**
 * This message represents a range of addresses for a stream.
 * This is used to request the address map of a stream in
 * a given boundary-- limits given by (end, start].
 */
message StreamAddressRangeMsg {
  UuidMsg stream_id = 1;
  // Start is inclusive
  int64 start = 2;
  // End is exclusive
  int64 end = 3;
}

// Used to store KVPs -- See pairs below
message MapMsg {
  repeated google.protobuf.Any key_value_pair = 1;
}

message UuidToListOfBytesPairMsg {
  UuidMsg key = 1;
  repeated bytes value = 2;
}

message UuidToLongPairMsg {
  UuidMsg key = 1;
  int64 value = 2;
}

message UuidToStreamAddressSpacePairMsg {
  UuidMsg key = 1;
  StreamAddressSpaceMsg value = 2;
}
