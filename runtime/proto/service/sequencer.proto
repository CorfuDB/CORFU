syntax = "proto3";

package org.corfudb.runtime;
option java_package = "org.corfudb.runtime.proto.service";

import "common.proto";
import "tx_resolution.proto";

/**
 * Represents the response sent by the sequencer when streams address maps are requested
 * (i.e. StreamsAddressRequest)
 *
 * It contains a per stream map with its corresponding address space
 * (composed of the addresses of this stream and trim mark)
 */
message StreamsAddressResponseMsg {
  uint64 log_tail = 1;
  // Map of (UUID, StreamAddressSpace) pairs
  MapMsg address_map = 2;
}

/**
  proto3 does not support non integer or string keys.
  This message contains a map of UUID to an array of bytes.
  The bytes array can be further parsed into a Set of bytes.
 */
message UUIDToListOfBytesPairMsg {
  UuidMsg key = 1;
  repeated bytes value = 2;
}

/**
 * A token request is at the heart of the Corfu log protocol.
 *
 * <p>There are four token request scenarios, designated by the relevant constants :
 * 0. TokenRequestType::TK_QUERY : Query of the current log tail and of specific stream-tails.
 * 1. TokenRequestType::TK_RAW : Ask for raw (global) log token(s).
 *              This extends the global log tail by the requested # of tokens.
 * 2. TokenRequestType::TK_MULTI_STREAM : Ask for token(s) on multiple streams.
 *          This extends both the global log tail, and each of the specified stream tails,
 *          by the requested # of tokens.
 * 3. TokenRequestType::TK_TX :
 *          First, check transaction resolution. If transaction can commit, then behave
 *          like TokenRequestType::TK_MULTI_STREAM.</p>
 */
message TokenRequestMsg {
  enum TokenRequestType {
    INVALID = 0;
    TK_QUERY = 1;
    TK_RAW = 2;
    TK_MULTI_STREAM = 3;
    TK_TX = 4;
  }

  TokenRequestType request_type = 11;
  int64 num_tokens = 12;
  repeated UuidMsg streams = 13;
  TxResolutionInfoMsg txn_resolution = 14;
}

/**
  proto3 does not support non integer or string keys.
  This message contains a map of UUID to an array of bytes.
  The bytes array can be further parsed into a Set of bytes.
 */
message UUIDToLongPairMsg {
  UuidMsg key = 1;
  int64 value = 2;
}

message TokenResponseMsg {
  /** the cause/type of response. */
  TokenType resp_type = 1;

  // In case of a conflict, signal to the client which key was responsible for the conflict.
  bytes conflict_key = 2;



  // In case of a conflict, signal to the client which stream was responsible for the conflict.
  UuidMsg conflict_stream = 3;

  /** The current token or global log tail in the case of stream tails query */
  TokenMsg token = 4;

  /**
    The backPointer map, if available.
    Map of (UUID, Long) pairs
  */
  MapMsg backpointer_map = 5;

  // Map of (UUID, Long) pairs
  MapMsg stream_tails = 6;
}

message UUIDToStreamAddressPairMsg {
  UuidMsg key = 1;
  StreamAddressSpaceMsg value = 2;
}

// SequencerRecoveryMsg
message BootstrapSequencerRequestMsg {
  int64 global_tail = 1;
  // Map of (UUID, StreamAddressSpace) pairs
  MapMsg streams_address_map = 2;
  int64 sequencer_epoch = 3;

  /**
   * Boolean flag to denote whether this bootstrap message is just updating an existing primary
   * sequencer with the new epoch (if set to true) or bootstrapping a currently NOT_READY
   * sequencer.
   */
  bool bootstrap_without_tails_update = 4;
}

message BootstrapSequencerResponseMsg {

}

message SequencerTrimRequestMsg {
  int64 trim_mark = 1;
}

message SequencerTrimResponseMsg {

}

message SequencerMetricsRequestMsg {

}

message SequencerMetricsResponseMsg {
  SequencerMetricsMsg sequencer_metrics = 1;
}

/**
 * Represents the request sent to the sequencer to retrieve one or several streams address map.
 */
message StreamsAddressRequestMsg {
  enum Type {
    INVALID = 0;
    /*To request specific streams*/
    STREAMS = 1;
    /*To request all streams*/
    ALL_STREAMS = 2;
  }
  /** The type of request, one of the above. */
  Type req_type = 1;
  repeated StreamAddressRangeMsg stream_range = 2;
}