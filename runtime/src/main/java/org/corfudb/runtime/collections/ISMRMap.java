package org.corfudb.runtime.collections;

import com.google.common.collect.ImmutableMap;
import org.corfudb.annotations.*;
import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.runtime.object.ICoalescableObject;
import org.corfudb.runtime.object.ISMREntry;
import org.corfudb.runtime.object.ISMREntryGenerator;

import java.util.*;

/**
 * Created by mwei on 1/9/16.
 */
public interface ISMRMap<K, V> extends Map<K, V>, ISMRObject, ICoalescableObject {

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any modification to
     * the map, since the size of the map could be potentially changed.
     */
    @Accessor
    @Override
    int size();

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any modification to
     * the map, since the size of the map could be potentially changed.
     */
    @Accessor
    @Override
    boolean isEmpty();

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any operation on the
     * given key.
     */
    @Accessor
    @Override
    boolean containsKey(@ConflictParameter Object key);

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any modification to
     * the map, since the presence of values could be potentially changed.
     */
    @Accessor
    @Override
    boolean containsValue(Object value);

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any operation on the
     * given key.
     */
    @Accessor
    @Override
    V get(@ConflictParameter Object key);

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @MutatorAccessor(name = "put", undoFunction = "undoPut", undoRecordFunction = "undoPutRecord")
    @Override
    V put(@ConflictParameter K key, V value);


    /**
     * This operation behaves like a put operation, but does not
     * return the previous value, and does not result in a read
     * of the map.
     *
     * Calling this operation produces the same put record as calling
     * "put" directly. However, the runtime will not try to sync
     * the object to obtain an upcall.
     *
     * Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @Mutator(name = "put", noUpcall = true)
    default void blindPut(@ConflictParameter K key, V value) {
        put(key, value);
    }

    /** Generate an undo record for a put, given the previous state of the map
     * and the parameters to the put call.
     *
     * @param previousState     The previous state of the map
     * @param key               The key from the put call
     * @param value             The value from the put call. This is not
     *                          needed to generate an undo record.
     * @return                  An undo record, which for a put is the
     *                          previous value in the map.
     */
    default V undoPutRecord(ISMRMap<K,V> previousState, K key, V value) {
        return previousState.get(key);
    }

    /** Undo a put, given the current state of the map, an undo record
     * and the arguments to the put command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoPutRecord
     * @param key           The key of the put to undo
     * @param value         The value of the put to undo, which is not
     *                      needed.
     */
    default void undoPut(ISMRMap<K,V> map, V undoRecord, K key, V value) {
        if (undoRecord == null) {
            map.remove(key);
        }
        else {
            map.put(key, undoRecord);
        }
    }

    /**
     * {@jnheritDoc}
     *
     * Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @MutatorAccessor(name="remove", undoFunction = "undoRemove", undoRecordFunction = "undoRemoveRecord")
    @Override
    V remove(@ConflictParameter Object key);

    /** Generate an undo record for a remove, given the previous state of the map
     * and the parameters to the remove call.
     *
     * @param previousState     The previous state of the map
     * @param key               The key from the remove call
     * @return                  An undo record, which for a remove is the
     *                          previous value in the map.
     */
    default V undoRemoveRecord(ISMRMap<K,V> previousState, K key) {
        return previousState.get(key);
    }

    /** Undo a remove, given the current state of the map, an undo record
     * and the arguments to the remove command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoRemoveRecord
     */
    default void undoRemove(ISMRMap<K,V> map, V undoRecord, K key) {
        if (undoRecord == null) {
            map.remove(key);
        }
        else {
            map.put(key, undoRecord);
        }
    }

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts on any keys that are in the map given.
     */
    @Mutator(name="putAll", undoFunction="undoPutAll",
            undoRecordFunction="undoPutAllRecord", conflictParameterFunction="putAllConflictFunction")
    @Override
    void putAll(Map<? extends K, ? extends V> m);


    /** Generate the conflict parameters for putAll, given the arguments to the
     * putAll operation.
     * @param m                 The map for the putAll operation.
     * @return                  An array of conflict parameters, which are the
     *                          hash codes of the keys given.
     */
    default Object[] putAllConflictFunction(Map<? extends K, ? extends V> m) {
        return m.keySet().stream()
                .map(Object::hashCode)
                .toArray(Object[]::new);
    }

    enum UndoNullable {
        NULL;
    }

    /** Generate an undo record for putAll, given the previous state of the map
     * and the parameters to the putAll call.
     *
     * @param previousState     The previous state of the map
     * @param m                 The map from the putAll call
     * @return                  An undo record, which for a putAll is all the
     *                          previous entries in the map.
     */
    default Map<K,V> undoPutAllRecord(ISMRMap<K,V> previousState, Map<? extends K, ? extends V> m) {
        ImmutableMap.Builder<K,V> builder = ImmutableMap.builder();
        m.keySet().forEach(k -> builder.put(k,
                (previousState.get(k) == null ? (V) UndoNullable.NULL : previousState.get(k))));
        return builder.build();
    }

    /** Undo a remove, given the current state of the map, an undo record
     * and the arguments to the remove command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoRemoveRecord
     */
    default void undoPutAll(ISMRMap<K,V> map, Map<K,V> undoRecord, Map<? extends K, ? extends V> m) {
        undoRecord.entrySet().forEach(e -> {
                    if (e.getValue() == UndoNullable.NULL) { map.remove(e.getKey()); }
                    else { map.put(e.getKey(), e.getValue()); }
                });
    }


    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with the entire map, since it drops
     * all mappings which are present.
     */
    @Mutator(name="clear", reset=true)
    @Override
    void clear();

    /**
     * {@inheritDoc}
     *
     * This function currently does not return a view like the java.util implementation,
     * and changes to the keySet will *not* be reflected in the map.
     *
     * Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Set<K> keySet();

    /**
     * {@inheritDoc}
     *
     * This function currently does not return a view like the java.util implementation,
     * and changes to the values will *not* be reflected in the map.
     *
     * Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Collection<V> values();

    /**
     * {@inheritDoc}
     *
     * This function currently does not return a view like the java.util implementation,
     * and changes to the entrySet will *not* be reflected in the map.
     *
     * Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Set<Entry<K, V>> entrySet();

    @Override
    default List<ISMREntry> coalesceUpdates(List<ISMREntry> updates, ISMREntryGenerator generator) {
        // The coalesced entry can have three components: a clear call, and a list of put and remove calls.
        final Set<K> seenKeys = new HashSet<>();
        final Map<K,V> putMap = new HashMap<>();

        // Iterate through all the entries, starting from the end.
        List<ISMREntry> newUpdates = new ArrayList<>();
        ListIterator<ISMREntry> updateIterator = updates.listIterator(updates.size());
        while (updateIterator.hasPrevious()) {
            ISMREntry entry = updateIterator.previous();
            // clear any undo information, since
            // it will be wrong.
            entry.clearUndoRecord();
            if (entry.getSMRMethod().equals("clear")) {
                // If this is a clear call, we can stop
                // since nothing before this call is needed
                // but we need to add the clear call itself
                // as the first record.
                newUpdates.add(0, entry);
                break;
            }
            else if (entry.getSMRMethod().equals("put")) {
                // If a remove entry doesn't already exist for this
                // put, add it to the list of put calls.
                if (!seenKeys.contains(entry.getSMRArguments()[0])) {
                    seenKeys.add((K)entry.getSMRArguments()[0]);
                    putMap.put((K) entry.getSMRArguments()[0],
                            (V) entry.getSMRArguments()[1]);
                }
            }
            else if (entry.getSMRMethod().equals("putAll")) {
                // same as above.
                Map<K,V> entryMap = ((Map<K,V>)entry.getSMRArguments()[0]);
                entryMap.entrySet().stream()
                        .filter(e -> !seenKeys.contains(e.getKey()))
                        .forEach(e -> {
                            seenKeys.add(e.getKey());
                            putMap.put(e.getKey(), e.getValue());
                        });
            }
            else if (entry.getSMRMethod().equals("remove")) {
                // if the remove isn't remapped by a subsequent put
                if (!seenKeys.contains(entry.getSMRArguments()[0])) {
                    newUpdates.add(entry);
                }
            }
        }

        // Merge all the put calls by generating one large putAll call, unless there's only one entry.
        if (putMap.size() == 1) {
            Entry<K,V> entry = putMap.entrySet().iterator().next();
            newUpdates.add(generator.generate("put", new Object[] {entry.getKey(), entry.getValue()}
                , false, null));
        } else if (putMap.size() > 1) {
            newUpdates.add(generator.generate("putAll", new Object[] {putMap},
                    false, null));
        }
        return newUpdates;
    }
}
