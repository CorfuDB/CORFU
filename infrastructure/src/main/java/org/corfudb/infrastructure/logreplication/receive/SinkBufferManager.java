package org.corfudb.infrastructure.logreplication.receive;

import lombok.extern.slf4j.Slf4j;

import org.corfudb.protocols.wireprotocol.logreplication.LogReplicationEntry;
import org.corfudb.protocols.wireprotocol.logreplication.LogReplicationEntryMetadata;
import org.corfudb.protocols.wireprotocol.logreplication.MessageType;

import java.util.HashMap;

@Slf4j
/**
 * For snapshot sync and log entry sync, it is possible that the messages generated by the primary site will
 * be delivered out of order due to message loss due to network connect loss or congestion. At the backup site
 * we keep a buffer to store the out of order messages and apply them at the backup site in order.
 * For snapshot sync, the message will be applied according the seqNumber.
 * For log entry sync, each message has a pre pointer that is a timestamp of the premessage, this guarantees that
 * the messages will be applied in order.
 * At the same time, we should back an ACK to the primary site to notify the primary site any possible data loss.
 */
public abstract class SinkBufferManager {
    // It is implemented as a hashmap.
    HashMap<Long, LogReplicationEntry> buffer;
    LogReplicationSinkManager sinkManager;
    MessageType type;
    int size;

    // How frequent in time, the ack will be sent.
    private int ackCycleTime;

    // If ackCycleCnt number of messages has been processed, it will trigger an ack too.
    private int ackCycleCnt;

    // Reset the ackCnt after sending an ACK
    private int ackCnt = 0;
    private long ackTime = 0;

    // The message with the key are expecting.
    // For snapshot sync, the ack should be nextKey - 1
    // For log entry sync, the ack is the nextKey which is the timestamp the last log
    // entry has been processed.
    long lastProcessedTs;

    public SinkBufferManager(MessageType type, int ackCycleTime, int ackCycleCnt, int size, long lastProcessedTs, LogReplicationSinkManager sinkManager) {
        this.type = type;
        this.ackCycleTime = ackCycleTime;
        this.ackCycleCnt = ackCycleCnt;
        this.size = size;
        this.sinkManager = sinkManager;
        this.lastProcessedTs = lastProcessedTs;
        buffer = new HashMap<>();
    }

    void processBuffer() {
        while (true) {
            LogReplicationEntry dataMessage = buffer.get(lastProcessedTs);
            if (dataMessage == null)
                return;
            sinkManager.receiveWithoutBuffering(dataMessage);
            buffer.remove(lastProcessedTs);
            lastProcessedTs = getCurrentTs(dataMessage);
        }
    }

    boolean shouldAck(LogReplicationEntry entry) {
        ackCnt++;

        long currentTime = java.lang.System.currentTimeMillis();
        if (ackCnt == ackCycleCnt || (currentTime - ackTime) >= ackCycleTime) {
            ackCnt = 0;
            ackTime = currentTime;
            return true;
        }

        return false;
    }

    /**
     * If the message is the expected message, will push down to sinkManager to process it.
     * Then process the message in the buffer if the next expected messages are in the buffer in order.
     * Otherwise put the received message into the buffer.
     * At the end according to the ack policy, send ack.
     * @param dataMessage
     */
    public LogReplicationEntry processMsgAndBuffer(LogReplicationEntry dataMessage) {

        if (verifyMessageType(dataMessage) == false)
           return null;

        long preTs = getPreTs(dataMessage);

        System.out.print("\nSink Buffer lastProcessedTs " + lastProcessedTs + " currePreTs " + preTs);
        if (preTs == lastProcessedTs) {
            sinkManager.receiveWithoutBuffering(dataMessage);
            lastProcessedTs = getCurrentTs(dataMessage);
            processBuffer();
        } else {
            buffer.put(preTs, dataMessage);
        }

        /*
         * send ack up to
         */
        if (shouldAck(dataMessage)) {
            LogReplicationEntryMetadata metadata = makeAckMessage(dataMessage);
            return new LogReplicationEntry(metadata, new byte[0]);
        }

        return null;
    }

    abstract long getPreTs(org.corfudb.protocols.wireprotocol.logreplication.LogReplicationEntry entry);

    abstract long getCurrentTs(LogReplicationEntry entry);

    public abstract LogReplicationEntryMetadata makeAckMessage(LogReplicationEntry entry);

    public abstract boolean verifyMessageType(LogReplicationEntry entry);
}
