<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Layout.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">infrastructure</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.view</a> &gt; <span class="el_source">Layout.java</span></div><h1>Layout.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.view;

import static java.util.Objects.requireNonNull;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import lombok.Data;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.exceptions.QuorumUnreachableException;
import org.corfudb.runtime.view.ClusterStatusReport.ClusterStatus;
import org.corfudb.runtime.view.replication.ChainReplicationProtocol;
import org.corfudb.runtime.view.replication.IReplicationProtocol;
import org.corfudb.runtime.view.replication.NeverHoleFillPolicy;
import org.corfudb.runtime.view.replication.QuorumReplicationProtocol;
import org.corfudb.runtime.view.replication.ReadWaitHoleFillPolicy;
import org.corfudb.runtime.view.stream.AddressMapStreamView;
import org.corfudb.runtime.view.stream.BackpointerStreamView;
import org.corfudb.runtime.view.stream.IStreamView;
import org.corfudb.runtime.view.stream.ThreadSafeStreamView;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * This class represents the layout of a Corfu instance.
 * Created by mwei on 12/8/15.
 */
<span class="nc bnc" id="L41" title="All 48 branches missed.">@Data</span>
public class Layout {

    /**
     * Sorting layouts according to epochs in descending order
     */
<span class="fc" id="L47">    public static final Comparator&lt;Layout&gt; LAYOUT_COMPARATOR = Comparator.comparing(Layout::getEpoch).reversed();</span>

    /**
     * A Gson parser.
     */
<span class="nc" id="L52">    @Getter</span>
<span class="fc" id="L53">    static final Gson parser = new GsonBuilder()</span>
<span class="fc" id="L54">            .registerTypeAdapter(Layout.class, new LayoutDeserializer())</span>
<span class="fc" id="L55">            .create();</span>
    /**
     * A list of layout servers in the layout.
     */
<span class="nc" id="L59">    @Getter</span>
    List&lt;String&gt; layoutServers;
    /**
     * A list of sequencers in the layout.
     */
<span class="nc" id="L64">    @Getter</span>
    List&lt;String&gt; sequencers;
    /**
     * A list of the segments in the layout.
     */
<span class="nc" id="L69">    @Getter</span>
    List&lt;LayoutSegment&gt; segments;
    /**
     * A list of unresponsive nodes in the layout.
     */
<span class="nc" id="L74">    @Getter</span>
    List&lt;String&gt; unresponsiveServers;
    /**
     * The epoch of this layout.
     */
<span class="nc" id="L79">    @Getter</span>
<span class="nc" id="L80">    @Setter</span>
    long epoch;

    /**
     * Invalid epoch value.
     * Is used to fetch layout(epoch agnostic request) by the corfuRuntime.
     */
    public static final long INVALID_EPOCH = -1L;

    /** The unique Id for the Corfu cluster represented by this layout.
     *  Should remain consistent for the lifetime of the layout. May be
     *  {@code null} in a legacy layout.
     */
<span class="nc" id="L93">    @Getter</span>
    UUID clusterId;

    /**
     * Defensive constructor since we can create a Layout from a JSON file.
     * JSON deserialize is forced through this constructor.
     */
<span class="nc bnc" id="L100" title="All 4 branches missed.">    public Layout(@NonNull List&lt;String&gt; layoutServers, @NonNull List&lt;String&gt; sequencers,</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">                  @NonNull List&lt;LayoutSegment&gt; segments, @NonNull List&lt;String&gt; unresponsiveServers,</span>
<span class="nc" id="L102">                  long epoch, @Nullable UUID clusterId) {</span>

<span class="nc" id="L104">        this.layoutServers = layoutServers;</span>
<span class="nc" id="L105">        this.sequencers = sequencers;</span>
<span class="nc" id="L106">        this.segments = segments;</span>
<span class="nc" id="L107">        this.unresponsiveServers = unresponsiveServers;</span>
<span class="nc" id="L108">        this.epoch = epoch;</span>
<span class="nc" id="L109">        this.clusterId = clusterId;</span>

        /* Assert that we constructed a valid Layout */
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (this.layoutServers.size() == 0) {</span>
<span class="nc" id="L113">            throw new IllegalArgumentException(&quot;Empty list of LayoutServers&quot;);</span>
        }
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (this.sequencers.size() == 0) {</span>
<span class="nc" id="L116">            throw new IllegalArgumentException(&quot;Empty list of Sequencers&quot;);</span>
        }
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (this.segments.size() == 0) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(&quot;Empty list of segments&quot;);</span>
        }
<span class="nc bnc" id="L121" title="All 2 branches missed.">        for (Layout.LayoutSegment segment : segments) {</span>
<span class="nc" id="L122">            requireNonNull(segment.stripes);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">            if (segment.stripes.size() == 0) {</span>
<span class="nc" id="L124">                throw new IllegalArgumentException(&quot;One segment has an empty list of stripes&quot;);</span>
            }
<span class="nc" id="L126">        }</span>
<span class="nc" id="L127">    }</span>

    public Layout(List&lt;String&gt; layoutServers, List&lt;String&gt; sequencers, List&lt;LayoutSegment&gt; segments,
                  long epoch, UUID clusterId) {
<span class="nc" id="L131">        this(layoutServers, sequencers, segments, new ArrayList&lt;String&gt;(), epoch, clusterId);</span>
<span class="nc" id="L132">    }</span>

    /**
     * Get a layout from a JSON string.
     */
    @SuppressWarnings({&quot;checkstyle:abbreviation&quot;})
    public static Layout fromJSONString(String json) {
        /* Empty Json file creates an null Layout */
<span class="nc" id="L140">        return requireNonNull(parser.fromJson(json, Layout.class));</span>
    }

    /**
     * Return all the segments that an endpoint participates in.
     * @param endpoint the endpoint to return all the segments for
     * @return a set of segments that contain the endpoint
     */
    public List&lt;LayoutSegment&gt; getSegmentsForEndpoint(@Nonnull String endpoint) {
<span class="nc" id="L149">        List&lt;LayoutSegment&gt; res = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">        for (LayoutSegment segment : getSegments()) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            for (LayoutStripe stripe : segment.getStripes()) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                if (stripe.getLogServers().contains(endpoint)) {</span>
<span class="nc" id="L154">                    res.add(segment);</span>
                }
<span class="nc" id="L156">            }</span>
<span class="nc" id="L157">        }</span>

<span class="nc" id="L159">        return res;</span>
    }

    /**
     * This function returns a set of all active servers in the layout.
     *
     * @return A set containing all servers in the layout.
     */
    public Set&lt;String&gt; getAllActiveServers() {
<span class="nc" id="L168">        Set&lt;String&gt; activeServers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L169">        activeServers.addAll(layoutServers);</span>
<span class="nc" id="L170">        activeServers.addAll(sequencers);</span>
<span class="nc" id="L171">        segments.forEach(x -&gt;</span>
<span class="nc" id="L172">                x.getStripes().forEach(y -&gt;</span>
<span class="nc" id="L173">                        activeServers.addAll(y.getLogServers())));</span>
<span class="nc" id="L174">        activeServers.removeAll(unresponsiveServers);</span>
<span class="nc" id="L175">        return activeServers;</span>
    }

    /**
     * This function returns a set of all servers in the layout.
     *
     * @return A set of all servers in the layout.
     */
    public Set&lt;String&gt; getAllServers() {
<span class="nc" id="L184">        Set&lt;String&gt; allServers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L185">        allServers.addAll(getAllActiveServers());</span>
<span class="nc" id="L186">        allServers.addAll(unresponsiveServers);</span>
<span class="nc" id="L187">        return allServers;</span>
    }

    /**
     * Returns the primary sequencer.
     *
     * @return The primary sequencer.
     */
    public String getPrimarySequencer() {
<span class="nc" id="L196">        return sequencers.get(0);</span>
    }

    /**
     * Given the log's global address, return equivalent local address for a striped log segment.
     *
     * @param globalAddress The global address
     */
    public long getLocalAddress(long globalAddress) {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L206" title="All 6 branches missed.">            if (ls.start &lt;= globalAddress &amp;&amp; (ls.end &gt; globalAddress || ls.end == -1)) {</span>
                // TODO: this does not account for shifting segments.
<span class="nc" id="L208">                return globalAddress / ls.getNumberOfStripes();</span>
            }
<span class="nc" id="L210">        }</span>
<span class="nc" id="L211">        throw new RuntimeException(&quot;Unmapped address!&quot;);</span>
    }

    /**
     * Return global address for a given stripe.
     *
     * @param stripe The layout stripe.
     * @param localAddress The local address.
     */
    public long getGlobalAddress(LayoutStripe stripe, long localAddress) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (ls.getStripes().contains(stripe)) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">                for (int i = 0; i &lt; ls.getNumberOfStripes(); i++) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                    if (ls.getStripes().get(i).equals(stripe)) {</span>
<span class="nc" id="L225">                        return (localAddress * ls.getNumberOfStripes()) + i;</span>
                    }
                }
            }
<span class="nc" id="L229">        }</span>
<span class="nc" id="L230">        throw new RuntimeException(&quot;Unmapped address!&quot;);</span>
    }

    /** Return a list of segments which contain global
     * addresses less than or equal to the given address
     * (known as the prefix).
     *
     * @param globalAddress The global address prefix
     *                      to use.
     * @return              A list of segments which
     *                      contain addresses less than
     *                      or equal to the global
     *                      address.
     */
    public @Nonnull List&lt;LayoutSegment&gt; getPrefixSegments(long globalAddress) {
<span class="nc" id="L245">        return segments.stream()</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                .filter(p -&gt; p.getEnd() &lt;= globalAddress)</span>
<span class="nc" id="L247">                .collect(Collectors.toList());</span>
    }

    /**
     * Return layout segment stripe.
     *
     * @param globalAddress The global address.
     */
    public LayoutStripe getStripe(long globalAddress) {
<span class="nc" id="L256">        LayoutSegment ls = getSegment(globalAddress);</span>
<span class="nc" id="L257">        return ls.getStripes().get((int) (globalAddress % ls.getNumberOfStripes()));</span>
    }

    /**
     * Return layout segment.
     *
     * @param globalAddress The global address.
     */
    public LayoutSegment getSegment(long globalAddress) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L267" title="All 6 branches missed.">            if (ls.start &lt;= globalAddress &amp;&amp; (ls.end &gt; globalAddress || ls.end == -1)) {</span>
<span class="nc" id="L268">                return ls;</span>
            }
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">        throw new RuntimeException(&quot;Unmapped address &quot; + Long.toString(globalAddress) + &quot;!&quot;);</span>
    }

    /**
     * Get the first segment.
     * @return Returns the segment at index 0.
     */
    public LayoutSegment getFirstSegment() {
<span class="nc" id="L279">        return this.getSegments().get(0);</span>
    }

    /**
     * Return latest segment.
     * @return the latest segment.
     */
    public LayoutSegment getLatestSegment() {
<span class="nc" id="L287">        return this.getSegments().get(this.getSegments().size() - 1);</span>
    }

    /**
     * Get the last node in the last segment.
     *
     * @return Returns the last node in the last segment.
     */
    public String getLastAddedNodeInLastSegment() {

        // Fetching the latest segment. Note: This is the unbounded segment with ongoing writes.
        // Returning the last node in the first stripe for determinism.
<span class="nc" id="L299">        List&lt;String&gt; firstStripeLogServers = getLatestSegment().getFirstStripe().getLogServers();</span>
<span class="nc" id="L300">        return firstStripeLogServers.get(firstStripeLogServers.size() - 1);</span>
    }

    /**
     * Get the length of a segment at a particular address.
     *
     * @param address The address to check.
     * @return The length (number of servers) of that segment, or 0 if empty.
     */
    public int getSegmentLength(long address) {
<span class="nc" id="L310">        return getStripe(address).getLogServers().size();</span>
    }

    /**
     * Get the replication mode of a segment at a particular address.
     *
     * @param address The address to check.
     * @return The replication mode of the segment, or null if empty.
     */
    public ReplicationMode getReplicationMode(long address) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L321" title="All 6 branches missed.">            if (ls.start &lt;= address &amp;&amp; (ls.end &gt; address || ls.end == -1)) {</span>
<span class="nc" id="L322">                return ls.getReplicationMode();</span>
            }
<span class="nc" id="L324">        }</span>
<span class="nc" id="L325">        return null;</span>
    }

    /**
     * Get the layout as a JSON string.
     */
    @SuppressWarnings({&quot;checkstyle:abbreviation&quot;})
    public String asJSONString() {
<span class="nc" id="L333">        return parser.toJson(this);</span>
    }

    /**
     *
     * Layout copy constructor.
     *
     * @param layout layout to copy
     */
<span class="nc" id="L342">    public Layout(@Nonnull Layout layout) {</span>
<span class="nc" id="L343">        Layout layoutCopy = parser.fromJson(layout.asJSONString(), Layout.class);</span>
<span class="nc" id="L344">        this.layoutServers = layoutCopy.getLayoutServers();</span>
<span class="nc" id="L345">        this.sequencers = layoutCopy.getSequencers();</span>
<span class="nc" id="L346">        this.segments = layoutCopy.getSegments();</span>
<span class="nc" id="L347">        this.unresponsiveServers = layoutCopy.getUnresponsiveServers();</span>
<span class="nc" id="L348">        this.epoch = layoutCopy.getEpoch();</span>
<span class="nc" id="L349">        this.clusterId = layoutCopy.clusterId;</span>
<span class="nc" id="L350">    }</span>

    public void nextEpoch() {
<span class="nc" id="L353">        epoch += 1;</span>
<span class="nc" id="L354">    }</span>

    public ImmutableList&lt;String&gt; getActiveLayoutServers() {
<span class="nc" id="L357">        return layoutServers.stream()</span>
                // Unresponsive servers are excluded as they do not respond with a WrongEpochException.
<span class="nc bnc" id="L359" title="All 2 branches missed.">                .filter(s -&gt; !unresponsiveServers.contains(s))</span>
<span class="nc" id="L360">                .collect(ImmutableList.toImmutableList());</span>
    }

<span class="nc" id="L363">    public enum ReplicationMode {</span>
<span class="nc" id="L364">        CHAIN_REPLICATION {</span>
            @Override
            public void validateSegmentSeal(LayoutSegment layoutSegment,
                                            Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                    completableFutureMap)
                    throws QuorumUnreachableException {
<span class="nc" id="L370">                SealServersHelper.waitForChainSegmentSeal(layoutSegment, completableFutureMap);</span>
<span class="nc" id="L371">            }</span>

            @Override
            public int getMinReplicationFactor(Layout layout, LayoutStripe stripe) {
<span class="nc" id="L375">                return 1;</span>
            }

            @Override
            public IStreamView  getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L380">                return new ThreadSafeStreamView(r, streamId, options);</span>
            }

            @Override
            public IStreamView getUnsafeStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (r.getParameters().isFollowBackpointersEnabled()) {</span>
<span class="nc" id="L386">                    return new BackpointerStreamView(r, streamId, options);</span>
                } else {
<span class="nc" id="L388">                    return new AddressMapStreamView(r, streamId, options);</span>
                }
            }

            @Override
            public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">                if (r.getParameters().isHoleFillingDisabled()) {</span>
<span class="nc" id="L395">                    return new ChainReplicationProtocol(new NeverHoleFillPolicy(100));</span>
                } else {
<span class="nc" id="L397">                    return new ChainReplicationProtocol(</span>
<span class="nc" id="L398">                            new ReadWaitHoleFillPolicy(r.getParameters().getHoleFillTimeout(),</span>
<span class="nc" id="L399">                                    r.getParameters().getHoleFillRetryThreshold()));</span>
                }
            }

            @Override
            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,
                                                            Set&lt;String&gt; responsiveNodes) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">                return !responsiveNodes.containsAll(layoutSegment.getAllLogServers())</span>
                        ? ClusterStatus.UNAVAILABLE : ClusterStatus.STABLE;
            }
        },
<span class="nc" id="L410">        QUORUM_REPLICATION {</span>
            @Override
            public void validateSegmentSeal(LayoutSegment layoutSegment,
                                            Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                    completableFutureMap)
                    throws QuorumUnreachableException {
                //TODO: Take care of log unit servers which were not sealed.
<span class="nc" id="L417">                SealServersHelper.waitForQuorumSegmentSeal(layoutSegment, completableFutureMap);</span>
<span class="nc" id="L418">            }</span>

            @Override
            public int getMinReplicationFactor(Layout layout, LayoutStripe stripe) {
<span class="nc" id="L422">                return (stripe.getLogServers().size() / 2) + 1;</span>
            }

            @Override
            public IStreamView  getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L427">                return new ThreadSafeStreamView(r, streamId, options);</span>
            }

            @Override
            public IStreamView getUnsafeStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (r.getParameters().isFollowBackpointersEnabled()) {</span>
<span class="nc" id="L433">                    return new BackpointerStreamView(r, streamId, options);</span>
                } else {
<span class="nc" id="L435">                    return new AddressMapStreamView(r, streamId, options);</span>
                }
            }

            @Override
            public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {
<span class="nc bnc" id="L441" title="All 2 branches missed.">                if (r.getParameters().isHoleFillingDisabled()) {</span>
<span class="nc" id="L442">                    return new QuorumReplicationProtocol(new NeverHoleFillPolicy(100));</span>
                } else {
<span class="nc" id="L444">                    return new QuorumReplicationProtocol(</span>
<span class="nc" id="L445">                            new ReadWaitHoleFillPolicy(r.getParameters().getHoleFillTimeout(),</span>
<span class="nc" id="L446">                                    r.getParameters().getHoleFillRetryThreshold()));</span>
                }
            }

            @Override
            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,
                                                            Set&lt;String&gt; responsiveNodes) {
<span class="nc" id="L453">                ClusterStatus clusterStatus = ClusterStatus.STABLE;</span>
                // At least a quorum of nodes should be reachable in every stripe for the cluster
                // to be STABLE.
<span class="nc bnc" id="L456" title="All 2 branches missed.">                for (LayoutStripe layoutStripe : layoutSegment.getStripes()) {</span>
<span class="nc" id="L457">                    List&lt;String&gt; responsiveLogServers</span>
<span class="nc" id="L458">                            = new ArrayList&lt;&gt;(layoutStripe.getLogServers());</span>
                    // Retain only the responsive servers.
<span class="nc" id="L460">                    responsiveLogServers.retainAll(responsiveNodes);</span>

<span class="nc bnc" id="L462" title="All 2 branches missed.">                    if (!responsiveLogServers.containsAll(layoutStripe.getLogServers())) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                        if (clusterStatus.equals(ClusterStatus.STABLE)) {</span>
<span class="nc" id="L464">                            clusterStatus = ClusterStatus.DEGRADED;</span>
                        }
<span class="nc" id="L466">                        int quorumSize = (layoutStripe.getLogServers().size() / 2) + 1;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                        if (responsiveLogServers.size() &lt; quorumSize) {</span>
<span class="nc" id="L468">                            clusterStatus = ClusterStatus.UNAVAILABLE;</span>
<span class="nc" id="L469">                            break;</span>
                        }
                    }
<span class="nc" id="L472">                }</span>
<span class="nc" id="L473">                return clusterStatus;</span>
            }

<span class="nc" id="L476">        }, NO_REPLICATION {</span>
            @Override
            public void validateSegmentSeal(LayoutSegment layoutSegment,
                                            Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                    completableFutureMap)
                    throws QuorumUnreachableException {
<span class="nc" id="L482">                throw new UnsupportedOperationException(&quot;unsupported seal&quot;);</span>
            }

            @Override
            public int getMinReplicationFactor(Layout layout, LayoutStripe stripe) {
<span class="nc" id="L487">                return 1;</span>
            }

            @Override
            public IStreamView getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L492">                throw new UnsupportedOperationException(&quot;Stream view used without a&quot;</span>
                        + &quot; replication mode&quot;);
            }

            @Override
            public IStreamView getUnsafeStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L498">                throw new UnsupportedOperationException(&quot;Stream view used without a&quot;</span>
                        + &quot; replication mode&quot;);
            }

            @Override
            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,
                                                            Set&lt;String&gt; responsiveNodes) {
<span class="nc" id="L505">                throw new UnsupportedOperationException(&quot;Unsupported cluster health check.&quot;);</span>
            }
        };

        /**
         * Seals the layout segment.
         */
        public abstract void validateSegmentSeal(LayoutSegment layoutSegment,
                                                 Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                         completableFutureMap)
                throws QuorumUnreachableException;

        /**
         * Compute the min replication factor for the log unit servers in the replication protocol
         * for a specific stripe.
         *
         * @param layout the layout to compute the min replication factor for.
         * @param stripe The stripe for which the minimum replication factor is needed.
         * @return the minimum amount of nodes required to maintain replication
         */
        public abstract int getMinReplicationFactor(Layout layout, LayoutStripe stripe);

        public abstract IStreamView getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options);

        public abstract IStreamView getUnsafeStreamView(CorfuRuntime r, UUID streamId, StreamOptions options);

        public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {
<span class="nc" id="L532">            throw new UnsupportedOperationException();</span>
        }

        /**
         * Returns the health of the cluster for a given segment.
         *
         * @param layoutSegment   Layout Segment
         * @param responsiveNodes Set of all responsive nodes.
         * @return Cluster Health.
         */
        public abstract ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment, Set&lt;String&gt; responsiveNodes);
    }


<span class="nc bnc" id="L546" title="All 26 branches missed.">    @Data</span>
    @Getter
<span class="nc" id="L548">    @Setter</span>
    public static class LayoutSegment {
        /**
         * The replication mode of the segment.
         */
<span class="nc" id="L553">        ReplicationMode replicationMode;</span>

        /**
         * The address the layout segment starts at. (included in the segment)
         */
<span class="nc" id="L558">        long start;</span>

        /**
         * The address the layout segment ends at. (excluded from the segment)
         */
<span class="nc" id="L563">        long end;</span>

        /**
         * A list of log servers for this segment.
         */
<span class="nc" id="L568">        List&lt;LayoutStripe&gt; stripes;</span>

        /**
         * Constructor Layout Segment, contiguous partition in a Corfu Log.
         *
         * &lt;p&gt;For example, [1...100], [101...200], [201...), where the last segment is active and
         * open ended.&lt;/p&gt;
         *
         * @param replicationMode The layout segment replication mode.
         * @param start The start address for layout segment (e.g., 1).
         * @param end  The end address for layout segment. (e.g., 100)
         * @param stripes List of stripes for layout segment.
         */
<span class="nc bnc" id="L581" title="All 2 branches missed.">        public LayoutSegment(@NonNull ReplicationMode replicationMode, long start, long end,</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                             @NonNull List&lt;LayoutStripe&gt; stripes) {</span>
<span class="nc" id="L583">            this.replicationMode = replicationMode;</span>
<span class="nc" id="L584">            this.start = start;</span>
<span class="nc" id="L585">            this.end = end;</span>
<span class="nc" id="L586">            this.stripes = stripes;</span>

<span class="nc" id="L588">        }</span>

        public int getNumberOfStripes() {
<span class="nc" id="L591">            return stripes.size();</span>
        }

        /**
         * Gets the first stripe.
         *
         * @return Returns the stripe at index 0.
         */
        public LayoutStripe getFirstStripe() {
<span class="nc" id="L600">            return stripes.get(0);</span>
        }

        /**
         * Get all servers from all stripes present in this segment.
         *
         * @return Set of log unit servers.
         */
        public Set&lt;String&gt; getAllLogServers() {
<span class="nc" id="L609">            return this.getStripes().stream()</span>
<span class="nc" id="L610">                    .flatMap(layoutStripe -&gt; layoutStripe.getLogServers().stream())</span>
<span class="nc" id="L611">                    .collect(Collectors.toSet());</span>
        }
    }

<span class="nc bnc" id="L615" title="All 14 branches missed.">    @Data</span>
    @Getter
    public static class LayoutStripe {
<span class="nc" id="L618">        final List&lt;String&gt; logServers;</span>

<span class="nc bnc" id="L620" title="All 2 branches missed.">        public LayoutStripe(@NonNull List&lt;String&gt; logServers) {</span>
<span class="nc" id="L621">            this.logServers = logServers;</span>
<span class="nc" id="L622">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>