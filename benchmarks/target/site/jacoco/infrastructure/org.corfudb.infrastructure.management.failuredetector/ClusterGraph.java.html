<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClusterGraph.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">benchmarks</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure.management.failuredetector</a> &gt; <span class="el_source">ClusterGraph.java</span></div><h1>ClusterGraph.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure.management.failuredetector;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import lombok.Builder;
import lombok.NonNull;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.wireprotocol.ClusterState;
import org.corfudb.protocols.wireprotocol.NodeState;
import org.corfudb.protocols.wireprotocol.failuredetector.FailureDetectorMetrics.ConnectivityGraph;
import org.corfudb.protocols.wireprotocol.failuredetector.NodeConnectivity;
import org.corfudb.protocols.wireprotocol.failuredetector.NodeConnectivity.ConnectionStatus;
import org.corfudb.protocols.wireprotocol.failuredetector.NodeConnectivity.NodeConnectivityType;
import org.corfudb.protocols.wireprotocol.failuredetector.NodeRank;
import org.corfudb.util.JsonUtils;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Graph representation of a cluster state. For instance, asymmetric graph,
 * there is an asymmetric failure between nodes `a` and `b`. {@link ConnectionStatus} could be OK/FAILED:
 * {a -&gt; {{a: OK}, {b: FAILED}, {c: OK}}}
 * {b -&gt; {{a: FAILED}, {b: OK}, {c: FAILED}}}
 * {c -&gt; {{a: OK}, {b: false}, {c: OK}}}
 * &lt;p&gt;
 * This class represents a cluster as a graph, it allows to:
 * - find fully connected node: node that connected to all other nodes exclude unresponsive nodes.
 * - find a decision maker: a node which should decide to add failed node to the unresponsive list.
 * The decision maker is an optimization technique, needed to reduce parallel updates of the cluster state.
 * Still, each node can choose its own decision maker. See {@link this#getDecisionMaker()} for details
 * - find a node which should be healed and excluded from the unresponsive list
 * - transform all asymmetric failures to a symmetric ones. If there is an asymmetric failure
 * (node B can connect to node B, but node B can not connect to node A) between two nodes
 * then make it symmetric which means neither node A nor B can connect to each other.
 */
<span class="nc bnc" id="L48" title="All 6 branches missed.">@Builder</span>
<span class="nc" id="L49">@ToString</span>
<span class="nc" id="L50">@Slf4j</span>
public class ClusterGraph {

    @NonNull
    private final ImmutableMap&lt;String, NodeConnectivity&gt; graph;

    @NonNull
    private final String localNode;

    @NonNull
    private final ImmutableList&lt;String&gt; unresponsiveNodes;
    /**
     * Transform a cluster state to the cluster graph.
     * ClusterState contains some extra information, cluster graph is a pure representation of a graph of nodes.
     * To be able to work efficiently with cluster state to find failed and healed nodes the cluster state should be
     * transformed to cluster graph
     *
     * @param cluster cluster state
     * @return cluster graph
     */
    public static ClusterGraph toClusterGraph(ClusterState cluster) {
<span class="nc" id="L71">        Map&lt;String, NodeConnectivity&gt; graph = cluster.getNodes()</span>
<span class="nc" id="L72">                .values()</span>
<span class="nc" id="L73">                .stream()</span>
<span class="nc" id="L74">                .map(NodeState::getConnectivity)</span>
<span class="nc" id="L75">                .collect(Collectors.toMap(NodeConnectivity::getEndpoint, Function.identity()));</span>

<span class="nc" id="L77">        return ClusterGraph.builder()</span>
<span class="nc" id="L78">                .localNode(cluster.getLocalEndpoint())</span>
<span class="nc" id="L79">                .unresponsiveNodes(cluster.getUnresponsiveNodes())</span>
<span class="nc" id="L80">                .graph(ImmutableMap.copyOf(graph))</span>
<span class="nc" id="L81">                .build();</span>
    }

    /**
     * Convert a cluster graph which could have asymmetric failures to a graph with symmetric failures between nodes.
     * See {@link ConnectionStatus} for OK/FAILED
     * For instance:
     * {a: [{a: OK, b: FAILED}]}
     * {b: [{a: OK, b: OK}]}
     * Node A believes that node B is disconnected
     * Node B believes that node A is connected.
     * The graph will be changed to:
     * {a: [{a: OK, b: FAILED}]}
     * {b: [{a: FAILED, b: OK}]}
     * Node B is not connected to node A anymore.
     *
     * @return a graph with symmetric failures between nodes.
     */
    public ClusterGraph toSymmetric() {
<span class="nc" id="L100">        Map&lt;String, NodeConnectivity&gt; symmetric = new HashMap&lt;&gt;();</span>

<span class="nc" id="L102">        graph.keySet().forEach(nodeName -&gt; {</span>
<span class="nc" id="L103">            NodeConnectivity node = graph.get(nodeName);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (node.getType() == NodeConnectivityType.UNAVAILABLE) {</span>
<span class="nc" id="L105">                symmetric.put(nodeName, node);</span>
<span class="nc" id="L106">                return;</span>
            }

<span class="nc" id="L109">            Map&lt;String, ConnectionStatus&gt; newConnectivity = new HashMap&lt;&gt;();</span>
<span class="nc" id="L110">            node.getConnectivity()</span>
                    //Get list of adjacent nodes to this node
<span class="nc" id="L112">                    .keySet()</span>
                    // For all adjacent nodes figure out if the node is connected to current node
<span class="nc" id="L114">                    .forEach(adjNodeName -&gt; {</span>
<span class="nc" id="L115">                        NodeConnectivity adjNode = graph.get(adjNodeName);</span>

                        //If current node is not the local node and another node is unavailable we don't change
                        // the adjacent node connectivity matrix, we leave it as is
<span class="nc bnc" id="L119" title="All 2 branches missed.">                        if (adjNode.getType() == NodeConnectivityType.UNAVAILABLE) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                            if (!isLocalNode(node)) {</span>
<span class="nc" id="L121">                                newConnectivity.put(adjNodeName, node.getConnectionStatus(adjNodeName));</span>
<span class="nc" id="L122">                                return;</span>
                            }
                        }

                        //Get connection status for current node
<span class="nc" id="L127">                        ConnectionStatus nodeConnection = getConnectionStatus(node, adjNode);</span>
                        //Get connection status for opposite node
<span class="nc" id="L129">                        ConnectionStatus oppositeNodeConnection = getConnectionStatus(adjNode, node);</span>

                        //Symmetric failure - connection successful only if both nodes connected status is true
                        //in the other case - make the failure symmetric
<span class="nc" id="L133">                        ConnectionStatus status = ConnectionStatus.OK;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                        if (EnumSet.of(nodeConnection, oppositeNodeConnection).contains(ConnectionStatus.FAILED)) {</span>
<span class="nc" id="L135">                            status = ConnectionStatus.FAILED;</span>
                        }
<span class="nc" id="L137">                        newConnectivity.put(adjNodeName, status);</span>
<span class="nc" id="L138">                    });</span>

<span class="nc" id="L140">            NodeConnectivity symmetricConnectivity = NodeConnectivity.builder()</span>
<span class="nc" id="L141">                    .endpoint(nodeName)</span>
<span class="nc" id="L142">                    .epoch(node.getEpoch())</span>
<span class="nc" id="L143">                    .connectivity(ImmutableMap.copyOf(newConnectivity))</span>
<span class="nc" id="L144">                    .type(node.getType())</span>
<span class="nc" id="L145">                    .build();</span>

<span class="nc" id="L147">            symmetric.put(nodeName, symmetricConnectivity);</span>
<span class="nc" id="L148">        });</span>

        //Provide a new graph with symmetric failures
<span class="nc" id="L151">        return ClusterGraph.builder()</span>
<span class="nc" id="L152">                .localNode(localNode)</span>
<span class="nc" id="L153">                .unresponsiveNodes(unresponsiveNodes)</span>
<span class="nc" id="L154">                .graph(ImmutableMap.copyOf(symmetric))</span>
<span class="nc" id="L155">                .build();</span>
    }

    private boolean isLocalNode(NodeConnectivity node) {
<span class="nc" id="L159">        return node.getEndpoint().equals(localNode);</span>
    }

    /**
     * Get a decision maker node to detect a failure. It must have:
     * - highest number of successful connections in the graph.
     * There could be many nodes with same number of successful connections,
     * then the decision maker will be a node with smallest name.
     * &lt;p&gt;
     * The decision maker is an optimization technique, needed to reduce parallel updates of the cluster state.
     * Still, each node can choose its own decision maker.
     * Note: it's not required to choose a particular one for entire cluster to add a node to unresponsive list.
     * In a partitioned scenario, a minority side can choose to have a decision maker
     * just that it's decisions will not be used as it does not have consensus
     * &lt;p&gt;
     * The decision maker always exists. There is always at least the local node,
     * it always has at least one successful connection to itself.
     * We also have two additional checks to prevent all possible incorrect ways. Decision maker not found if:
     * - ClusterGraph is empty, which is an invalid state.
     * - the decision maker doesn't have connections, which is also impossible.
     *
     * @return a decision maker node
     */
    public Optional&lt;NodeRank&gt; getDecisionMaker() {
<span class="nc" id="L183">        log.trace(&quot;Get decision maker&quot;);</span>

<span class="nc" id="L185">        NavigableSet&lt;NodeRank&gt; nodes = getNodeRanks();</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (nodes.isEmpty()) {</span>
<span class="nc" id="L188">            log.error(&quot;Empty graph. Can't provide decision maker&quot;);</span>
<span class="nc" id="L189">            return Optional.empty();</span>
        }

<span class="nc" id="L192">        NodeRank decisionMaker = nodes.first();</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (decisionMaker.getNumConnections() &lt; 1) {</span>
<span class="nc" id="L195">            log.trace(&quot;The node is fully disconnected from the graph. Decision maker doesn't exists&quot;);</span>
<span class="nc" id="L196">            return Optional.empty();</span>
        }

<span class="nc" id="L199">        log.trace(&quot;Decision maker has found: {}, all node ranks: {}&quot;, decisionMaker, nodes);</span>
<span class="nc" id="L200">        return Optional.of(decisionMaker);</span>
    }

    /**
     * Find failed node in a graph.
     * Collect all node ranks in a graph and choose the node with smallest number of successful connections and
     * with highest name (sorted alphabetically)
     *
     * @return failed node
     */
    public Optional&lt;NodeRank&gt; findFailedNode() {
<span class="nc" id="L211">        log.trace(&quot;Looking for failed node&quot;);</span>

<span class="nc" id="L213">        NavigableSet&lt;NodeRank&gt; nodes = getNodeRanks();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (nodes.isEmpty()) {</span>
<span class="nc" id="L215">            log.error(&quot;Empty graph. Can't provide failed node&quot;);</span>
<span class="nc" id="L216">            return Optional.empty();</span>
        }

<span class="nc" id="L219">        NodeRank last = nodes.last();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (last.getNumConnections() == graph.size()) {</span>
<span class="nc" id="L221">            return Optional.empty();</span>
        }

        //If the node is connected to all alive nodes (nodes not in unresponsive list)
        // in the cluster, that node can't be a failed node.
        // We can't rely on information from nodes in unresponsive list.
<span class="nc" id="L227">        Optional&lt;NodeRank&gt; fullyConnected = findFullyConnectedNode(last.getEndpoint());</span>

        //check if failed node is fully connected
<span class="nc" id="L230">        boolean isFailedNodeFullyConnected = fullyConnected</span>
<span class="nc" id="L231">                .map(fcNode -&gt; fcNode.equals(last))</span>
<span class="nc" id="L232">                .orElse(false);</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (isFailedNodeFullyConnected) {</span>
<span class="nc" id="L235">            log.trace(&quot;Fully connected node can't be a failed node&quot;);</span>
<span class="nc" id="L236">            return Optional.empty();</span>
        }

<span class="nc" id="L239">        return Optional.of(last);</span>
    }

    /**
     * See if the node is fully connected.
     *
     * @param endpoint          local node name
     * @return local node rank
     */
    public Optional&lt;NodeRank&gt; findFullyConnectedNode(String endpoint) {
<span class="nc" id="L249">        log.trace(&quot;Find responsive node. Unresponsive nodes: {}&quot;, unresponsiveNodes);</span>

<span class="nc" id="L251">        NodeConnectivity node = getNodeConnectivity(endpoint);</span>

<span class="nc bnc" id="L253" title="All 3 branches missed.">        switch (node.getType()) {</span>
            case NOT_READY:
            case UNAVAILABLE:
<span class="nc" id="L256">                log.trace(&quot;Not connected node: {}&quot;, endpoint);</span>
<span class="nc" id="L257">                return Optional.empty();</span>
            case CONNECTED:
<span class="nc bnc" id="L259" title="All 2 branches missed.">                for (String adjacent : node.getConnectivity().keySet()) {</span>
                    //if adjacent node is unresponsive then exclude it from fully connected graph
<span class="nc bnc" id="L261" title="All 2 branches missed.">                    if (unresponsiveNodes.contains(adjacent)) {</span>
<span class="nc" id="L262">                        continue;</span>
                    }

<span class="nc" id="L265">                    NodeConnectivity adjacentNode = getNodeConnectivity(adjacent);</span>

                    //if adjacent node is unavailable then exclude it from  fully connected graph
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    if (adjacentNode.getType() == NodeConnectivityType.UNAVAILABLE) {</span>
<span class="nc" id="L269">                        continue;</span>
                    }

<span class="nc bnc" id="L272" title="All 2 branches missed.">                    if (adjacentNode.getConnectionStatus(endpoint) != ConnectionStatus.OK) {</span>
<span class="nc" id="L273">                        log.trace(&quot;Fully connected node not found&quot;);</span>
<span class="nc" id="L274">                        return Optional.empty();</span>
                    }
<span class="nc" id="L276">                }</span>

<span class="nc" id="L278">                NodeRank rank = new NodeRank(</span>
                        endpoint,
<span class="nc" id="L280">                        getNodeConnectivity(endpoint).getConnected()</span>
                );

<span class="nc" id="L283">                return Optional.of(rank);</span>
            default:
<span class="nc" id="L285">                throw new IllegalStateException(&quot;Unknown node state&quot;);</span>
        }
    }

    /**
     * Get node by name
     *
     * @param node node name
     * @return a node in the graph
     */
    @VisibleForTesting
    public NodeConnectivity getNodeConnectivity(String node) {
<span class="nc" id="L297">        return graph.get(node);</span>
    }

    /**
     * Graph size
     *
     * @return size
     */
    public int size() {
<span class="nc" id="L306">        return graph.size();</span>
    }

    public String toJson() {
<span class="nc" id="L310">        return JsonUtils.toJson(connectivityGraph());</span>
    }

    /**
     * Transform ClusterGraph to Connectivity graph
     *
     * @return connectivity graph
     */
    public ConnectivityGraph connectivityGraph() {
<span class="nc" id="L319">        return new ConnectivityGraph(new TreeSet&lt;&gt;(graph.values()));</span>
    }

    private NavigableSet&lt;NodeRank&gt; getNodeRanks() {
<span class="nc" id="L323">        NavigableSet&lt;NodeRank&gt; nodes = new TreeSet&lt;&gt;();</span>

<span class="nc" id="L325">        graph.keySet().forEach(node -&gt; {</span>
<span class="nc" id="L326">            int numConnected = graph.get(node).getConnected();</span>
<span class="nc" id="L327">            nodes.add(new NodeRank(node, numConnected));</span>
<span class="nc" id="L328">        });</span>

<span class="nc" id="L330">        return nodes;</span>
    }

    /**
     * Get connection status between two nodes in the graph.
     * For instance:
     * {a: [{a: OK}, {b: FAILED}]}
     * {b: [{a: OK}, {b: FAILED}]}
     * getConnectionStatus(&quot;a&quot;, &quot;b&quot;) -&gt; FAILED
     * getConnectionStatus(&quot;b&quot;, &quot;a&quot;) -&gt; OK
     *
     * @param sourceNode source node
     * @param targetNode second node
     * @return connection status
     */
    private ConnectionStatus getConnectionStatus(NodeConnectivity sourceNode, NodeConnectivity targetNode) {

<span class="nc bnc" id="L347" title="All 4 branches missed.">        if (sourceNode == null || targetNode == null) {</span>
<span class="nc" id="L348">            String errMsg = &quot;Source or target node is null. Source: &quot; + sourceNode + &quot;, target: &quot; + targetNode;</span>
<span class="nc" id="L349">            throw new IllegalArgumentException(errMsg);</span>
        }

<span class="nc" id="L352">        Set&lt;NodeConnectivityType&gt; types = EnumSet.of(sourceNode.getType(), targetNode.getType());</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (types.contains(NodeConnectivityType.UNAVAILABLE)) {</span>
<span class="nc" id="L354">            return ConnectionStatus.FAILED;</span>
        }

<span class="nc" id="L357">        return sourceNode.getConnectionStatus(targetNode.getEndpoint());</span>
    }

    /**
     * Helper provides methods to build cluster graph
     * &lt;pre&gt;
     * ClusterGraph graph = cluster(
     *     connectivity(&quot;a&quot;, ImmutableMap.of(&quot;a&quot;, OK, &quot;b&quot;, FAILED, &quot;c&quot;, OK)),
     *     unavailable(&quot;b&quot;),
     *     connectivity(&quot;c&quot;, ImmutableMap.of(&quot;a&quot;, OK, &quot;b&quot;, FAILED, &quot;c&quot;, OK))
     * );
     * &lt;/pre&gt;
     */
    public static class ClusterGraphHelper {

<span class="nc" id="L372">        private ClusterGraphHelper() {</span>
            //prevent creating instances
<span class="nc" id="L374">        }</span>

        public static ClusterGraph cluster(String localNode,
                                           ImmutableList&lt;String&gt; unresponsiveNodes,
                                           NodeConnectivity... nodes) {
<span class="nc" id="L379">            Map&lt;String, NodeConnectivity&gt; graph = Arrays.stream(nodes)</span>
<span class="nc" id="L380">                    .collect(Collectors.toMap(NodeConnectivity::getEndpoint, Function.identity()));</span>

<span class="nc" id="L382">            return ClusterGraph.builder()</span>
<span class="nc" id="L383">                    .localNode(localNode)</span>
<span class="nc" id="L384">                    .unresponsiveNodes(unresponsiveNodes)</span>
<span class="nc" id="L385">                    .graph(ImmutableMap.copyOf(graph))</span>
<span class="nc" id="L386">                    .build();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>