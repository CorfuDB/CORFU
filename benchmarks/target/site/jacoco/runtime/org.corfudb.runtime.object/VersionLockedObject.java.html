<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>VersionLockedObject.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">benchmarks</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.object</a> &gt; <span class="el_source">VersionLockedObject.java</span></div><h1>VersionLockedObject.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.object;

import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.exceptions.NoRollbackException;
import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;
import org.corfudb.runtime.object.transactions.WriteSetSMRStream;
import org.corfudb.runtime.view.Address;
import org.corfudb.util.CorfuComponent;
import org.corfudb.util.MetricsUtils;
import org.corfudb.util.Utils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.StampedLock;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

//TODO Discard TransactionStream for building maps but not for constructing tails

/**
 * The VersionLockedObject maintains a versioned object which is backed by an ISMRStream, and is
 * optionally backed by an additional optimistic update stream.
 *
 * &lt;p&gt;Users of the VersionLockedObject cannot access the versioned object directly, rather they
 * use the access() and update() methods to read and manipulate the object.
 *
 * &lt;p&gt;access() and update() allow the user to provide functions to execute under locks. These
 * functions execute various &quot;unsafe&quot; methods provided by this object which inspect and
 * manipulate the object state.
 *
 * &lt;p&gt;syncObjectUnsafe() enables the user to bring the object to a given version, and the
 * VersionLockedObject manages any sync or rollback of updates necessary.
 *
 * &lt;p&gt;Created by mwei on 11/13/16.
 */
<span class="nc" id="L49">@Slf4j</span>
public class VersionLockedObject&lt;T&gt; {

    /**
     * The actual underlying object.
     */
<span class="nc" id="L55">    @Getter</span>
    private T object;

    /**
     * A list of upcalls pending in the system. The proxy keeps this set so it can remember to
     * save the upcalls for pending requests.
     */
<span class="nc" id="L62">    @Getter</span>
    private final Set&lt;Long&gt; pendingUpcalls;

    // This enum is necessary because null cannot be inserted
    // into a ConcurrentHashMap.
<span class="nc" id="L67">    enum NullValue {</span>
<span class="nc" id="L68">        NULL_VALUE</span>
    }

    /**
     * A list of upcall results, keyed by the address they were requested.
     */
<span class="nc" id="L74">    @Getter</span>
    private final Map&lt;Long, Object&gt; upcallResults;


    /**
     * A lock, which controls access to modifications to the object. Any access to unsafe
     * methods should obtain the lock.
     */
    private final StampedLock lock;

    /**
     * The stream view this object is backed by.
     */
    private final ISMRStream smrStream;

    /**
     * The optimistic SMR stream on this object, if any.
     */
    private WriteSetSMRStream optimisticStream;

    /**
     * The upcall map for this object.
     */
    private final Map&lt;String, ICorfuSMRUpcallTarget&lt;T&gt;&gt; upcallTargetMap;

    /**
     * The undo record function map for this object.
     */
    private final Map&lt;String, IUndoRecordFunction&lt;T&gt;&gt; undoRecordFunctionMap;

    /**
     * The undo target map for this object.
     */
    private final Map&lt;String, IUndoFunction&lt;T&gt;&gt; undoFunctionMap;

    /**
     * The reset set for this object.
     */
    private final Set&lt;String&gt; resetSet;

    /**
     * A function that generates a new instance of this object.
     */
    private final Supplier&lt;T&gt; newObjectFn;

    /**
     * Correctness Logging
     */
<span class="nc" id="L122">    private final Logger correctnessLogger = LoggerFactory.getLogger(&quot;correctness&quot;);</span>


    /**
     * The VersionLockedObject maintains a versioned object which is backed by an ISMRStream,
     * and is optionally backed by an additional optimistic update stream.
     *
     * @param newObjectFn       A function passed to instantiate a new instance of this object.
     * @param smrStream         Stream View backing this object.
     * @param upcallTargets     UpCall map for this object.
     * @param undoRecordTargets Undo record function map for this object.
     * @param undoTargets       Undo functions map.
     * @param resetSet          Reset set for this object.
     */
    public VersionLockedObject(Supplier&lt;T&gt; newObjectFn,
                               StreamViewSMRAdapter smrStream,
                               Map&lt;String, ICorfuSMRUpcallTarget&lt;T&gt;&gt; upcallTargets,
                               Map&lt;String, IUndoRecordFunction&lt;T&gt;&gt; undoRecordTargets,
                               Map&lt;String, IUndoFunction&lt;T&gt;&gt; undoTargets,
<span class="nc" id="L141">                               Set&lt;String&gt; resetSet) {</span>
<span class="nc" id="L142">        this.smrStream = smrStream;</span>

<span class="nc" id="L144">        this.upcallTargetMap = upcallTargets;</span>
<span class="nc" id="L145">        this.undoRecordFunctionMap = undoRecordTargets;</span>
<span class="nc" id="L146">        this.undoFunctionMap = undoTargets;</span>
<span class="nc" id="L147">        this.resetSet = resetSet;</span>

<span class="nc" id="L149">        this.newObjectFn = newObjectFn;</span>
<span class="nc" id="L150">        this.object = newObjectFn.get();</span>
<span class="nc" id="L151">        this.pendingUpcalls = ConcurrentHashMap.newKeySet();</span>
<span class="nc" id="L152">        this.upcallResults = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L154">        lock = new StampedLock();</span>
<span class="nc" id="L155">    }</span>

    /**
     * Run gc on this object. Since the stream that backs this object is not thread-safe:
     * synchronization between gc and external object access is needed.
     */
    public void gc(long trimMark) {
<span class="nc" id="L162">        long ts = 0;</span>

<span class="nc" id="L164">        try (Timer.Context vloGcDuration = VloMetricsHelper.getVloGcContext()) {</span>
<span class="nc" id="L165">            ts = lock.writeLock();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            pendingUpcalls.removeIf(e -&gt; e &lt; trimMark);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            upcallResults.entrySet().removeIf(e -&gt; e.getKey() &lt; trimMark);</span>
<span class="nc" id="L168">            smrStream.gc(trimMark);</span>
<span class="nc bnc" id="L169" title="All 8 branches missed.">        } finally {</span>
<span class="nc" id="L170">            lock.unlock(ts);</span>
<span class="nc" id="L171">        }</span>
<span class="nc" id="L172">    }</span>

    /**
     * Access the internal state of the object, trying first to optimistically access
     * the object, then obtaining a write lock the optimistic access fails.
     *
     * &lt;p&gt;If the directAccessCheckFunction returns true, then we execute the accessFunction
     * without running updateFunction. If false, we execute the updateFunction to
     * allow the user to modify the state of the object before calling accessFunction.
     *
     * &lt;p&gt;directAccessCheckFunction is executed under an optimistic read lock. Read-only
     * unsafe operations are permitted.
     *
     * &lt;p&gt;updateFunction is executed under a write lock. Both read and write unsafe operations
     * are permitted.
     *
     * &lt;p&gt;accessFunction is accessed either under a read lock or write lock depending on
     * whether an update was necessary or not.
     *
     * @param directAccessCheckFunction A function which returns True if the object can be
     *                                  accessed without being updated.
     * @param updateFunction            A function which is executed when direct access
     *                                  is not allowed and the object must be updated.
     * @param accessFunction            A function which allows the user to directly access
     *                                  the object while locked in the state enforced by
     *                                  either the directAccessCheckFunction or updateFunction.
     * @param &lt;R&gt;                       The type of the access function return.
     * @return Returns the access function.
     */
    public &lt;R&gt; R access(Function&lt;VersionLockedObject&lt;T&gt;, Boolean&gt; directAccessCheckFunction,
                        Consumer&lt;VersionLockedObject&lt;T&gt;&gt; updateFunction,
                        Function&lt;T, R&gt; accessFunction) {
        // First, we try to do an optimistic read on the object, in case it
        // meets the conditions for direct access.
<span class="nc" id="L206">        long ts = lock.tryOptimisticRead();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (ts != 0) {</span>
<span class="nc" id="L208">            try (Timer.Context optimistReadDuration = VloMetricsHelper.getOptimisticReadContext()) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (directAccessCheckFunction.apply(this)) {</span>
<span class="nc" id="L210">                    log.trace(&quot;Access [{}] Direct (optimistic-read) access at {}&quot;,</span>
<span class="nc" id="L211">                            this, getVersionUnsafe());</span>
<span class="nc" id="L212">                    R ret = accessFunction.apply(object);</span>

<span class="nc" id="L214">                    long versionForCorrectness = getVersionUnsafe();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    if (lock.validate(ts)) {</span>
<span class="nc" id="L216">                        correctnessLogger.trace(&quot;Version, {}&quot;, versionForCorrectness);</span>
<span class="nc" id="L217">                        return ret;</span>
                    }
                }
<span class="nc bnc" id="L220" title="All 12 branches missed.">            } catch (Exception e) {</span>
                // If we have an exception, we didn't get a chance to validate the lock.
                // If it's still valid, then we should re-throw the exception since it was
                // on a correct view of the object.
<span class="nc bnc" id="L224" title="All 2 branches missed.">                if (lock.validate(ts)) {</span>
<span class="nc" id="L225">                    throw e;</span>
                }
                // Otherwise, it is not on a correct view of the object (the object was
                // modified) and we should try again by upgrading the lock.
<span class="nc" id="L229">                log.warn(&quot;Access [{}] Direct (optimistic-read) exception, upgrading lock. Exception &quot;,</span>
                        this, e);
<span class="nc" id="L231">            }</span>
        }
        // Next, we just upgrade to a full write lock if the optimistic
        // read fails, since it means that the state of the object was
        // updated.
<span class="nc" id="L236">        try (Timer.Context updateObjectReadDuration = VloMetricsHelper.getUpdatedObjectReadContext()) {</span>
            // Attempt an upgrade
<span class="nc" id="L238">            ts = lock.tryConvertToWriteLock(ts);</span>
            // Upgrade failed, try conversion again
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (ts == 0) {</span>
<span class="nc" id="L241">                ts = lock.writeLock();</span>
            }
            // Check if direct access is possible (unlikely).
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (directAccessCheckFunction.apply(this)) {</span>
<span class="nc" id="L245">                log.trace(&quot;Access [{}] Direct (writelock) access at {}&quot;, this, getVersionUnsafe());</span>
<span class="nc" id="L246">                R ret = accessFunction.apply(object);</span>

<span class="nc" id="L248">                long versionForCorrectness = getVersionUnsafe();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                if (lock.validate(ts)) {</span>
<span class="nc" id="L250">                    correctnessLogger.trace(&quot;Version, {}&quot;, versionForCorrectness);</span>
<span class="nc" id="L251">                    return ret;</span>
                }
            }
            // If not, perform the update operations
<span class="nc" id="L255">            updateFunction.accept(this);</span>
<span class="nc" id="L256">            correctnessLogger.trace(&quot;Version, {}&quot;, getVersionUnsafe());</span>
<span class="nc" id="L257">            log.trace(&quot;Access [{}] Updated (writelock) access at {}&quot;, this, getVersionUnsafe());</span>
<span class="nc" id="L258">            return accessFunction.apply(object);</span>
            // And perform the access
<span class="nc bnc" id="L260" title="All 12 branches missed.">        } finally {</span>
<span class="nc" id="L261">            lock.unlock(ts);</span>
<span class="nc" id="L262">        }</span>
    }

    /**
     * Update the object under a write lock.
     *
     * @param updateFunction A function to execute once the write lock has been acquired.
     * @param &lt;R&gt;            The type of the return of the updateFunction.
     * @return The return value of the update function.
     */
    public &lt;R&gt; R update(Function&lt;VersionLockedObject&lt;T&gt;, R&gt; updateFunction) {
<span class="nc" id="L273">        long ts = 0;</span>

<span class="nc" id="L275">        try (Timer.Context updateDuration = VloMetricsHelper.getVloUpdateContext()) {</span>
<span class="nc" id="L276">            ts = lock.writeLock();</span>
<span class="nc" id="L277">            log.trace(&quot;Update[{}] (writelock)&quot;, this);</span>
<span class="nc" id="L278">            return updateFunction.apply(this);</span>
<span class="nc bnc" id="L279" title="All 8 branches missed.">        } finally {</span>
<span class="nc" id="L280">            lock.unlock(ts);</span>
<span class="nc" id="L281">        }</span>
    }

    /**
     * Roll the object back to the supplied version if possible.
     * This function may roll back to a point prior to the requested version.
     * Otherwise, throws a NoRollbackException.
     *
     * &lt;p&gt;Unsafe, requires that the caller has acquired a write lock.
     *
     * @param rollbackVersion The version to rollback to.
     * @throws NoRollbackException If the object cannot be rolled back to
     *                             the supplied version.
     */
    public void rollbackObjectUnsafe(long rollbackVersion) {
<span class="nc" id="L296">        log.trace(&quot;Rollback[{}] to {}&quot;, this, rollbackVersion);</span>
<span class="nc" id="L297">        rollbackStreamUnsafe(smrStream, rollbackVersion);</span>
<span class="nc" id="L298">        log.trace(&quot;Rollback[{}] completed&quot;, this);</span>
<span class="nc" id="L299">    }</span>

    /**
     * Move the pointer for this object (effectively, forcefuly
     * change the version of this object without playing
     * any updates).
     *
     * @param globalAddress The global address to set the pointer to
     */
    public void seek(long globalAddress) {
<span class="nc" id="L309">        smrStream.seek(globalAddress);</span>
<span class="nc" id="L310">    }</span>

    /**
     * Bring the object to the requested version, rolling back or syncing
     * the object from the log if necessary to reach the requested version.
     *
     * @param timestamp The timestamp to update the object to.
     */
    public void syncObjectUnsafe(long timestamp) {
        // If there is an optimistic stream attached,
        // and it belongs to this thread use that
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (optimisticallyOwnedByThreadUnsafe()) {</span>
            // If there are no updates, ensure we are at the right snapshot
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (optimisticStream.pos() == Address.NEVER_READ) {</span>
<span class="nc" id="L324">                final WriteSetSMRStream currentOptimisticStream =</span>
                        optimisticStream;
                // If we are too far ahead, roll back to the past
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (getVersionUnsafe() &gt; timestamp) {</span>
                    try {
<span class="nc" id="L329">                        rollbackObjectUnsafe(timestamp);</span>
<span class="nc" id="L330">                    } catch (NoRollbackException nre) {</span>
<span class="nc" id="L331">                        log.warn(&quot;SyncObjectUnsafe[{}] to {} failed {}&quot;, this, timestamp, nre);</span>
<span class="nc" id="L332">                        resetUnsafe();</span>
<span class="nc" id="L333">                    }</span>
                }
                // Now sync the regular log
<span class="nc" id="L336">                syncStreamUnsafe(smrStream, timestamp);</span>
                // It's possible that due to reset,
                // the optimistic stream is no longer
                // present. Restore it.
<span class="nc" id="L340">                optimisticStream = currentOptimisticStream;</span>
            }
<span class="nc" id="L342">            syncStreamUnsafe(optimisticStream, Address.OPTIMISTIC);</span>
        } else {
            // If there is an optimistic stream for another
            // transaction, remove it by rolling it back first
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (this.optimisticStream != null) {</span>
<span class="nc" id="L347">                optimisticRollbackUnsafe();</span>
<span class="nc" id="L348">                this.optimisticStream = null;</span>
            }
            // If we are too far ahead, roll back to the past
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (getVersionUnsafe() &gt; timestamp) {</span>
                try {
<span class="nc" id="L353">                    rollbackObjectUnsafe(timestamp);</span>
                    // Rollback successfully got us to the right
                    // version, we're done.
<span class="nc bnc" id="L356" title="All 2 branches missed.">                    if (getVersionUnsafe() == timestamp) {</span>
<span class="nc" id="L357">                        return;</span>
                    }
<span class="nc" id="L359">                } catch (NoRollbackException nre) {</span>
<span class="nc" id="L360">                    log.warn(&quot;Rollback[{}] to {} failed {}&quot;, this, timestamp, nre);</span>
<span class="nc" id="L361">                    resetUnsafe();</span>
<span class="nc" id="L362">                }</span>
            }
<span class="nc" id="L364">            syncStreamUnsafe(smrStream, timestamp);</span>
        }
<span class="nc" id="L366">    }</span>

    /**
     * Log an update to this object, noting a request to save the
     * upcall result if necessary.
     *
     * @param entry      The entry to log.
     * @param saveUpcall True, if the upcall result should be
     *                   saved, false otherwise.
     * @return The address the update was logged at.
     */
    public long logUpdate(SMREntry entry, boolean saveUpcall) {
<span class="nc" id="L378">        return smrStream.append(entry,</span>
                t -&gt; {
<span class="nc bnc" id="L380" title="All 2 branches missed.">                    if (saveUpcall) {</span>
<span class="nc" id="L381">                        pendingUpcalls.add(t.getToken().getSequence());</span>
                    }
<span class="nc" id="L383">                    return true;</span>
                },
                t -&gt; {
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    if (saveUpcall) {</span>
<span class="nc" id="L387">                        pendingUpcalls.remove(t.getToken().getSequence());</span>
                    }
<span class="nc" id="L389">                    return true;</span>
                });
    }

    /**
     * Get a handle to the optimistic stream.
     */
    public WriteSetSMRStream getOptimisticStreamUnsafe() {
<span class="nc" id="L397">        return optimisticStream;</span>
    }

    /**
     * Check whether or not this object was modified by this thread.
     *
     * @return True, if the object was modified by this thread. False otherwise.
     */
    public boolean optimisticallyOwnedByThreadUnsafe() {
<span class="nc bnc" id="L406" title="All 2 branches missed.">        return optimisticStream != null &amp;&amp;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">               optimisticStream.isStreamForThisThread();</span>
    }

    /**
     * Set the optimistic stream for this thread, rolling back
     * any previous threads if they were present.
     *
     * @param optimisticStream The new optimistic stream to install.
     */
    public void setOptimisticStreamUnsafe(WriteSetSMRStream optimisticStream) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (this.optimisticStream != null) {</span>
<span class="nc" id="L418">            optimisticRollbackUnsafe();</span>
        }
<span class="nc" id="L420">        this.optimisticStream = optimisticStream;</span>
<span class="nc" id="L421">    }</span>

    /**
     * Get the version of this object. This corresponds to the position
     * of the pointer into the SMR stream.
     *
     * @return Returns the pointer position to the object in the stream.
     */
    public long getVersionUnsafe() {
<span class="nc" id="L430">        return smrStream.pos();</span>
    }

    /**
     * Check whether this object is currently under optimistic modifications.
     */
    public boolean isOptimisticallyModifiedUnsafe() {
<span class="nc bnc" id="L437" title="All 4 branches missed.">        return optimisticStream != null &amp;&amp; optimisticStream.pos() != Address.NEVER_READ;</span>
    }

    /**
     * Reset this object to the uninitialized state.
     */
    public void resetUnsafe() {
<span class="nc" id="L444">        log.debug(&quot;Reset[{}]&quot;, this);</span>
<span class="nc" id="L445">        object = newObjectFn.get();</span>
<span class="nc" id="L446">        smrStream.reset();</span>
<span class="nc" id="L447">        optimisticStream = null;</span>
<span class="nc" id="L448">    }</span>

    /**
     * Get the ID of the stream backing this object.
     *
     * @return The ID of the stream backing this object.
     */
    @SuppressWarnings(&quot;checkstyle:abbreviation&quot;)
    public UUID getID() {
<span class="nc" id="L457">        return smrStream.getID();</span>
    }

    /**
     * Generate the summary string for this version locked object.
     *
     * &lt;p&gt;The format of this string is [type]@[version][+]
     * (where + is the optimistic flag)
     *
     * @return The summary string for this version locked object
     */
    @Override
    public String toString() {
<span class="nc" id="L470">        WriteSetSMRStream optimisticStream = this.optimisticStream;</span>

<span class="nc" id="L472">        return object.getClass().getSimpleName()</span>
<span class="nc" id="L473">                + &quot;[&quot; + Utils.toReadableId(smrStream.getID()) + &quot;]@&quot;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">                + (getVersionUnsafe() == Address.NEVER_READ ? &quot;NR&quot; : getVersionUnsafe())</span>
<span class="nc" id="L475">                + (optimisticStream == null ? &quot;&quot; : &quot;+&quot; + optimisticStream.pos());</span>
    }


    /**
     * Given a SMR entry with an undo entry, undo the update.
     *
     * @param entry The entry to undo.
     */
    private void applyUndoRecordUnsafe(SMREntry entry) {
<span class="nc" id="L485">        log.trace(&quot;Undo[{}] of {}@{} ({})&quot;, this, entry.getSMRMethod(),</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                Address.isAddress(entry.getGlobalAddress()) ? entry.getGlobalAddress() : &quot;OPT&quot;,</span>
<span class="nc" id="L487">                entry.getUndoRecord());</span>
<span class="nc" id="L488">        IUndoFunction&lt;T&gt; undoFunction = undoFunctionMap.get(entry.getSMRMethod());</span>
        // If the undo function exists, apply it.
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (undoFunction != null) {</span>
<span class="nc" id="L491">            undoFunction.doUndo(object, entry.getUndoRecord(), entry.getSMRArguments());</span>
<span class="nc" id="L492">            return;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        } else if (resetSet.contains(entry.getSMRMethod())) {</span>
            // If this is a reset, undo by restoring the
            // previous state.
<span class="nc" id="L496">            object = (T) entry.getUndoRecord();</span>
            // clear the undo record, since it is now
            // consumed (the object may change)
<span class="nc" id="L499">            entry.clearUndoRecord();</span>
<span class="nc" id="L500">            return;</span>
        }
        // Otherwise we don't know how to undo,
        // throw a runtime exception, because
        // this is a bug, undoRecords we don't know
        // how to process shouldn't be in the log.
<span class="nc" id="L506">        throw new RuntimeException(&quot;Unknown undo record in undo log&quot;);</span>
    }


    /**
     * Apply an SMR update to the object, possibly optimistically.
     *
     * @param entry The entry to apply.
     */
    private Object applyUpdateUnsafe(SMREntry entry) {
<span class="nc" id="L516">        log.trace(&quot;Apply[{}] of {}@{} ({})&quot;, this, entry.getSMRMethod(),</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                Address.isAddress(entry.getGlobalAddress()) ? entry.getGlobalAddress() : &quot;OPT&quot;,</span>
<span class="nc" id="L518">                entry.getSMRArguments());</span>

<span class="nc" id="L520">        ICorfuSMRUpcallTarget&lt;T&gt; target = upcallTargetMap.get(entry.getSMRMethod());</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L522">            throw new RuntimeException(&quot;Unknown upcall &quot; + entry.getSMRMethod());</span>
        }

        // Calculate an undo record if no undo record is present -OR- there
        // is an optimistic entry, (which has no valid global address).
        // In the case of optimistic entries, the snapshot may have changed
        // since the last time they were applied, so we need to recalculate
        // undo -- this is the case without snapshot isolation.
<span class="nc bnc" id="L530" title="All 4 branches missed.">        if (!entry.isUndoable() || !Address.isAddress(entry.getGlobalAddress())) {</span>
            // Can we generate an undo record?
<span class="nc" id="L532">            IUndoRecordFunction&lt;T&gt; undoRecordTarget =</span>
<span class="nc" id="L533">                    undoRecordFunctionMap.get(entry.getSMRMethod());</span>
            // If there was no previously calculated undo entry
<span class="nc bnc" id="L535" title="All 2 branches missed.">            if (undoRecordTarget != null) {</span>
                // Calculate the undo record.
<span class="nc" id="L537">                entry.setUndoRecord(undoRecordTarget</span>
<span class="nc" id="L538">                        .getUndoRecord(object, entry.getSMRArguments()));</span>
<span class="nc" id="L539">                log.trace(&quot;Apply[{}] Undo-&gt;{}&quot;, this, entry.getUndoRecord());</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            } else if (resetSet.contains(entry.getSMRMethod())) {</span>
                // This entry actually resets the object. So here
                // we can safely get a new instance, and add the
                // previous instance to the undo log.
<span class="nc" id="L544">                entry.setUndoRecord(object);</span>
<span class="nc" id="L545">                object = newObjectFn.get();</span>
<span class="nc" id="L546">                log.trace(&quot;Apply[{}] Undo-&gt;RESET&quot;, this);</span>
            }
        }

        // Now invoke the upcall
<span class="nc" id="L551">        return target.upcall(object, entry.getSMRArguments());</span>
    }

    /**
     * Roll back the given stream by applying undo records in reverse order
     * from the current stream position until rollbackVersion.
     *
     * @param stream          The stream of SMR updates to apply in
     *                        reverse order.
     * @param rollbackVersion The version to stop roll back at.
     * @throws NoRollbackException If an entry in the stream did not contain
     *                             undo information.
     */
    protected void rollbackStreamUnsafe(ISMRStream stream, long rollbackVersion) {
        // If we're already at or before the given version, there's
        // nothing to do
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (stream.pos() &lt;= rollbackVersion) {</span>
<span class="nc" id="L568">            return;</span>
        }

<span class="nc" id="L571">        List&lt;SMREntry&gt; entries = stream.current();</span>

<span class="nc bnc" id="L573" title="All 2 branches missed.">        while (!entries.isEmpty()) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (entries.stream().allMatch(SMREntry::isUndoable)) {</span>
                // start from the end, process one at a time
<span class="nc" id="L576">                ListIterator&lt;SMREntry&gt; it = entries.listIterator(entries.size());</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                while (it.hasPrevious()) {</span>
<span class="nc" id="L578">                    applyUndoRecordUnsafe(it.previous());</span>
                }
<span class="nc" id="L580">            } else {</span>
<span class="nc" id="L581">                Optional&lt;SMREntry&gt; entry = entries.stream().findFirst();</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                if (log.isTraceEnabled()) {</span>
<span class="nc" id="L583">                    log.trace(&quot;rollbackStreamUnsafe: one or more stream entries in address @{} are not undoable. &quot; +</span>
<span class="nc" id="L584">                                    &quot;Undoable entries: {}/{}&quot;, stream.pos(),</span>
<span class="nc" id="L585">                            (int) entries.stream().filter(SMREntry::isUndoable).count(),</span>
<span class="nc" id="L586">                            entries.size());</span>
                }
<span class="nc" id="L588">                throw new NoRollbackException(entry, stream.pos(), rollbackVersion);</span>
            }

<span class="nc" id="L591">            entries = stream.previous();</span>

<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (stream.pos() &lt;= rollbackVersion) {</span>
<span class="nc" id="L594">                return;</span>
            }
        }

<span class="nc" id="L598">        throw new NoRollbackException(stream.pos(), rollbackVersion);</span>
    }

    /**
     * Sync this stream by playing updates forward in the stream until
     * the given timestamp. If Address.MAX is given, updates will be
     * applied until the current tail of the stream. If Address.OPTIMISTIC
     * is given, updates will be applied to the end of the stream, and
     * upcall results will be stored in the resulting entries.
     *
     * &lt;p&gt;When the stream is trimmed, this exception is passed up to the caller,
     * unless the timestamp was Address.MAX, in which the entire object is
     * reset and re-try the sync, which should pick up any checkpoint that
     * was inserted.
     *
     * @param stream    The stream to sync forward
     * @param timestamp The timestamp to sync up to.
     */
    protected void syncStreamUnsafe(ISMRStream stream, long timestamp) {
<span class="nc bnc" id="L617" title="All 2 branches missed.">        log.trace(&quot;Sync[{}] {}&quot;, this, (timestamp == Address.OPTIMISTIC)</span>
                ? &quot;Optimistic&quot; : &quot;to &quot; + timestamp);
<span class="nc bnc" id="L619" title="All 2 branches missed.">        long syncTo = (timestamp == Address.OPTIMISTIC) ? Address.MAX : timestamp;</span>
<span class="nc" id="L620">        stream.streamUpTo(syncTo)</span>
<span class="nc" id="L621">                .forEachOrdered(entry -&gt; {</span>
                    try {
<span class="nc" id="L623">                        Object res = applyUpdateUnsafe(entry);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                        if (timestamp == Address.OPTIMISTIC) {</span>
<span class="nc" id="L625">                            entry.setUpcallResult(res);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                        } else if (pendingUpcalls.contains(entry.getGlobalAddress())) {</span>
<span class="nc" id="L627">                            log.debug(&quot;Sync[{}] Upcall Result {}&quot;,</span>
<span class="nc" id="L628">                                    this, entry.getGlobalAddress());</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                            upcallResults.put(entry.getGlobalAddress(), res == null</span>
                                    ? NullValue.NULL_VALUE : res);
<span class="nc" id="L631">                            pendingUpcalls.remove(entry.getGlobalAddress());</span>
                        }
<span class="nc" id="L633">                        entry.setUpcallResult(res);</span>
<span class="nc" id="L634">                    } catch (Exception e) {</span>
<span class="nc" id="L635">                        log.error(&quot;Sync[{}] Error: Couldn't execute upcall due to {}&quot;, this, e);</span>
<span class="nc" id="L636">                        throw new UnrecoverableCorfuError(e);</span>
<span class="nc" id="L637">                    }</span>
<span class="nc" id="L638">                });</span>
<span class="nc" id="L639">    }</span>

    /**
     * Roll back the optimistic stream, resetting the object if it can not
     * be restored.
     */
    protected void optimisticRollbackUnsafe() {
        try {
<span class="nc" id="L647">            log.trace(&quot;OptimisticRollback[{}] started&quot;, this);</span>
<span class="nc" id="L648">            rollbackStreamUnsafe(this.optimisticStream,</span>
                    Address.NEVER_READ);
<span class="nc" id="L650">            log.trace(&quot;OptimisticRollback[{}] complete&quot;, this);</span>
<span class="nc" id="L651">        } catch (NoRollbackException nre) {</span>
<span class="nc" id="L652">            log.warn(&quot;OptimisticRollback[{}] failed&quot;, this);</span>
<span class="nc" id="L653">            resetUnsafe();</span>
<span class="nc" id="L654">        }</span>
<span class="nc" id="L655">    }</span>

    /** Apply an SMREntry to the version object, while
     * doing bookkeeping for the underlying stream.
     *
     * @param entry smr entry
     */
    public void applyUpdateToStreamUnsafe(SMREntry entry, long globalAddress) {
<span class="nc" id="L663">        applyUpdateUnsafe(entry);</span>
<span class="nc" id="L664">        seek(globalAddress + 1);</span>
<span class="nc" id="L665">    }</span>

    /**
     * This class includes the metrics registry and the timer names used within VersionLockedObject
     * methods
     */
<span class="nc" id="L671">    private static class VloMetricsHelper {</span>
<span class="nc" id="L672">        private static final MetricRegistry metrics = CorfuRuntime.getDefaultMetrics();</span>
<span class="nc" id="L673">        private static final String VLO_OPTIMISTIC_READ = CorfuComponent.OBJECT.toString() +</span>
                &quot;vlo.optimistic-read&quot;;
<span class="nc" id="L675">        private static final String VLO_UPDATED_OBJECT_READ = CorfuComponent.OBJECT.toString() +</span>
                &quot;vlo.updated-object-read&quot;;
<span class="nc" id="L677">        private static final String VLO_UPDATE = CorfuComponent.OBJECT.toString() + &quot;vlo.update&quot;;</span>
<span class="nc" id="L678">        private static final String VLO_GC = CorfuComponent.OBJECT.toString() + &quot;vlo.gc&quot;;</span>

        private static Timer.Context getOptimisticReadContext() {
<span class="nc" id="L681">            return MetricsUtils.getConditionalContext(metrics.timer(VLO_OPTIMISTIC_READ));</span>
        }

        private  static Timer.Context getUpdatedObjectReadContext() {
<span class="nc" id="L685">            return MetricsUtils.getConditionalContext(metrics.timer(VLO_UPDATED_OBJECT_READ));</span>
        }

        private  static Timer.Context getVloUpdateContext() {
<span class="nc" id="L689">            return MetricsUtils.getConditionalContext(metrics.timer(VLO_UPDATE));</span>
        }

        private  static Timer.Context getVloGcContext() {
<span class="nc" id="L693">            return MetricsUtils.getConditionalContext(metrics.timer(VLO_GC));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>