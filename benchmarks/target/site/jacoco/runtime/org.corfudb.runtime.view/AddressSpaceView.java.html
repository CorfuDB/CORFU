<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AddressSpaceView.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">benchmarks</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.view</a> &gt; <span class="el_source">AddressSpaceView.java</span></div><h1>AddressSpaceView.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.view;

import com.codahale.metrics.Gauge;
import com.codahale.metrics.MetricRegistry;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.RemovalNotification;
import com.google.common.collect.Iterables;
import com.google.common.util.concurrent.UncheckedExecutionException;
import io.netty.handler.timeout.TimeoutException;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.wireprotocol.DataType;
import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.protocols.wireprotocol.IToken;
import org.corfudb.protocols.wireprotocol.LogData;
import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;
import org.corfudb.protocols.wireprotocol.TailsResponse;
import org.corfudb.protocols.wireprotocol.Token;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.clients.LogUnitClient;
import org.corfudb.runtime.exceptions.NetworkException;
import org.corfudb.runtime.exceptions.OverwriteCause;
import org.corfudb.runtime.exceptions.OverwriteException;
import org.corfudb.runtime.exceptions.QuotaExceededException;
import org.corfudb.runtime.exceptions.StaleTokenException;
import org.corfudb.runtime.exceptions.TrimmedException;
import org.corfudb.runtime.exceptions.WriteSizeException;
import org.corfudb.runtime.exceptions.WrongEpochException;
import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;
import org.corfudb.util.CFUtils;
import org.corfudb.util.CorfuComponent;
import org.corfudb.util.MetricsUtils;
import org.corfudb.util.Sleep;
import org.corfudb.util.Utils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;


/**
 * A view of the address space implemented by Corfu.
 *
 * &lt;p&gt;Created by mwei on 12/10/15.&lt;/p&gt;
 */
<span class="nc" id="L61">@Slf4j</span>
public class AddressSpaceView extends AbstractView {

    /**
     * A cache for read results.
     */
    final Cache&lt;Long, ILogData&gt; readCache;

<span class="nc" id="L69">    final private long cacheKeySize = MetricsUtils.sizeOf.deepSizeOf(new Long(0));</span>

<span class="nc" id="L71">    final private long defaultMaxCacheEntries = 5000;</span>

<span class="nc" id="L73">    private final ReadOptions defaultReadOptions = ReadOptions.builder()</span>
<span class="nc" id="L74">            .ignoreTrim(false)</span>
<span class="nc" id="L75">            .waitForHole(true)</span>
<span class="nc" id="L76">            .clientCacheable(true)</span>
<span class="nc" id="L77">            .serverCacheable(true)</span>
<span class="nc" id="L78">            .build();</span>

    /**
     * Constructor for the Address Space View.
     */
    public AddressSpaceView(@Nonnull final CorfuRuntime runtime) {
<span class="nc" id="L84">        super(runtime);</span>

<span class="nc" id="L86">        CacheBuilder cacheBuilder = CacheBuilder.newBuilder();</span>

<span class="nc" id="L88">        long maxCacheEntries = runtime.getParameters().getMaxCacheEntries();</span>
<span class="nc" id="L89">        long maxCacheWeight = runtime.getParameters().getMaxCacheWeight();</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (maxCacheEntries != 0) {</span>
<span class="nc" id="L92">            cacheBuilder.maximumSize(runtime.getParameters().getMaxCacheEntries());</span>
        }

<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (maxCacheWeight != 0) {</span>
<span class="nc" id="L96">            cacheBuilder.maximumWeight(runtime.getParameters().getMaxCacheWeight());</span>
<span class="nc" id="L97">            cacheBuilder.weigher((k, v) -&gt; (int) (cacheKeySize + MetricsUtils.sizeOf.deepSizeOf(v)));</span>
        }

<span class="nc bnc" id="L100" title="All 4 branches missed.">        if (maxCacheEntries == 0 &amp;&amp; maxCacheWeight == 0) {</span>
            // If cache weight/size are not set, then we default to using
            // size based cache
<span class="nc" id="L103">            cacheBuilder.maximumSize(defaultMaxCacheEntries);</span>
        }

<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (runtime.getParameters().getCacheConcurrencyLevel() != 0) {</span>
<span class="nc" id="L107">            cacheBuilder.concurrencyLevel(runtime.getParameters().getCacheConcurrencyLevel());</span>
        }

<span class="nc" id="L110">        readCache = cacheBuilder.expireAfterAccess(runtime.getParameters().getCacheExpiryTime(), TimeUnit.SECONDS)</span>
<span class="nc" id="L111">                .expireAfterWrite(runtime.getParameters().getCacheExpiryTime(), TimeUnit.SECONDS)</span>
<span class="nc" id="L112">                .removalListener(this::handleEviction)</span>
<span class="nc" id="L113">                .recordStats()</span>
<span class="nc" id="L114">                .build();</span>

<span class="nc" id="L116">        MetricRegistry metrics = CorfuRuntime.getDefaultMetrics();</span>
<span class="nc" id="L117">        final String pfx = String.format(&quot;%s0x%x.cache.&quot;, CorfuComponent.ADDRESS_SPACE_VIEW.toString(),</span>
<span class="nc" id="L118">                                         this.hashCode());</span>
<span class="nc" id="L119">        metrics.register(pfx + &quot;cache-size&quot;, (Gauge&lt;Long&gt;) readCache::size);</span>
<span class="nc" id="L120">        metrics.register(pfx + &quot;evictions&quot;, (Gauge&lt;Long&gt;) () -&gt; readCache.stats().evictionCount());</span>
<span class="nc" id="L121">        metrics.register(pfx + &quot;hit-rate&quot;, (Gauge&lt;Double&gt;) () -&gt; readCache.stats().hitRate());</span>
<span class="nc" id="L122">        metrics.register(pfx + &quot;hits&quot;, (Gauge&lt;Long&gt;) () -&gt; readCache.stats().hitCount());</span>
<span class="nc" id="L123">        metrics.register(pfx + &quot;misses&quot;, (Gauge&lt;Long&gt;) () -&gt; readCache.stats().missCount());</span>
<span class="nc" id="L124">    }</span>

    public void handleEviction(RemovalNotification&lt;Long, ILogData&gt; notification) {
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L128">            log.trace(&quot;handleEviction: evicting {} cause {}&quot;, notification.getKey(), notification.getCause());</span>
        }
<span class="nc" id="L130">    }</span>

    /**
     * Remove all log entries that are less than the trim mark
     */
    public void gc(long trimMark) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        readCache.asMap().entrySet().removeIf(e -&gt; e.getKey() &lt; trimMark);</span>
<span class="nc" id="L137">    }</span>

    /**
     * Reset all in-memory caches.
     */
    public void resetCaches() {
<span class="nc" id="L143">        readCache.invalidateAll();</span>
<span class="nc" id="L144">    }</span>

    /**
     * Validates the state of a write after an exception occurred during the process
     *
     * There are [currently] three different scenarios:
     *   1. The data was persisted to some log units and we were able to recover it.
     *   2. The data was not persisted and another client (or this client) hole filled.
     *      In that case, we return an OverwriteException and let the upper layer handle it.
     *   3. The address we tried to write to was trimmed. In this case, there is no way to
     *      know if the write went through or not. For sanity, we throw an OverwriteException
     *      and let the above layer retry.
     *
     * @param address
     */
    private void validateStateOfWrittenEntry(long address, @Nonnull ILogData ld) {
        ILogData logData;
        try {
<span class="nc" id="L162">            logData = read(address);</span>
<span class="nc" id="L163">        } catch (TrimmedException te) {</span>
            // We cannot know if the write went through or not
<span class="nc" id="L165">            throw new UnrecoverableCorfuError(&quot;We cannot determine state of an update because of a trim.&quot;);</span>
<span class="nc" id="L166">        }</span>

<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (!logData.equals(ld)){</span>
<span class="nc" id="L169">            throw new OverwriteException(OverwriteCause.DIFF_DATA);</span>
        }
<span class="nc" id="L171">    }</span>

    /**
     * Write the given log data using a token, returning
     * either when the write has been completed successfully,
     * or throwing an OverwriteException if another value
     * has been adopted, or a WrongEpochException if the
     * token epoch is invalid.
     *
     * @param token        The token to use for the write.
     * @param data         The data to write.
     * @param cacheOption  The caching behaviour for this write
     * @throws OverwriteException   If the globalAddress given
     *                              by the token has adopted
     *                              another value.
     * @throws WrongEpochException  If the token epoch is invalid.
     */
    public void write(@Nonnull IToken token, @Nonnull Object data, @Nonnull CacheOption cacheOption) {
        ILogData ld;
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (data instanceof ILogData) {</span>
<span class="nc" id="L191">            ld = (ILogData) data;</span>
        } else {
<span class="nc" id="L193">            ld = new LogData(DataType.DATA, data);</span>
        }

<span class="nc" id="L196">        layoutHelper(e -&gt; {</span>
<span class="nc" id="L197">            Layout l = e.getLayout();</span>
            // Check if the token issued is in the same
            // epoch as the layout we are about to write
            // to.
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (token.getEpoch() != l.getEpoch()) {</span>
<span class="nc" id="L202">                throw new StaleTokenException(l.getEpoch());</span>
            }

            // Set the data to use the token
<span class="nc" id="L206">            ld.useToken(token);</span>
<span class="nc" id="L207">            ld.setId(runtime.getParameters().getClientId());</span>

            // Do the write
            try {
<span class="nc" id="L211">                l.getReplicationMode(token.getSequence())</span>
<span class="nc" id="L212">                        .getReplicationProtocol(runtime)</span>
<span class="nc" id="L213">                        .write(e, ld);</span>
<span class="nc" id="L214">            } catch (OverwriteException ex) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (ex.getOverWriteCause() == OverwriteCause.SAME_DATA){</span>
                    // If we have an overwrite exception with the SAME_DATA cause, it means that the
                    // server suspects our data has already been written, in this case we need to
                    // validate the state of the write.
<span class="nc" id="L219">                    validateStateOfWrittenEntry(token.getSequence(), ld);</span>
                } else {
                    // If we have an Overwrite exception with a different cause than SAME_DATA
                    // we do not need to validate the state of the write, as we know we have been
                    // certainly overwritten either by other data, by a hole or the address was trimmed.
                    // Large writes are also rejected right away.
<span class="nc" id="L225">                    throw ex;</span>
                }
<span class="nc" id="L227">            } catch (WriteSizeException | QuotaExceededException ie) {</span>
<span class="nc" id="L228">                log.warn(&quot;write: write failed&quot;, ie);</span>
<span class="nc" id="L229">                throw ie;</span>
<span class="nc" id="L230">            } catch (RuntimeException re) {</span>
<span class="nc" id="L231">                log.error(&quot;write: Got exception during replication protocol write with token: {}&quot;, token, re);</span>
<span class="nc" id="L232">                validateStateOfWrittenEntry(token.getSequence(), ld);</span>
<span class="nc" id="L233">            }</span>
<span class="nc" id="L234">            return null;</span>
        }, true);

        // Cache the successful write
<span class="nc bnc" id="L238" title="All 4 branches missed.">        if (!runtime.getParameters().isCacheDisabled() &amp;&amp; cacheOption == CacheOption.WRITE_THROUGH) {</span>
<span class="nc" id="L239">            readCache.put(token.getSequence(), ld);</span>
        }
<span class="nc" id="L241">    }</span>

    /**
     * Write the given log data and then add it to the address
     * space cache (i.e. WRITE_THROUGH option)
     *
     * @see AddressSpaceView#write(IToken, Object, CacheOption)
     */
    public void write(IToken token, Object data) throws OverwriteException {
<span class="nc" id="L250">        write(token, data, CacheOption.WRITE_THROUGH);</span>
<span class="nc" id="L251">    }</span>

    /**
     * Directly read from the log, returning any
     * committed value, or NULL, if no value has
     * been committed.
     *
     * @param address   The address to read from.
     * @return          Committed data stored in the
     *                  log, or NULL, if no value
     *                  has been committed.
     */
    public @Nullable ILogData peek(final long address) {
<span class="nc" id="L264">        return layoutHelper(e -&gt; e.getLayout().getReplicationMode(address)</span>
<span class="nc" id="L265">                    .getReplicationProtocol(runtime)</span>
<span class="nc" id="L266">                    .peek(e, address));</span>
    }

    /**
     * Perform a single read with the default read options
     */
    public @NonNull ILogData read(long address) {
<span class="nc" id="L273">        return read(address, defaultReadOptions);</span>
    }

    /**
     * Read the given object from an address and streams.
     *
     * @param address An address to read from.
     * @param options Read options for this particular write (i.e. configure caching behavior)
     * @return A result, which be cached.
     */
    public @Nonnull
<span class="nc bnc" id="L284" title="All 2 branches missed.">    ILogData read(long address, @NonNull ReadOptions options) {</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (cacheReadRequest(options)) {</span>
            // The VersionLockedObject and the Transaction layer will generate
            // undoRecord(s) during a transaction commit, or object sync. These
            // undo records are stored in transient fields and are not persisted.
            // A missing undo record can cause a NoRollbackException, thus forcing
            // a complete object rebuild that generates a &quot;scanning&quot; behavior
            // which affects the LRU window. In essence, affecting other cache users
            // and making the VersionLockedObject very sensitive to caching behavior.
            // A concrete example of this would be unsynchronized readers/writes:
            // 1. Thread A starts replicating write1
            // 2. Thread B discovers the write (via stream tail query) and
            //    tries to read write1
            // 3. Thread B's read results in a cache miss and the reader thread
            //    starts loading the value into the cache
            // 4. Thread A completes its write and caches it with undo records
            // 5. Thread B finishes loading and caches the loaded value replacing
            //    the cached value from step 4 (i.e. loss of undo records computed
            //    by thread A)
<span class="nc" id="L304">            ILogData data = readCache.getIfPresent(address);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (data == null) {</span>
                // Loading a value without the cache loader can result in
                // redundant loading calls (i.e. multiple threads try to
                // load the same value), but currently a redundant RPC
                // is much cheaper than the cost of a NoRollBackException, therefore
                // this trade-off is reasonable
<span class="nc" id="L311">                final ILogData loadedVal = fetch(address);</span>
<span class="nc" id="L312">                return cacheLoadAndGet(readCache, address, loadedVal);</span>
            }
<span class="nc" id="L314">            return data;</span>
        }

<span class="nc" id="L317">        return fetch(address);</span>
    }

    /**
     * Determine whether to cache or not based on the ReadOptions and CorfuRuntimeParameters
     * configurations
     */
    private boolean cacheReadRequest(ReadOptions options) {
<span class="nc bnc" id="L325" title="All 4 branches missed.">        return !runtime.getParameters().isCacheDisabled() &amp;&amp; options.isClientCacheable();</span>
    }

    /**
     * This method reads a batch of addresses if 'nextRead' is not found in the cache.
     * In the case of a cache miss, it piggybacks on the read for nextRead.
     *
     * If 'nextRead' is present in the cache, it directly returns this data.
     *
     * @param nextRead current address of interest
     * @param addresses batch of addresses to read (bring into the cache) in case there is a cache miss (includes
     *                  nextRead)
     * @param options  options for this read request
     * @return data for current 'address' of interest.
     */
    public @Nonnull
<span class="nc bnc" id="L341" title="All 4 branches missed.">    ILogData read(@NonNull Long nextRead, @NonNull NavigableSet&lt;Long&gt; addresses,</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                  @NonNull ReadOptions options) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (cacheReadRequest(options)) {</span>
<span class="nc" id="L344">            ILogData data = readCache.getIfPresent(nextRead);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (data == null) {</span>
<span class="nc" id="L346">                List&lt;Long&gt; batch = getBatch(nextRead, addresses);</span>
<span class="nc" id="L347">                log.trace(&quot;read: request address {}, read batch {}&quot;, nextRead, batch);</span>
<span class="nc" id="L348">                Map&lt;Long, ILogData&gt; mapAddresses = this.read(batch, options);</span>
<span class="nc" id="L349">                data = mapAddresses.get(nextRead);</span>
            }

<span class="nc" id="L352">            return data;</span>
        }

<span class="nc" id="L355">        return fetch(nextRead);</span>
    }

    /**
     * Prepare a batch of entries to be read, including the current address to retrieve.
     *
     * @param currentRead current address to retrieve.
     * @param queue queue to get entries from.
     * @return batch of entries.
     */
<span class="nc bnc" id="L365" title="All 2 branches missed.">    private List&lt;Long&gt; getBatch(long currentRead, @NonNull NavigableSet&lt;Long&gt; queue) {</span>
<span class="nc" id="L366">        int counter = 0;</span>
<span class="nc" id="L367">        List&lt;Long&gt; batchRead = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L368">        batchRead.add(currentRead);</span>
<span class="nc" id="L369">        counter++;</span>

<span class="nc" id="L371">        Iterator&lt;Long&gt; it = queue.iterator();</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">        while (it.hasNext() &amp;&amp; counter &lt; runtime.getParameters().getStreamBatchSize()) {</span>
<span class="nc" id="L373">            batchRead.add(it.next());</span>
<span class="nc" id="L374">            counter++;</span>
        }

<span class="nc" id="L377">        return batchRead;</span>
    }

    /**
     * Read the given object from a range of addresses.
     *
     * - If the waitForWrite flag is set to true, when an empty address is encountered,
     * it waits for one hole to be filled. All the rest empty addresses within the list
     * are hole filled directly and the reader does not wait.
     * - In case the flag is set to false, none of the reads wait for write completion and
     * the empty addresses are hole filled right away.
     *
     * @param addresses An iterable with addresses to read from
     * @return A result, which be cached.
     */
    public Map&lt;Long, ILogData&gt; read(Iterable&lt;Long&gt; addresses) {
<span class="nc" id="L393">        return read(addresses, defaultReadOptions);</span>
    }


    /**
     * Attempts to insert a loaded value into the cache and return the cached value for a particular key.
     */
    private ILogData cacheLoadAndGet(Cache&lt;Long, ILogData&gt; cache, long address, ILogData loadedValue) {
        try {
<span class="nc" id="L402">            return cache.get(address, () -&gt; loadedValue);</span>
<span class="nc" id="L403">        } catch (ExecutionException | UncheckedExecutionException e) {</span>
            // Guava wraps the exceptions thrown from the lower layers, therefore
            // we need to unwrap them before throwing them to the upper layers that
            // don't understand the guava exceptions
<span class="nc" id="L407">            Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L409">                throw (RuntimeException) cause;</span>
            } else {
<span class="nc" id="L411">                throw new RuntimeException(cause);</span>
            }
        }
    }

    /**
     * Read the given object from a range of addresses.
     *
     * @param addresses An iterable with addresses to read from
     * @return A map of addresses read, which will be cached if caching is enabled
     */
<span class="nc bnc" id="L422" title="All 2 branches missed.">    public Map&lt;Long, ILogData&gt; read(Iterable&lt;Long&gt; addresses, @NonNull ReadOptions options) {</span>
        // We need this map to preserve ordering as entries are expected in ascending order.
<span class="nc" id="L424">        Map&lt;Long, ILogData&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (cacheReadRequest(options)) {</span>
<span class="nc" id="L427">            Set&lt;Long&gt; addressesToFetch = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L429" title="All 2 branches missed.">            for (Long address : addresses) {</span>
<span class="nc" id="L430">                ILogData val = readCache.getIfPresent(address);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                if (val == null) {</span>
<span class="nc" id="L432">                    addressesToFetch.add(address);</span>
                } else {
<span class="nc" id="L434">                    result.put(address, val);</span>
                }
<span class="nc" id="L436">            }</span>

            // At this point we computed a subset of the addresses that
            // resulted in a cache miss and need to be fetched
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (!addressesToFetch.isEmpty()) {</span>
<span class="nc" id="L441">                Map&lt;Long, ILogData&gt; fetchedAddresses = fetchAll(addressesToFetch, options);</span>
<span class="nc" id="L442">                result.putAll(checkForTrimmedAddresses(fetchedAddresses, options));</span>
            }

<span class="nc" id="L445">            return result;</span>
        }

<span class="nc" id="L448">        Map&lt;Long, ILogData&gt; readAddresses = fetchAll(addresses, options);</span>
<span class="nc" id="L449">        return checkForTrimmedAddresses(readAddresses, options);</span>

    }

    /**
     * Get the first address in the address space.
     */
    public Token getTrimMark() {
<span class="nc" id="L457">        return layoutHelper(</span>
                e -&gt; {
<span class="nc" id="L459">                    long trimMark = e.getLayout().segments.stream()</span>
<span class="nc" id="L460">                            .flatMap(seg -&gt; seg.getStripes().stream())</span>
<span class="nc" id="L461">                            .flatMap(stripe -&gt; stripe.getLogServers().stream())</span>
<span class="nc" id="L462">                            .map(e::getLogUnitClient)</span>
<span class="nc" id="L463">                            .map(LogUnitClient::getTrimMark)</span>
<span class="nc" id="L464">                            .map(future -&gt; {</span>
                                // This doesn't look nice, but its required to trigger
                                // the retry mechanism in AbstractView. Also, getUninterruptibly
                                // can't be used here because it throws a UnrecoverableCorfuInterruptedError
                                try {
<span class="nc" id="L469">                                    return future.join();</span>
<span class="nc" id="L470">                                } catch (CompletionException ex) {</span>
<span class="nc" id="L471">                                    Throwable cause = ex.getCause();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                                    if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L473">                                        throw (RuntimeException) cause;</span>
                                    } else {
<span class="nc" id="L475">                                        throw new RuntimeException(cause);</span>
                                    }
                                }
                            })
<span class="nc" id="L479">                            .max(Comparator.naturalOrder()).get();</span>
<span class="nc" id="L480">                    return new Token(e.getLayout().getEpoch(), trimMark);</span>
                });
    }

    /**
     * Get the log's tail, i.e., last address in the address space.
     */
    public Long getLogTail() {
<span class="nc" id="L488">        return layoutHelper(</span>
<span class="nc" id="L489">                e -&gt; Utils.getLogTail(e.getLayout(), runtime));</span>
    }

    /**
     * Get all tails, includes: log tail and stream tails.
     */
    public TailsResponse getAllTails() {
<span class="nc" id="L496">        return layoutHelper(</span>
<span class="nc" id="L497">                e -&gt; Utils.getAllTails(e.getLayout(), runtime));</span>
    }

    /**
     * Get log address space, which includes:
     *     1. Addresses belonging to each stream.
     *     2. Log Tail.
     * @return
     */
    public StreamsAddressResponse getLogAddressSpace() {
<span class="nc" id="L507">        return layoutHelper(</span>
<span class="nc" id="L508">                e -&gt; Utils.getLogAddressSpace(e.getLayout(), runtime));</span>
    }

    /**
     * Prefix trim the address space.
     *
     * &lt;p&gt;At the end of a prefix trim, all addresses equal to or
     * less than the address given will be marked for trimming,
     * which means that they may return either the original
     * data, or a trimmed exception.&lt;/p&gt;
     *
     * @param address log address
     */
    public void prefixTrim(final Token address) {
<span class="nc" id="L522">        log.info(&quot;PrefixTrim[{}]&quot;, address);</span>
<span class="nc" id="L523">        final int numRetries = 3;</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (int x = 0; x &lt; numRetries; x++) {</span>
            try {
                // By changing the order of the trimming operations, i.e., signal the
                // sequencer about a trim before actually trimming the log unit, we prevent a race condition,
                // in which a client could attempt to read a trimmed address over and over again, as signal
                // has not reached the sequencer. The problem with this is that we have a retry limit of 2, so
                // if the race is present on just one cycle we will abort due to trimmed exception.
                // In this case we avoid this case, and even if the log unit trim fails,
                // this data is checkpointed so there is no actual correctness implication.
                // TODO(Maithem): trimCache should be epoch aware?
<span class="nc" id="L535">                runtime.getSequencerView().trimCache(address.getSequence());</span>

<span class="nc" id="L537">                layoutHelper(e -&gt; {</span>
<span class="nc" id="L538">                            e.getLayout().getPrefixSegments(address.getSequence()).stream()</span>
<span class="nc" id="L539">                                    .flatMap(seg -&gt; seg.getStripes().stream())</span>
<span class="nc" id="L540">                                    .flatMap(stripe -&gt; stripe.getLogServers().stream())</span>
<span class="nc" id="L541">                                    .map(e::getLogUnitClient)</span>
<span class="nc" id="L542">                                    .map(client -&gt; client.prefixTrim(address))</span>
<span class="nc" id="L543">                                    .forEach(cf -&gt; {CFUtils.getUninterruptibly(cf,</span>
                                            NetworkException.class, TimeoutException.class,
                                            WrongEpochException.class);
<span class="nc" id="L546">                                    });</span>
<span class="nc" id="L547">                            return null;</span>
                }, true);
<span class="nc" id="L549">                break;</span>
<span class="nc" id="L550">            } catch (NetworkException | TimeoutException e) {</span>
<span class="nc" id="L551">                log.warn(&quot;prefixTrim: encountered a network error on try {}&quot;, x, e);</span>
<span class="nc" id="L552">                Duration retryRate = runtime.getParameters().getConnectionRetryRate();</span>
<span class="nc" id="L553">                Sleep.sleepUninterruptibly(retryRate);</span>
<span class="nc" id="L554">            } catch (WrongEpochException wee) {</span>
<span class="nc" id="L555">                long serverEpoch = wee.getCorrectEpoch();</span>
<span class="nc" id="L556">                long runtimeEpoch = runtime.getLayoutView().getLayout().getEpoch();</span>
<span class="nc" id="L557">                log.warn(&quot;prefixTrim[{}]: wrongEpochException, runtime is in epoch {}, while server is in epoch {}. &quot;</span>
                                + &quot;Invalidate layout for this client and retry, attempt: {}/{}&quot;,
<span class="nc" id="L559">                        address, runtimeEpoch, serverEpoch, x + 1, numRetries);</span>
<span class="nc" id="L560">                runtime.invalidateLayout();</span>
<span class="nc" id="L561">            }</span>
        }
<span class="nc" id="L563">    }</span>

    /** Force compaction on an address space, which will force
     * all log units to free space, and process any outstanding
     * trim requests.
     *
     */
    public void gc() {
<span class="nc" id="L571">        log.debug(&quot;GarbageCollect&quot;);</span>
<span class="nc" id="L572">        layoutHelper(e -&gt; {</span>
<span class="nc" id="L573">            e.getLayout().segments.stream()</span>
<span class="nc" id="L574">                    .flatMap(seg -&gt; seg.getStripes().stream())</span>
<span class="nc" id="L575">                    .flatMap(stripe -&gt; stripe.getLogServers().stream())</span>
<span class="nc" id="L576">                    .map(e::getLogUnitClient)</span>
<span class="nc" id="L577">                    .map(LogUnitClient::compact)</span>
<span class="nc" id="L578">                    .forEach(CFUtils::getUninterruptibly);</span>
<span class="nc" id="L579">            return null;</span>
        });
<span class="nc" id="L581">    }</span>

    /**
     * Force all server caches to be invalidated.
     */
    public void invalidateServerCaches() {
<span class="nc" id="L587">        log.debug(&quot;InvalidateServerCaches&quot;);</span>
<span class="nc" id="L588">        layoutHelper(e -&gt; {</span>
<span class="nc" id="L589">            e.getLayout().segments.stream()</span>
<span class="nc" id="L590">                    .flatMap(seg -&gt; seg.getStripes().stream())</span>
<span class="nc" id="L591">                    .flatMap(stripe -&gt; stripe.getLogServers().stream())</span>
<span class="nc" id="L592">                    .map(e::getLogUnitClient)</span>
<span class="nc" id="L593">                    .map(LogUnitClient::flushCache)</span>
<span class="nc" id="L594">                    .forEach(CFUtils::getUninterruptibly);</span>
<span class="nc" id="L595">            return null;</span>
        });
<span class="nc" id="L597">    }</span>

    /**
     * Force the client cache to be invalidated.
     */
    public void invalidateClientCache() {
<span class="nc" id="L603">        readCache.invalidateAll();</span>
<span class="nc" id="L604">    }</span>

    /**
     * Fetch a collection of addresses for insertion into the cache.
     *
     * Does not validate log entries.
     *
     * @param addresses     collection of addresses to read from.
     *
     * @return a map of read addresses.
     */
    @Nonnull
    private Map&lt;Long, ILogData&gt; fetchAll(Iterable&lt;Long&gt; addresses, ReadOptions options) {
<span class="nc" id="L617">        Map&lt;Long, ILogData&gt; result = new TreeMap&lt;&gt;();</span>

<span class="nc" id="L619">        Iterable&lt;List&lt;Long&gt;&gt; batches = Iterables.partition(addresses,</span>
<span class="nc" id="L620">                runtime.getParameters().getBulkReadSize());</span>

<span class="nc bnc" id="L622" title="All 2 branches missed.">        for (List&lt;Long&gt; batch : batches) {</span>
            // Doesn't handle the case where some address have a different replication mode
<span class="nc" id="L624">            Map&lt;Long, ILogData&gt; batchResult = layoutHelper(e -&gt; e.getLayout()</span>
<span class="nc" id="L625">                    .getReplicationMode(batch.iterator().next())</span>
<span class="nc" id="L626">                    .getReplicationProtocol(runtime)</span>
<span class="nc" id="L627">                    .readAll(e, batch, options.isWaitForHole(), options.isServerCacheable()));</span>
            // Sanity check for returned addresses
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (batchResult.size() != batch.size()) {</span>
<span class="nc" id="L630">                log.error(&quot;fetchAll: Requested number of addresses not equal to the read result&quot; +</span>
<span class="nc" id="L631">                        &quot;from server, requested: {}, returned: {}&quot;, batch, batchResult.keySet());</span>
<span class="nc" id="L632">                throw new IllegalStateException(&quot;Requested number of addresses not equal to the read result&quot;);</span>
            }
<span class="nc" id="L634">            result.putAll(batchResult);</span>
<span class="nc" id="L635">        }</span>

<span class="nc" id="L637">        return result;</span>
    }

    /**
     * Check list of returned data for trimmed data.
     *
     * @param result list of read data
     *
     * @return map with valid data (not trimmed) or TrimmedException is thrown is data is trimmed and
     * flag is not set.
     */
    private Map&lt;Long, ILogData&gt; checkForTrimmedAddresses(Map&lt;Long, ILogData&gt; result, ReadOptions options) {
<span class="nc" id="L649">        List&lt;Long&gt; trimmedAddresses = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L651" title="All 2 branches missed.">        for (Map.Entry&lt;Long, ILogData&gt; entry : result.entrySet()) {</span>
            // Add trimmed addresses to list
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (!checkLogData(entry.getKey(), entry.getValue(), false)) {</span>
<span class="nc" id="L654">                trimmedAddresses.add(entry.getKey());</span>
            } else {
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (options.isClientCacheable()) {</span>
                    // After fetching a value, we need to insert it in the cache.
                    // Even if trimmed exceptions are thrown, we cache the valid data.
<span class="nc" id="L659">                    result.put(entry.getKey(), cacheLoadAndGet(readCache, entry.getKey(), entry.getValue()));</span>
                } else {
<span class="nc" id="L661">                    result.put(entry.getKey(), entry.getValue());</span>
                }
            }
<span class="nc" id="L664">        }</span>

<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (!trimmedAddresses.isEmpty()) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (!options.isIgnoreTrim()) {</span>
<span class="nc" id="L668">                throw new TrimmedException(trimmedAddresses);</span>
            }

<span class="nc" id="L671">            log.warn(&quot;read: ignoring trimmed addresses {}&quot;, trimmedAddresses);</span>
        }

<span class="nc" id="L674">        return result;</span>
    }

    /**
     * Checks whether a log entry is valid or not. If a read
     * returns null, Empty, or trimmed an exception will be
     * thrown.
     *
     * @param address the address being checked
     * @param logData the ILogData at the address being checked
     * @return true if valid data, false if address is trimmed.
     */
    private boolean checkLogData(long address, ILogData logData, boolean throwException) {
<span class="nc bnc" id="L687" title="All 4 branches missed.">        if (logData == null || logData.getType() == DataType.EMPTY) {</span>
<span class="nc" id="L688">            throw new RuntimeException(&quot;Unexpected return of empty data at address &quot;</span>
                    + address + &quot; on read&quot;);
        }

<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (logData.isTrimmed()) {</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (throwException) {</span>
<span class="nc" id="L694">                throw new TrimmedException(String.format(&quot;Trimmed address %s&quot;, address));</span>
            }
<span class="nc" id="L696">            return false;</span>
        }

<span class="nc" id="L699">        return true;</span>
    }

    /**
     * Explicitly fetch a given address, bypassing the cache.
     *
     * @param address an address to read from.
     * @return the log data read at address
     */
    private  @Nonnull
    ILogData fetch(final long address) {
<span class="nc" id="L710">        ILogData result = layoutHelper(e -&gt; e.getLayout().getReplicationMode(address)</span>
<span class="nc" id="L711">                .getReplicationProtocol(runtime)</span>
<span class="nc" id="L712">                .read(e, address)</span>
        );

<span class="nc" id="L715">        checkLogDataThrowException(address, result);</span>

<span class="nc" id="L717">        return result;</span>
    }

    private void checkLogDataThrowException(long address, ILogData result) {
<span class="nc" id="L721">        checkLogData(address, result, true);</span>
<span class="nc" id="L722">    }</span>

    @VisibleForTesting
    Cache&lt;Long, ILogData&gt; getReadCache() {
<span class="nc" id="L726">        return readCache;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>