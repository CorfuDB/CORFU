<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AddressMapStreamView.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">universe</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.view.stream</a> &gt; <span class="el_source">AddressMapStreamView.java</span></div><h1>AddressMapStreamView.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.view.stream;

import java.util.Collections;
import java.util.List;
import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.UUID;
import java.util.function.Function;

import javax.annotation.Nonnull;

import com.google.common.collect.Iterables;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.protocols.wireprotocol.StreamAddressRange;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.exceptions.TrimmedException;
import org.corfudb.runtime.view.Address;
import org.corfudb.runtime.view.ObjectsView;
import org.corfudb.runtime.view.StreamOptions;
import org.roaringbitmap.longlong.Roaring64NavigableMap;


/** A view of a stream implemented with address maps.
 *
 * A stream's address space is discovered by requesting to the
 * sequencer, the map of all addresses belonging to this stream.
 *
 * Notice that, unlike the BackpointerStreamView, addresses are discovered
 * in a single call to the sequencer, therefore, entries are not read
 * in advance. For this reason, when iterating over the stream (getNextEntry)
 * we perform batch reads, which significantly reduces the number of RPCs to
 * Log Units, as opposed to reading one entry at a time. Also, single stepping
 * in the presence of holes is no longer a need as address space is determined
 * by the map provided by the sequencer.
 *
 * Created by annym on 04/25/19.
 */
<span class="nc" id="L41">@Slf4j</span>
public class AddressMapStreamView extends AbstractQueuedStreamView {

    private static final int DIFF_CONSECUTIVE_ADDRESSES = 1;

<span class="nc" id="L46">    private long addressCount = 0L;</span>

    /** Create a new address map stream view.
     *
     * @param runtime   The runtime to use for accessing the log.
     * @param streamId  The ID of the stream to view.
     */
    public AddressMapStreamView(final CorfuRuntime runtime,
                                final UUID streamId,
                                @Nonnull final StreamOptions options) {
<span class="nc" id="L56">        super(runtime, streamId, options);</span>
<span class="nc" id="L57">    }</span>

    public AddressMapStreamView(final CorfuRuntime runtime,
                                final UUID streamId) {
<span class="nc" id="L61">        this(runtime, streamId, StreamOptions.DEFAULT);</span>
<span class="nc" id="L62">    }</span>

    @Override
    protected ILogData removeFromQueue(NavigableSet&lt;Long&gt; queue) {
        boolean readNext;
<span class="nc" id="L67">        ILogData ld = null;</span>
        Long currentRead;

        do {
<span class="nc" id="L71">            currentRead = queue.pollFirst();</span>

<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (currentRead == null) {</span>
                // no more entries, empty queue.
<span class="nc" id="L75">                return null;</span>
            }

            try {
                // Because the discovery mechanism implemented by this class
                // does not require to read log entries in advance (only requests
                // the stream's full address map, without reading the actual data), entries can be read in
                // batches whenever we have a cache miss. This allows next reads
                // to be serviced immediately, rather than reading one entry at a time.
<span class="nc" id="L84">                ld = read(currentRead, queue);</span>

<span class="nc bnc" id="L86" title="All 4 branches missed.">                if (queue == getCurrentContext().readQueue &amp;&amp; ld != null) {</span>
                    // Validate that the data entry belongs to this stream, otherwise, skip.
                    // This verification protects from sequencer regression (tokens assigned in an older epoch
                    // that were never written to, and reassigned on a newer epoch)
<span class="nc bnc" id="L90" title="All 2 branches missed.">                    if (ld.containsStream(this.id)) {</span>
<span class="nc" id="L91">                        addToResolvedQueue(getCurrentContext(), currentRead, ld);</span>
<span class="nc" id="L92">                        readNext = false;</span>
                    } else {
<span class="nc" id="L94">                        log.trace(&quot;getNextEntry[{}]: the data for address {} does not belong to this stream. Skip.&quot;,</span>
                                this, currentRead);
                        // Invalid entry (does not belong to this stream). Read next.
<span class="nc" id="L97">                        readNext = true;</span>
                    }
                } else {
<span class="nc" id="L100">                    readNext = false;</span>
                }
<span class="nc" id="L102">            } catch (TrimmedException te) {</span>
                // Because addresses are requested in increasing order and system relies on prefix trim,
                // we force trimmedExceptions to be thrown by lower layers, and handle ignoreTrimmed at this layer.
                // Note that lower layers will cache the valid entries, to optimize read performance.

<span class="nc bnc" id="L107" title="All 2 branches missed.">                if (!getReadOptions().isIgnoreTrim()) {</span>
<span class="nc" id="L108">                    throw te;</span>
                }

<span class="nc" id="L111">                log.debug(&quot;removeFromQueue[{}]: ignoring trimmed addresses {}&quot;, this, te.getTrimmedAddresses());</span>
                // Ignore trimmed address, remove trimmed addresses and get next from queue
<span class="nc" id="L113">                te.getTrimmedAddresses().forEach(address -&gt; queue.remove(address));</span>

                // If a TrimmedException was caught, the requested address (nextRead) is trimmed (lower of all),
                // we need to continue reading to retrieve the next valid entry for this stream.
<span class="nc" id="L117">                readNext = true;</span>
<span class="nc" id="L118">            }</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        } while (readNext);</span>

<span class="nc" id="L121">        return ld;</span>
    }

    /**
     * Retrieve this stream's address map, i.e., a map of all addresses corresponding to this stream between
     * (stop address, start address] and return a boolean indicating if addresses were found in this range.
     *
     * @param streamId stream's ID, it is required because this same method can be used for
     *                 discovering addresses from the checkpoint stream.
     * @param queue    queue to insert discovered addresses in the given range
     * @param startAddress range start address (inclusive)
     * @param stopAddress  range end address (exclusive and lower than start address)
     * @param filter       function to filter entries
     * @param checkpoint   boolean indicating if it is a checkpoint stream
     * @param maxGlobal    maximum Address until which we want to sync (is not necessarily equal to start address)
     * @return
     */
    @Override
    protected boolean discoverAddressSpace(final UUID streamId,
                                           final NavigableSet&lt;Long&gt; queue,
                                           final long startAddress,
                                           final long stopAddress,
                                           final Function&lt;ILogData, Boolean&gt; filter,
                                           final boolean checkpoint,
                                           final long maxGlobal) {
        // Sanity check: startAddress must be a valid address and greater than stopAddress.
        // The startAddress refers to the max resolution we want to resolve this stream to,
        // while stopAddress refers to the lower boundary (locally resolved).
        // If startAddress is equal to stopAddress there is nothing to resolve.
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if (Address.isAddress(startAddress) &amp;&amp; (startAddress &gt; stopAddress)) {</span>

<span class="nc" id="L152">            StreamAddressSpace streamAddressSpace = getStreamAddressMap(startAddress, stopAddress, streamId);</span>

<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (checkpoint) {</span>
<span class="nc" id="L155">                processCheckpoint(streamAddressSpace, filter, queue);</span>
            } else {
                // Transfer discovered addresses to queue. We must limit to maxGlobal,
                // as startAddress could be ahead of maxGlobal---in case it reflects
                // the tail of the stream.
<span class="nc" id="L160">                queue.addAll(streamAddressSpace.copyAddressesToSet(maxGlobal));</span>

<span class="nc" id="L162">                long trimMark = streamAddressSpace.getTrimMark();</span>

                // In case we are dealing with a stream that does not have the checkpoint
                // capability, check to see if we are trying to access an address that has been
                // previously trimmed.
<span class="nc bnc" id="L167" title="All 2 branches missed.">                if (!isCheckpointCapable()</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">                        &amp;&amp; Address.isAddress(trimMark)</span>
                        &amp;&amp; trimMark &gt; stopAddress) {
<span class="nc" id="L170">                    String message = String.format(&quot;getStreamAddressMap[{%s}] stream has been &quot; +</span>
                                    &quot;trimmed at address %s and we are trying to access the &quot; +
                                    &quot;stream starting at address %s. This stream does not have &quot; +
<span class="nc" id="L173">                                    &quot;the checkpoint capability.&quot;, this, trimMark, stopAddress);</span>
<span class="nc" id="L174">                    log.info(message);</span>
<span class="nc" id="L175">                    throw new TrimmedException(message);</span>
                }
                // Address maps might have been trimmed, hence not reflecting all updates to the stream
                // For this reason, in the case of a valid trim mark, we must be sure this space is
                // already resolved or loaded by a checkpoint.
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (isCheckpointCapable()</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        &amp;&amp; Address.isAddress(trimMark)</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                        &amp;&amp; !isTrimCoveredByCheckpointOrLocalView(trimMark)) {</span>
<span class="nc" id="L183">                    String message = String.format(&quot;getStreamAddressMap[{%s}] stream has been &quot; +</span>
                                    &quot;trimmed at address %s and this space is not covered by the &quot; +
                                    &quot;loaded checkpoint with start address %s, while accessing the &quot; +
                                    &quot;stream at version %s. Looking for a new checkpoint.&quot;,this,
<span class="nc" id="L187">                            trimMark, getCurrentContext().checkpoint.startAddress, maxGlobal);</span>
<span class="nc" id="L188">                    log.info(message);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                    if (getReadOptions().isIgnoreTrim()) {</span>
<span class="nc" id="L190">                        log.debug(&quot;getStreamAddressMap[{}]: Ignoring trimmed exception for address[{}].&quot;,</span>
<span class="nc" id="L191">                                this, streamAddressSpace.getTrimMark());</span>
                    } else {
<span class="nc" id="L193">                        throw new TrimmedException(message);</span>
                    }
                }
            }
        }

<span class="nc" id="L199">        addressCount += queue.size();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        return !queue.isEmpty();</span>
    }

    private void processCheckpoint(StreamAddressSpace streamAddressSpace, Function&lt;ILogData, Boolean&gt; filter,
                                   NavigableSet&lt;Long&gt; queue) {
<span class="nc" id="L205">        SortedSet&lt;Long&gt; checkpointAddresses = new TreeSet&lt;&gt;(Collections.reverseOrder());</span>
<span class="nc" id="L206">        streamAddressSpace.getAddressMap().forEach(checkpointAddresses::add);</span>

        // Checkpoint entries will be read in batches of a predefined size,
        // the reason not to read them all in a single call is that:
        // 1. There might be more than one checkpoint.
        // 2. Because trims are async (between sequencer and log unit), part of these
        // addresses (for instance for the first checkpoint) might have been already
        // trimmed from the log, but stream maps (sequencer) still do not reflect it
        // (causing unnecessary TrimmedExceptions--as this checkpoint is not even
        // needed in the first place).
<span class="nc" id="L216">        Iterable&lt;List&lt;Long&gt;&gt; batches = Iterables.partition(checkpointAddresses,</span>
<span class="nc" id="L217">                runtime.getParameters().getCheckpointReadBatchSize());</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">        for (List&lt;Long&gt; batch : batches) {</span>
            try {
<span class="nc" id="L221">                List&lt;ILogData&gt; entries = readAll(batch);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                for (ILogData data : entries) {</span>
<span class="nc" id="L223">                    filter.apply(data);</span>
<span class="nc" id="L224">                }</span>
<span class="nc" id="L225">            } catch (TrimmedException te) {</span>
<span class="nc" id="L226">                log.warn(&quot;processCheckpoint: trimmed addresses {}&quot;, te.getTrimmedAddresses());</span>
                // Read one entry at a time for the last failed batch, this way we might load
                // the required checkpoint entries until the stop condition is fulfilled
                // without hitting a trimmed position.
<span class="nc" id="L230">                processCheckpointBatchByEntry(batch, filter);</span>

                // Because checkpoint addresses were ordered in reverse,
                // we don't need to continue reading entries (prefix trim).
<span class="nc" id="L234">                break;</span>
<span class="nc" id="L235">            }</span>
<span class="nc" id="L236">        }</span>

        // Select correct checkpoint - Highest
<span class="nc" id="L239">        List&lt;Long&gt; checkpointEntries = resolveCheckpoint(getCurrentContext());</span>
<span class="nc" id="L240">        queue.addAll(checkpointEntries);</span>
<span class="nc" id="L241">    }</span>

    /**
     * Process a batch of addresses as single entries.
     *
     * @param batch list of addresses to read.
     * @param filter filter to apply to checkpoint data.
     *
     * @return True, resolved checkpoint (reached end of valid checkpoint).
     *         False, otherwise.
     */
    private void processCheckpointBatchByEntry(List&lt;Long&gt; batch,
                                                  Function&lt;ILogData, Boolean&gt; filter) {
<span class="nc" id="L254">        log.debug(&quot;processCheckpointBatchByEntry[{}]: single step across {}&quot;, this, batch);</span>
        try {
            boolean checkpointResolved;
<span class="nc bnc" id="L257" title="All 2 branches missed.">            for (long address : batch) {</span>
<span class="nc" id="L258">                ILogData data = read(address);</span>
<span class="nc" id="L259">                checkpointResolved = filter.apply(data);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (checkpointResolved) {</span>
                    // Return if checkpoint has already been resolved (reached stop).
<span class="nc" id="L262">                    break;</span>
                }
<span class="nc" id="L264">            }</span>
<span class="nc" id="L265">        } catch (TrimmedException ste) {</span>
            // Even if this checkpoint was not resolved, we can safely return as previous read checkpoints
            // might have resolved. If none was found, the stream will be rebuilt from the regular stream
            // address space.
<span class="nc" id="L269">            return;</span>
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">    }</span>

    private StreamAddressSpace getStreamAddressMap(long startAddress, long stopAddress, UUID streamId) {
        // Case non-consecutive addresses
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (startAddress - stopAddress &gt; DIFF_CONSECUTIVE_ADDRESSES) {</span>
<span class="nc" id="L276">            log.trace(&quot;getStreamAddressMap[{}] get addresses from {} to {}&quot;, this, startAddress, stopAddress);</span>
            // This step is an optimization.
            // Attempt to read the last entry and verify its backpointer,
            // if this address is already resolved locally do not request the stream map to the sequencer as new
            // updates are not required to be synced (this benefits single runtime writers).
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if(isAddressToBackpointerResolved(startAddress, streamId)) {</span>
<span class="nc" id="L282">                return new StreamAddressSpace(Address.NON_ADDRESS, Roaring64NavigableMap.bitmapOf(startAddress));</span>
            }

<span class="nc" id="L285">            log.trace(&quot;getStreamAddressMap[{}]: request stream address space between {} and {}.&quot;,</span>
<span class="nc" id="L286">                        streamId, startAddress, stopAddress);</span>
<span class="nc" id="L287">            return runtime.getSequencerView()</span>
<span class="nc" id="L288">                    .getStreamAddressSpace(new StreamAddressRange(streamId, startAddress, stopAddress));</span>
        }

        // Start and stop address are consecutive addresses, no need to request the address map for this stream,
        // the only address to include is startAddress (stopAddress is already resolved - not included in the lookup).
<span class="nc" id="L293">        return new StreamAddressSpace(Address.NON_ADDRESS, Roaring64NavigableMap.bitmapOf(startAddress));</span>
    }

    private boolean isAddressToBackpointerResolved(long startAddress, UUID streamId) {
        ILogData d;
        try {
<span class="nc" id="L299">            d = read(startAddress);</span>
<span class="nc" id="L300">        } catch (TrimmedException e) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (getReadOptions().isIgnoreTrim()) {</span>
<span class="nc" id="L302">                log.debug(&quot;isAddressToBackpointerResolved[{}]: Ignoring trimmed exception for address[{}],&quot; +</span>
<span class="nc" id="L303">                        &quot; stream[{}]&quot;, this, startAddress, streamId);</span>
<span class="nc" id="L304">                return false;</span>
            } else {
                // Info level as trimmedExceptions are handled by upper layers, which accordingly retry
                // and abort in the case that a stream cannot be resolved from a checkpoint.
<span class="nc" id="L308">                log.info(&quot;getStreamAddressMap[{}]; Attempting to resolve backpointer for {} but address is trimmed. &quot; +</span>
                                &quot;Looking for a checkpoint.&quot;,
<span class="nc" id="L310">                        this, startAddress);</span>
<span class="nc" id="L311">                throw e;</span>
            }
<span class="nc" id="L313">        }</span>

<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (d.hasBackpointer(streamId)) {</span>
<span class="nc" id="L316">            long previousAddress = d.getBackpointer(streamId);</span>
<span class="nc" id="L317">            log.trace(&quot;getStreamAddressMap[{}]: backpointer for {} points to {}&quot;,</span>
<span class="nc" id="L318">                    streamId, startAddress, previousAddress);</span>
            // if backpointer is a valid log address or Address.NON_EXIST (beginning of the stream)
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if ((Address.isAddress(previousAddress) &amp;&amp;</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">                    getCurrentContext().resolvedQueue.contains(previousAddress))</span>
                    || previousAddress == Address.NON_EXIST) {
<span class="nc" id="L323">                log.trace(&quot;getStreamAddressMap[{}]: backpointer {} is locally present, do not request &quot; +</span>
<span class="nc" id="L324">                        &quot;stream address map.&quot;, streamId, previousAddress);</span>
<span class="nc" id="L325">                return true;</span>
            }
        }

<span class="nc" id="L329">        return false;</span>
    }

    /**
     * Verify that a trim is covered either by a loaded checkpoint or by the locally resolved addresses.
     *
     * Because address maps might have been trimmed, the trim mark is a 'marker' of addresses that were
     * removed from the map (historical) and that should be covered by a checkpoint.
     *
     * @param trimMark
     * @return TRUE, trim mark contained in checkpoint, FALSE, otherwise.
     */
    private boolean isTrimCoveredByCheckpointOrLocalView(long trimMark) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        return isTrimResolvedLocally(trimMark) ||</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                isTrimCoveredByCheckpoint(trimMark);</span>
    }

    private boolean isTrimResolvedLocally(long trimMark) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        return getCurrentContext().checkpoint.id == null</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                &amp;&amp; getCurrentContext().resolvedQueue.contains(trimMark);</span>
    }

    private boolean isTrimCoveredByCheckpoint(long trimMark) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">        return getCurrentContext().checkpoint.id != null &amp;&amp;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                getCurrentContext().checkpoint.startAddress &gt;= trimMark;</span>
    }

    /**
     * Check to see if the current stream is checkpoint capable.
     *
     * @return whether this stream is capable of being checkpointed
     */
    private boolean isCheckpointCapable() {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        return !getId().equals(ObjectsView.TRANSACTION_STREAM_ID);</span>
    }

    @Override
    public long getTotalUpdates() {
<span class="nc" id="L367">        return addressCount;</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>