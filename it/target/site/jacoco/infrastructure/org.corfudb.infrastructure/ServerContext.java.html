<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ServerContext.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">universe</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">ServerContext.java</span></div><h1>ServerContext.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import static org.corfudb.util.MetricsUtils.isMetricsReportingSetUp;

import com.codahale.metrics.MetricRegistry;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import io.netty.channel.EventLoopGroup;

import java.io.File;
import java.nio.file.Files;
import java.time.Duration;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.comm.ChannelImplementation;
import org.corfudb.infrastructure.paxos.PaxosDataStore;
import org.corfudb.protocols.wireprotocol.PriorityLevel;
import org.corfudb.protocols.wireprotocol.failuredetector.FailureDetectorMetrics;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.CorfuRuntime.CorfuRuntimeParameters;
import org.corfudb.runtime.exceptions.WrongEpochException;
import org.corfudb.runtime.view.ConservativeFailureHandlerPolicy;
import org.corfudb.runtime.view.IReconfigurationHandlerPolicy;
import org.corfudb.runtime.view.Layout;
import org.corfudb.runtime.view.Layout.LayoutSegment;
import org.corfudb.util.MetricsUtils;
import org.corfudb.util.NodeLocator;
import org.corfudb.util.UuidUtils;

/**
 * Server Context:
 * &lt;ul&gt;
 * &lt;li&gt;Contains the common node level {@link DataStore}&lt;/li&gt;
 * &lt;li&gt;Responsible for Server level EPOCH &lt;/li&gt;
 * &lt;li&gt;Should contain common services/utilities that the different Servers in a node require.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note:
 * It is created in {@link CorfuServer} and then
 * passed to all the servers including {@link NettyServerRouter}.
 *
 * &lt;p&gt;Created by mdhawan on 8/5/16.
 */
<span class="nc" id="L62">@Slf4j</span>
public class ServerContext implements AutoCloseable {

    // Layout Server
    private static final String PREFIX_EPOCH = &quot;SERVER_EPOCH&quot;;
    private static final String KEY_EPOCH = &quot;CURRENT&quot;;
    private static final String PREFIX_LAYOUT = &quot;LAYOUT&quot;;
    private static final String KEY_LAYOUT = &quot;CURRENT&quot;;
    private static final String PREFIX_LAYOUTS = &quot;LAYOUTS&quot;;

    // Sequencer Server
    private static final String KEY_SEQUENCER = &quot;SEQUENCER&quot;;
    private static final String PREFIX_SEQUENCER_EPOCH = &quot;EPOCH&quot;;

    // Management Server
    private static final String PREFIX_MANAGEMENT = &quot;MANAGEMENT&quot;;
    private static final String MANAGEMENT_LAYOUT = &quot;LAYOUT&quot;;

    // Failure detector
    private static final String PREFIX_FAILURE_DETECTOR = &quot;FAILURE_DETECTOR&quot;;

    // LogUnit Server
    private static final String PREFIX_LOGUNIT = &quot;LOGUNIT&quot;;
    private static final String EPOCH_WATER_MARK = &quot;EPOCH_WATER_MARK&quot;;

    /** The node Id, stored as a base64 string. */
    private static final String NODE_ID = &quot;NODE_ID&quot;;

    /**
     * various duration constants.
     */
<span class="nc" id="L93">    public static final Duration SHUTDOWN_TIMER = Duration.ofSeconds(5);</span>


<span class="nc" id="L96">    @Getter</span>
    private final Map&lt;String, Object&gt; serverConfig;

<span class="nc" id="L99">    @Getter</span>
    private final DataStore dataStore;

<span class="nc" id="L102">    @Getter</span>
<span class="nc" id="L103">    @Setter</span>
    private IServerRouter serverRouter;

<span class="nc" id="L106">    @Getter</span>
<span class="nc" id="L107">    @Setter</span>
    private IReconfigurationHandlerPolicy failureHandlerPolicy;

<span class="nc" id="L110">    @Getter</span>
    private final EventLoopGroup clientGroup;

<span class="nc" id="L113">    @Getter</span>
    private final EventLoopGroup bossGroup;

<span class="nc" id="L116">    @Getter</span>
    private final EventLoopGroup workerGroup;

<span class="nc" id="L119">    @Getter (AccessLevel.PACKAGE)</span>
    private final NodeLocator nodeLocator;

<span class="nc" id="L122">    @Getter (AccessLevel.PACKAGE)</span>
    private final String localEndpoint;

<span class="nc" id="L125">    @Getter</span>
<span class="nc" id="L126">    private static final MetricRegistry metrics = new MetricRegistry();</span>

<span class="nc" id="L128">    @Getter</span>
    private final Set&lt;String&gt; dsFilePrefixesForCleanup =
<span class="nc" id="L130">            Sets.newHashSet(PaxosDataStore.PREFIX_PHASE_1, PaxosDataStore.PREFIX_PHASE_2, PREFIX_LAYOUTS);</span>

    /**
     * Returns a new ServerContext.
     *
     * @param serverConfig map of configuration strings to objects
     */
<span class="nc" id="L137">    public ServerContext(Map&lt;String, Object&gt; serverConfig) {</span>
<span class="nc" id="L138">        this.serverConfig = serverConfig;</span>
<span class="nc" id="L139">        this.dataStore = new DataStore(serverConfig, this::dataStoreFileCleanup);</span>
<span class="nc" id="L140">        generateNodeId();</span>
<span class="nc" id="L141">        this.failureHandlerPolicy = new ConservativeFailureHandlerPolicy();</span>

        // Setup the netty event loops. In tests, these loops may be provided by
        // a test framework to save resources.
<span class="nc" id="L145">        final boolean providedEventLoops =</span>
<span class="nc" id="L146">                 getChannelImplementation().equals(ChannelImplementation.LOCAL);</span>

<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (providedEventLoops) {</span>
<span class="nc" id="L149">            clientGroup = getServerConfig(EventLoopGroup.class, &quot;client&quot;);</span>
<span class="nc" id="L150">            workerGroup = getServerConfig(EventLoopGroup.class, &quot;worker&quot;);</span>
<span class="nc" id="L151">            bossGroup = getServerConfig(EventLoopGroup.class, &quot;boss&quot;);</span>
        } else {
<span class="nc" id="L153">            clientGroup = getNewClientGroup();</span>
<span class="nc" id="L154">            workerGroup = getNewWorkerGroup();</span>
<span class="nc" id="L155">            bossGroup = getNewBossGroup();</span>
        }

<span class="nc" id="L158">        nodeLocator = NodeLocator</span>
<span class="nc" id="L159">                .parseString(serverConfig.get(&quot;--address&quot;) + &quot;:&quot; + serverConfig.get(&quot;&lt;port&gt;&quot;));</span>
<span class="nc" id="L160">        localEndpoint = nodeLocator.toEndpointUrl();</span>

        // Metrics setup &amp; reporting configuration
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (!isMetricsReportingSetUp(metrics)) {</span>
<span class="nc" id="L164">            MetricsUtils.metricsReportingSetup(metrics);</span>
        }
<span class="nc" id="L166">    }</span>

    int getBaseServerThreadCount() {
<span class="nc" id="L169">        Integer threadCount = getServerConfig(Integer.class, &quot;--base-server-threads&quot;);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        return threadCount == null ? 1 : threadCount;</span>
    }

    int getLayoutServerThreadCount() {
<span class="nc" id="L174">        Integer threadCount = getServerConfig(Integer.class, &quot;--layout-server-threads&quot;);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        return threadCount == null ? 1 : threadCount;</span>
    }

    int getLogunitThreadCount() {
<span class="nc" id="L179">        Integer threadCount = getServerConfig(Integer.class, &quot;--logunit-threads&quot;);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        return threadCount == null ? Runtime.getRuntime().availableProcessors() * 2 : threadCount;</span>
    }

    int getManagementServerThreadCount() {
<span class="nc" id="L184">        Integer threadCount = getServerConfig(Integer.class, &quot;--management-server-threads&quot;);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        return threadCount == null ? 4 : threadCount;</span>
    }

    /**
     * Cleanup the DataStore files with names that are prefixes of the specified
     * fileName when so that the number of these files don't exceed the user-defined
     * retention limit. Cleanup is always done on files with lower epochs.
     */
    private void dataStoreFileCleanup(String fileName) {
<span class="nc" id="L194">        String logDirPath = getServerConfig(String.class, &quot;--log-path&quot;);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (logDirPath == null) {</span>
<span class="nc" id="L196">            return;</span>
        }

<span class="nc" id="L199">        File logDir = new File(logDirPath);</span>
<span class="nc" id="L200">        Set&lt;String&gt; prefixesToClean = getDsFilePrefixesForCleanup();</span>
<span class="nc" id="L201">        int numRetention = Integer.parseInt(getServerConfig(String.class, &quot;--metadata-retention&quot;));</span>

<span class="nc" id="L203">        prefixesToClean.stream()</span>
<span class="nc" id="L204">                .filter(fileName::startsWith)</span>
<span class="nc" id="L205">                .forEach(prefix -&gt; {</span>
<span class="nc" id="L206">                    File[] foundFiles = logDir.listFiles((dir, name) -&gt; name.startsWith(prefix));</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">                    if (foundFiles == null || foundFiles.length &lt;= numRetention) {</span>
<span class="nc" id="L208">                        log.debug(&quot;DataStore cleanup not started for prefix: {}.&quot;, prefix);</span>
<span class="nc" id="L209">                        return;</span>
                    }
<span class="nc" id="L211">                    log.debug(&quot;Start cleaning up DataStore files with prefix: {}.&quot;, prefix);</span>
<span class="nc" id="L212">                    Arrays.stream(foundFiles)</span>
<span class="nc" id="L213">                            .sorted(Comparator.comparingInt(file -&gt; {</span>
                                // Extract epoch number from file name and cast to int for comparision
<span class="nc" id="L215">                                Matcher matcher = Pattern.compile(&quot;\\d+&quot;).matcher(file.getName());</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                                return matcher.find(prefix.length()) ? Integer.parseInt(matcher.group()) : 0;</span>
                            }))
<span class="nc" id="L218">                            .limit(foundFiles.length - numRetention)</span>
<span class="nc" id="L219">                            .forEach(file -&gt; {</span>
                                try {
<span class="nc bnc" id="L221" title="All 2 branches missed.">                                    if (Files.deleteIfExists(file.toPath())) {</span>
<span class="nc" id="L222">                                        log.info(&quot;Removed DataStore file: {}&quot;, file.getName());</span>
                                    }
<span class="nc" id="L224">                                } catch (Exception e) {</span>
<span class="nc" id="L225">                                    log.error(&quot;Error when cleaning up DataStore files&quot;, e);</span>
<span class="nc" id="L226">                                }</span>
<span class="nc" id="L227">                            });</span>
<span class="nc" id="L228">                });</span>
<span class="nc" id="L229">    }</span>

    /**
     * Get the {@link ChannelImplementation} to use.
     *
     * @return The server channel type.
     */
    ChannelImplementation getChannelImplementation() {
<span class="nc" id="L237">        final String type = getServerConfig(String.class, &quot;--implementation&quot;);</span>
<span class="nc" id="L238">        return ChannelImplementation.valueOf(type.toUpperCase());</span>
    }

    /**
     * Get an instance of {@link CorfuRuntimeParameters} representing the default Corfu Runtime's
     * parameters.
     *
     * @return an instance of {@link CorfuRuntimeParameters}
     */
    public CorfuRuntimeParameters getManagementRuntimeParameters() {
<span class="nc" id="L248">        return CorfuRuntime.CorfuRuntimeParameters.builder()</span>
<span class="nc" id="L249">                .priorityLevel(PriorityLevel.HIGH)</span>
<span class="nc" id="L250">                .nettyEventLoop(clientGroup)</span>
<span class="nc" id="L251">                .shutdownNettyEventLoop(false)</span>
<span class="nc" id="L252">                .tlsEnabled((Boolean) serverConfig.get(&quot;--enable-tls&quot;))</span>
<span class="nc" id="L253">                .keyStore((String) serverConfig.get(&quot;--keystore&quot;))</span>
<span class="nc" id="L254">                .ksPasswordFile((String) serverConfig.get(&quot;--keystore-password-file&quot;))</span>
<span class="nc" id="L255">                .trustStore((String) serverConfig.get(&quot;--truststore&quot;))</span>
<span class="nc" id="L256">                .tsPasswordFile((String) serverConfig.get(&quot;--truststore-password-file&quot;))</span>
<span class="nc" id="L257">                .saslPlainTextEnabled((Boolean) serverConfig.get(&quot;--enable-sasl-plain-text-auth&quot;))</span>
<span class="nc" id="L258">                .usernameFile((String) serverConfig.get(&quot;--sasl-plain-text-username-file&quot;))</span>
<span class="nc" id="L259">                .passwordFile((String) serverConfig.get(&quot;--sasl-plain-text-password-file&quot;))</span>
<span class="nc" id="L260">                .bulkReadSize(Integer.parseInt((String) serverConfig.get(&quot;--batch-size&quot;)))</span>
<span class="nc" id="L261">                .build();</span>
    }

    /**
     * Generate a Node Id if not present.
     */
    private void generateNodeId() {
<span class="nc" id="L268">        String currentId = getDataStore().get(String.class, &quot;&quot;, ServerContext.NODE_ID);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (currentId == null) {</span>
<span class="nc" id="L270">            String idString = UuidUtils.asBase64(UUID.randomUUID());</span>
<span class="nc" id="L271">            log.info(&quot;No Node Id, setting to new Id={}&quot;, idString);</span>
<span class="nc" id="L272">            getDataStore().put(String.class, &quot;&quot;, ServerContext.NODE_ID, idString);</span>
<span class="nc" id="L273">        } else {</span>
<span class="nc" id="L274">            log.info(&quot;Node Id = {}&quot;, currentId);</span>
        }
<span class="nc" id="L276">    }</span>

    /**
     * Get the node id as an UUID.
     *
     * @return  A UUID for this node.
     */
    public UUID getNodeId() {
<span class="nc" id="L284">        return UuidUtils.fromBase64(getNodeIdBase64());</span>
    }

    /** Get the node id as a base64 string.
     *
     * @return A node ID for this node, as a base64 string.
     */
    public String getNodeIdBase64() {
<span class="nc" id="L292">        return getDataStore().get(String.class, &quot;&quot;, ServerContext.NODE_ID);</span>
    }

    /**
     * Get a field from the server configuration map.
     *
     * @param type          The type of the field.
     * @param optionName    The name of the option to retrieve.
     * @param &lt;T&gt;           The type of the field to return.
     * @return              The field with the give option name.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getServerConfig(Class&lt;T&gt; type, String optionName) {
<span class="nc" id="L305">        return (T) getServerConfig().get(optionName);</span>
    }


    /**
     * Install a single node layout if and only if no layout is currently installed.
     * Synchronized, so this method is thread-safe.
     *
     *  @return True, if a new layout was installed, false otherwise.
     */
    public synchronized boolean installSingleNodeLayoutIfAbsent() {
<span class="nc bnc" id="L316" title="All 4 branches missed.">        if ((Boolean) getServerConfig().get(&quot;--single&quot;) &amp;&amp; getCurrentLayout() == null) {</span>
<span class="nc" id="L317">            setCurrentLayout(getNewSingleNodeLayout());</span>
<span class="nc" id="L318">            return true;</span>
        }
<span class="nc" id="L320">        return false;</span>
    }

    /**
     * Get a new single node layout used for self-bootstrapping a server started with
     * the -s flag.
     *
     *  @returns A new single node layout with a unique cluster Id
     *  @throws IllegalArgumentException    If the cluster id was not auto, base64 or a UUID string
     */
    public Layout getNewSingleNodeLayout() {
<span class="nc" id="L331">        final String clusterIdString = (String) getServerConfig().get(&quot;--cluster-id&quot;);</span>
        UUID clusterId;
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (clusterIdString.equals(&quot;auto&quot;)) {</span>
<span class="nc" id="L334">            clusterId = UUID.randomUUID();</span>
        } else {
            // Is it a UUID?
            try {
<span class="nc" id="L338">                clusterId = UUID.fromString(clusterIdString);</span>
<span class="nc" id="L339">            } catch (IllegalArgumentException ignore) {</span>
                // Must be a base64 id, otherwise we will throw InvalidArgumentException again
<span class="nc" id="L341">                clusterId = UuidUtils.fromBase64(clusterIdString);</span>
<span class="nc" id="L342">            }</span>
        }
<span class="nc" id="L344">        log.info(&quot;getNewSingleNodeLayout: Bootstrapping with cluster Id {} [{}]&quot;,</span>
<span class="nc" id="L345">            clusterId, UuidUtils.asBase64(clusterId));</span>
<span class="nc" id="L346">        String localAddress = getServerConfig().get(&quot;--address&quot;) + &quot;:&quot;</span>
<span class="nc" id="L347">            + getServerConfig().get(&quot;&lt;port&gt;&quot;);</span>
<span class="nc" id="L348">        return new Layout(</span>
<span class="nc" id="L349">            Collections.singletonList(localAddress),</span>
<span class="nc" id="L350">            Collections.singletonList(localAddress),</span>
<span class="nc" id="L351">            Collections.singletonList(new LayoutSegment(</span>
                Layout.ReplicationMode.CHAIN_REPLICATION,
                0L,
                -1L,
<span class="nc" id="L355">                Collections.singletonList(</span>
                    new Layout.LayoutStripe(
<span class="nc" id="L357">                        Collections.singletonList(localAddress)</span>
                    )
                )
            )),
            0L,
            clusterId
        );
    }

    /**
     * Get the current {@link Layout} stored in the {@link DataStore}.
     *
     * @return The current stored {@link Layout}
     */
    public Layout getCurrentLayout() {
<span class="nc" id="L372">        return getDataStore().get(Layout.class, PREFIX_LAYOUT, KEY_LAYOUT);</span>
    }

    /**
     * Set the current {@link Layout} stored in the {@link DataStore}.
     *
     * @param layout The {@link Layout} to set in the {@link DataStore}.
     */
    public void setCurrentLayout(Layout layout) {
<span class="nc" id="L381">        getDataStore().put(Layout.class, PREFIX_LAYOUT, KEY_LAYOUT, layout);</span>
<span class="nc" id="L382">    }</span>

    /**
     * Get the list of servers registered in serverRouter
     *
     * @return A list of servers registered in serverRouter
     */
    public List&lt;AbstractServer&gt; getServers() {
<span class="nc" id="L390">        return serverRouter.getServers();</span>
    }

    /**
     * The epoch of this router. This is managed by the base server implementation.
     */
    public synchronized long getServerEpoch() {
<span class="nc" id="L397">        Long epoch = dataStore.get(Long.class, PREFIX_EPOCH, KEY_EPOCH);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        return epoch == null ? 0 : epoch;</span>
    }

    /**
     * Set the serverRouter epoch.
     *
     * @param serverEpoch the epoch to set
     */
    public synchronized void setServerEpoch(long serverEpoch, IServerRouter r) {
<span class="nc" id="L407">        Long lastEpoch = dataStore.get(Long.class, PREFIX_EPOCH, KEY_EPOCH);</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">        if (lastEpoch == null || lastEpoch &lt; serverEpoch) {</span>
<span class="nc" id="L409">            dataStore.put(Long.class, PREFIX_EPOCH, KEY_EPOCH, serverEpoch);</span>
<span class="nc" id="L410">            r.setServerEpoch(serverEpoch);</span>
<span class="nc" id="L411">            getServers().forEach(s -&gt; s.sealServerWithEpoch(serverEpoch));</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        } else if (serverEpoch == lastEpoch) {</span>
            // Setting to the same epoch, don't need to do anything.
        } else {
            // Regressing, throw an exception.
<span class="nc" id="L416">            throw new WrongEpochException(lastEpoch);</span>
        }
<span class="nc" id="L418">    }</span>

    public void setLayoutInHistory(Layout layout) {
<span class="nc" id="L421">        dataStore.put(Layout.class, PREFIX_LAYOUTS, String.valueOf(layout.getEpoch()), layout);</span>
<span class="nc" id="L422">    }</span>

    /**
     * Persists the sequencer epoch. This is set only by the SequencerServer in the resetServer.
     * No lock required as it relies on the resetServer lock.
     *
     * @param sequencerEpoch Epoch to persist.
     */
    public void setSequencerEpoch(long sequencerEpoch) {
<span class="nc" id="L431">        dataStore.put(Long.class, KEY_SEQUENCER, PREFIX_SEQUENCER_EPOCH, sequencerEpoch);</span>
<span class="nc" id="L432">    }</span>

    /**
     * Fetch the persisted sequencer epoch.
     *
     * @return Sequencer epoch.
     */
    public long getSequencerEpoch() {
<span class="nc" id="L440">        Long epoch = dataStore.get(Long.class, KEY_SEQUENCER, PREFIX_SEQUENCER_EPOCH);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        return epoch == null ? Layout.INVALID_EPOCH : epoch;</span>
    }

    /**
     * Sets the management layout in the persistent datastore.
     *
     * @param newLayout Layout to be persisted
     */
    public synchronized Layout saveManagementLayout(Layout newLayout) {
<span class="nc" id="L450">        Layout currentLayout = copyManagementLayout();</span>

        // Cannot update with a null layout.
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (newLayout == null) {</span>
<span class="nc" id="L454">            log.warn(&quot;Attempted to update with null. Current layout: {}&quot;, currentLayout);</span>
<span class="nc" id="L455">            return currentLayout;</span>
        }

        // Update only if new layout has a higher epoch than the existing layout.
<span class="nc bnc" id="L459" title="All 4 branches missed.">        if (currentLayout == null || newLayout.getEpoch() &gt; currentLayout.getEpoch()) {</span>
<span class="nc" id="L460">            dataStore.put(Layout.class, PREFIX_MANAGEMENT, MANAGEMENT_LAYOUT, newLayout);</span>
<span class="nc" id="L461">            currentLayout = copyManagementLayout();</span>
<span class="nc" id="L462">            log.info(&quot;Update to new layout at epoch {}&quot;, currentLayout.getEpoch());</span>
<span class="nc" id="L463">            return currentLayout;</span>
        }

<span class="nc" id="L466">        return currentLayout;</span>

    }

    /**
     * Save detected failure in a history. History represents all cluster state changes.
     * Disabled by default.
     *
     * @param detector failure detector state
     */
    public synchronized void saveFailureDetectorMetrics(FailureDetectorMetrics detector) {
<span class="nc" id="L477">        boolean enabled = Boolean.parseBoolean(System.getProperty(&quot;corfu.failuredetector&quot;, Boolean.FALSE.toString()));</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (!enabled){</span>
<span class="nc" id="L479">            return;</span>
        }

<span class="nc" id="L482">        dataStore.put(</span>
                FailureDetectorMetrics.class,
                PREFIX_FAILURE_DETECTOR,
<span class="nc" id="L485">                String.valueOf(getManagementLayout().getEpoch()),</span>
                detector
        );
<span class="nc" id="L488">    }</span>

    /**
     * Get latest change in a cluster state saved in data store. Or provide default value if history is disabled.
     *
     * @return latest failure saved in the history
     */
    public FailureDetectorMetrics getFailureDetectorMetrics() {
<span class="nc" id="L496">        boolean enabled = Boolean.parseBoolean(System.getProperty(&quot;corfu.failuredetector&quot;, Boolean.FALSE.toString()));</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if(!enabled){</span>
<span class="nc" id="L498">            return getDefaultFailureDetectorMetric(getManagementLayout());</span>
        }

<span class="nc" id="L501">        FailureDetectorMetrics failureMetrics = dataStore.get(</span>
<span class="nc" id="L502">                FailureDetectorMetrics.class, PREFIX_FAILURE_DETECTOR, String.valueOf(getManagementLayout().getEpoch())</span>
        );

<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (failureMetrics == null){</span>
<span class="nc" id="L506">            Layout layout = getManagementLayout();</span>

<span class="nc" id="L508">            return getDefaultFailureDetectorMetric(layout);</span>
        }

<span class="nc" id="L511">        return failureMetrics;</span>
    }

    /**
     * Provide default metric.
     * @param layout current layout
     * @return default value
     */
    private FailureDetectorMetrics getDefaultFailureDetectorMetric(Layout layout) {
<span class="nc" id="L520">        return FailureDetectorMetrics.builder()</span>
<span class="nc" id="L521">                .localNode(getLocalEndpoint())</span>
<span class="nc" id="L522">                .layout(layout.getLayoutServers())</span>
<span class="nc" id="L523">                .unresponsiveNodes(layout.getUnresponsiveServers())</span>
<span class="nc" id="L524">                .epoch(layout.getEpoch())</span>
<span class="nc" id="L525">                .build();</span>
    }

    /**
     * Fetches the management layout from the persistent datastore.
     *
     * @return The last persisted layout
     */
    public Layout getManagementLayout() {
<span class="nc" id="L534">        return dataStore.get(Layout.class, PREFIX_MANAGEMENT, MANAGEMENT_LAYOUT);</span>
    }

    /**
     * Sets the log unit epoch water mark.
     *
     * @param resetEpoch Epoch at which the reset command was received.
     */
    public synchronized void setLogUnitEpochWaterMark(long resetEpoch) {
<span class="nc" id="L543">        dataStore.put(Long.class, PREFIX_LOGUNIT, EPOCH_WATER_MARK, resetEpoch);</span>
<span class="nc" id="L544">    }</span>

    /**
     * Fetches the epoch at which the last epochWaterMark operation was received.
     *
     * @return Reset epoch.
     */
    public synchronized long getLogUnitEpochWaterMark() {
<span class="nc" id="L552">        Long resetEpoch = dataStore.get(Long.class, PREFIX_LOGUNIT, EPOCH_WATER_MARK);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        return resetEpoch == null ? Layout.INVALID_EPOCH : resetEpoch;</span>
    }

    /**
     * Fetches and creates a copy of the Management Layout from the local datastore.
     *
     * @return Copy of the management layout from the datastore.
     */
    public Layout copyManagementLayout() {
<span class="nc" id="L562">        Layout l = getManagementLayout();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L564">            return new Layout(l);</span>
        } else {
<span class="nc" id="L566">            return null;</span>
        }
    }

    /**
     * Get a new &quot;boss&quot; group, which services (accepts) incoming connections.
     *
     * @return A boss group.
     */
    private EventLoopGroup getNewBossGroup() {
<span class="nc" id="L576">        final ThreadFactory threadFactory = new ThreadFactoryBuilder()</span>
<span class="nc" id="L577">                .setNameFormat(getThreadPrefix() + &quot;accept-%d&quot;)</span>
<span class="nc" id="L578">                .build();</span>
<span class="nc" id="L579">        EventLoopGroup group = getChannelImplementation().getGenerator()</span>
<span class="nc" id="L580">                .generate(1, threadFactory);</span>
<span class="nc" id="L581">        log.info(&quot;getBossGroup: Type {}&quot;, group.getClass().getSimpleName());</span>
<span class="nc" id="L582">        return group;</span>
    }

    /**
     * Get a new &quot;worker&quot; group, which services incoming requests.
     *
     * @return A worker group.
     */
    private @Nonnull EventLoopGroup getNewWorkerGroup() {
<span class="nc" id="L591">        final ThreadFactory threadFactory = new ThreadFactoryBuilder()</span>
<span class="nc" id="L592">                .setNameFormat(getThreadPrefix() + &quot;worker-%d&quot;)</span>
<span class="nc" id="L593">                .build();</span>

<span class="nc" id="L595">        final int requestedThreads =</span>
<span class="nc" id="L596">                Integer.parseInt(getServerConfig(String.class, &quot;--Threads&quot;));</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        final int numThreads = requestedThreads == 0</span>
<span class="nc" id="L598">                ? Runtime.getRuntime().availableProcessors() * 2</span>
                : requestedThreads;
<span class="nc" id="L600">        EventLoopGroup group = getChannelImplementation().getGenerator()</span>
<span class="nc" id="L601">            .generate(numThreads, threadFactory);</span>

<span class="nc" id="L603">        log.info(&quot;getWorkerGroup: Type {} with {} threads&quot;,</span>
<span class="nc" id="L604">                group.getClass().getSimpleName(), numThreads);</span>
<span class="nc" id="L605">        return group;</span>
    }

    /**
     * Get a new &quot;client&quot; group, which services incoming client requests.
     *
     * @return A worker group.
     */
    private @Nonnull EventLoopGroup getNewClientGroup() {
<span class="nc" id="L614">        final ThreadFactory threadFactory = new ThreadFactoryBuilder()</span>
<span class="nc" id="L615">                .setNameFormat(getThreadPrefix() + &quot;client-%d&quot;)</span>
<span class="nc" id="L616">                .build();</span>

<span class="nc" id="L618">        final int requestedThreads =</span>
<span class="nc" id="L619">            Integer.parseInt(getServerConfig(String.class, &quot;--Threads&quot;));</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">        final int numThreads = requestedThreads == 0</span>
<span class="nc" id="L621">            ? Runtime.getRuntime().availableProcessors() * 2</span>
            : requestedThreads;
<span class="nc" id="L623">        EventLoopGroup group = getChannelImplementation().getGenerator()</span>
<span class="nc" id="L624">            .generate(numThreads, threadFactory);</span>

<span class="nc" id="L626">        log.info(&quot;getClientGroup: Type {} with {} threads&quot;,</span>
<span class="nc" id="L627">            group.getClass().getSimpleName(), numThreads);</span>
<span class="nc" id="L628">        return group;</span>
    }

    /**
     * Get the prefix for threads this server creates.
     *
     * @return A string that should be prepended to threads this server creates.
     */
    public @Nonnull String getThreadPrefix() {
<span class="nc" id="L637">        final String prefix = getServerConfig(String.class, &quot;--Prefix&quot;);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (prefix.equals(&quot;&quot;)) {</span>
<span class="nc" id="L639">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L641">            return prefix + &quot;-&quot;;</span>
        }
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Cleans up and releases all resources (such as thread pools and files) opened
     * by this {@link ServerContext}.
     */
    @Override
    public void close() {
<span class="nc" id="L653">        CorfuRuntimeParameters params = getManagementRuntimeParameters();</span>
        // Shutdown the active event loops unless they were provided to us
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (!getChannelImplementation().equals(ChannelImplementation.LOCAL)) {</span>
<span class="nc" id="L656">            clientGroup.shutdownGracefully(</span>
<span class="nc" id="L657">                    params.getNettyShutdownQuitePeriod(),</span>
<span class="nc" id="L658">                    params.getNettyShutdownTimeout(),</span>
                    TimeUnit.MILLISECONDS
            );
<span class="nc" id="L661">            bossGroup.shutdownGracefully(</span>
<span class="nc" id="L662">                    params.getNettyShutdownQuitePeriod(),</span>
<span class="nc" id="L663">                    params.getNettyShutdownTimeout(),</span>
                    TimeUnit.MILLISECONDS
            );
<span class="nc" id="L666">            workerGroup.shutdownGracefully(</span>
<span class="nc" id="L667">                    params.getNettyShutdownQuitePeriod(),</span>
<span class="nc" id="L668">                    params.getNettyShutdownTimeout(),</span>
                    TimeUnit.MILLISECONDS
            );
        }
<span class="nc" id="L672">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>