<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ServerContext.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cmdlets</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">ServerContext.java</span></div><h1>ServerContext.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import static org.corfudb.util.MetricsUtils.isMetricsReportingSetUp;

import com.codahale.metrics.MetricRegistry;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import io.netty.channel.EventLoopGroup;

import java.io.File;
import java.nio.file.Files;
import java.time.Duration;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.comm.ChannelImplementation;
import org.corfudb.infrastructure.datastore.DataStore;
import org.corfudb.infrastructure.datastore.KvDataStore.KvRecord;
import org.corfudb.infrastructure.paxos.PaxosDataStore;
import org.corfudb.protocols.wireprotocol.PriorityLevel;
import org.corfudb.protocols.wireprotocol.failuredetector.FailureDetectorMetrics;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.CorfuRuntime.CorfuRuntimeParameters;
import org.corfudb.runtime.exceptions.WrongEpochException;
import org.corfudb.runtime.view.ConservativeFailureHandlerPolicy;
import org.corfudb.runtime.view.IReconfigurationHandlerPolicy;
import org.corfudb.runtime.view.Layout;
import org.corfudb.runtime.view.Layout.LayoutSegment;
import org.corfudb.util.MetricsUtils;
import org.corfudb.util.NodeLocator;
import org.corfudb.util.UuidUtils;

/**
 * Server Context:
 * &lt;ul&gt;
 * &lt;li&gt;Contains the common node level {@link DataStore}&lt;/li&gt;
 * &lt;li&gt;Responsible for Server level EPOCH &lt;/li&gt;
 * &lt;li&gt;Should contain common services/utilities that the different Servers in a node require.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note:
 * It is created in {@link CorfuServer} and then
 * passed to all the servers including {@link NettyServerRouter}.
 *
 * &lt;p&gt;Created by mdhawan on 8/5/16.
 */
<span class="nc" id="L65">@Slf4j</span>
public class ServerContext implements AutoCloseable {

    // Layout Server
    private static final String PREFIX_EPOCH = &quot;SERVER_EPOCH&quot;;
    private static final String KEY_EPOCH = &quot;CURRENT&quot;;
    private static final String PREFIX_LAYOUT = &quot;LAYOUT&quot;;
    private static final String KEY_LAYOUT = &quot;CURRENT&quot;;
    private static final String PREFIX_LAYOUTS = &quot;LAYOUTS&quot;;

    // Sequencer Server
    private static final String KEY_SEQUENCER = &quot;SEQUENCER&quot;;
    private static final String PREFIX_SEQUENCER_EPOCH = &quot;EPOCH&quot;;

    // Management Server
    private static final String PREFIX_MANAGEMENT = &quot;MANAGEMENT&quot;;
    private static final String MANAGEMENT_LAYOUT = &quot;LAYOUT&quot;;

    // Failure detector
    private static final String PREFIX_FAILURE_DETECTOR = &quot;FAILURE_DETECTOR&quot;;

    // LogUnit Server
    private static final String PREFIX_LOGUNIT = &quot;LOGUNIT&quot;;
    private static final String EPOCH_WATER_MARK = &quot;EPOCH_WATER_MARK&quot;;

    /** The node Id, stored as a base64 string. */
    private static final String NODE_ID = &quot;NODE_ID&quot;;

<span class="nc" id="L93">    private static final KvRecord&lt;String&gt; NODE_ID_RECORD = KvRecord.of(NODE_ID, String.class);</span>

<span class="nc" id="L95">    private static final KvRecord&lt;Layout&gt; CURR_LAYOUT_RECORD = KvRecord.of(</span>
            PREFIX_LAYOUT, KEY_LAYOUT, Layout.class
    );

<span class="nc" id="L99">    private static final KvRecord&lt;Long&gt; SERVER_EPOCH_RECORD= KvRecord.of(</span>
            PREFIX_EPOCH, KEY_EPOCH, Long.class
    );

<span class="nc" id="L103">    private static final KvRecord&lt;Long&gt; SEQUENCER_RECORD = KvRecord.of(</span>
            KEY_SEQUENCER, PREFIX_SEQUENCER_EPOCH, Long.class
    );

<span class="nc" id="L107">    private static final KvRecord&lt;Layout&gt; MANAGEMENT_LAYOUT_RECORD = KvRecord.of(</span>
            PREFIX_MANAGEMENT, MANAGEMENT_LAYOUT, Layout.class
    );

<span class="nc" id="L111">    private static final KvRecord&lt;Long&gt; LOG_UNIT_WATERMARK_RECORD = KvRecord.of(</span>
            PREFIX_LOGUNIT, EPOCH_WATER_MARK, Long.class
    );


    /**
     * various duration constants.
     */
<span class="nc" id="L119">    public static final Duration SHUTDOWN_TIMER = Duration.ofSeconds(5);</span>


<span class="nc" id="L122">    @Getter</span>
    private final Map&lt;String, Object&gt; serverConfig;

<span class="nc" id="L125">    @Getter</span>
    private final DataStore dataStore;

<span class="nc" id="L128">    @Getter</span>
<span class="nc" id="L129">    @Setter</span>
    private IServerRouter serverRouter;

<span class="nc" id="L132">    @Getter</span>
<span class="nc" id="L133">    @Setter</span>
    private IReconfigurationHandlerPolicy failureHandlerPolicy;

<span class="nc" id="L136">    @Getter</span>
    private final EventLoopGroup clientGroup;

<span class="nc" id="L139">    @Getter</span>
    private final EventLoopGroup bossGroup;

<span class="nc" id="L142">    @Getter</span>
    private final EventLoopGroup workerGroup;

<span class="nc" id="L145">    @Getter (AccessLevel.PACKAGE)</span>
    private final NodeLocator nodeLocator;

<span class="nc" id="L148">    @Getter (AccessLevel.PACKAGE)</span>
    private final String localEndpoint;

<span class="nc" id="L151">    @Getter</span>
<span class="nc" id="L152">    private static final MetricRegistry metrics = new MetricRegistry();</span>

<span class="nc" id="L154">    @Getter</span>
    private final Set&lt;String&gt; dsFilePrefixesForCleanup =
<span class="nc" id="L156">            Sets.newHashSet(PaxosDataStore.PREFIX_PHASE_1, PaxosDataStore.PREFIX_PHASE_2, PREFIX_LAYOUTS);</span>

    /**
     * Returns a new ServerContext.
     *
     * @param serverConfig map of configuration strings to objects
     */
<span class="nc" id="L163">    public ServerContext(Map&lt;String, Object&gt; serverConfig) {</span>
<span class="nc" id="L164">        this.serverConfig = serverConfig;</span>
<span class="nc" id="L165">        this.dataStore = new DataStore(serverConfig, this::dataStoreFileCleanup);</span>
<span class="nc" id="L166">        generateNodeId();</span>
<span class="nc" id="L167">        this.failureHandlerPolicy = new ConservativeFailureHandlerPolicy();</span>

        // Setup the netty event loops. In tests, these loops may be provided by
        // a test framework to save resources.
<span class="nc" id="L171">        final boolean providedEventLoops =</span>
<span class="nc" id="L172">                 getChannelImplementation().equals(ChannelImplementation.LOCAL);</span>

<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (providedEventLoops) {</span>
<span class="nc" id="L175">            clientGroup = getServerConfig(EventLoopGroup.class, &quot;client&quot;);</span>
<span class="nc" id="L176">            workerGroup = getServerConfig(EventLoopGroup.class, &quot;worker&quot;);</span>
<span class="nc" id="L177">            bossGroup = getServerConfig(EventLoopGroup.class, &quot;boss&quot;);</span>
        } else {
<span class="nc" id="L179">            clientGroup = getNewClientGroup();</span>
<span class="nc" id="L180">            workerGroup = getNewWorkerGroup();</span>
<span class="nc" id="L181">            bossGroup = getNewBossGroup();</span>
        }

<span class="nc" id="L184">        nodeLocator = NodeLocator</span>
<span class="nc" id="L185">                .parseString(serverConfig.get(&quot;--address&quot;) + &quot;:&quot; + serverConfig.get(&quot;&lt;port&gt;&quot;));</span>
<span class="nc" id="L186">        localEndpoint = nodeLocator.toEndpointUrl();</span>

        // Metrics setup &amp; reporting configuration
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (!isMetricsReportingSetUp(metrics)) {</span>
<span class="nc" id="L190">            MetricsUtils.metricsReportingSetup(metrics);</span>
        }
<span class="nc" id="L192">    }</span>

    int getBaseServerThreadCount() {
<span class="nc" id="L195">        Integer threadCount = getServerConfig(Integer.class, &quot;--base-server-threads&quot;);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        return threadCount == null ? 1 : threadCount;</span>
    }

    int getLayoutServerThreadCount() {
<span class="nc" id="L200">        Integer threadCount = getServerConfig(Integer.class, &quot;--layout-server-threads&quot;);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        return threadCount == null ? 1 : threadCount;</span>
    }

    int getLogunitThreadCount() {
<span class="nc" id="L205">        Integer threadCount = getServerConfig(Integer.class, &quot;--logunit-threads&quot;);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        return threadCount == null ? Runtime.getRuntime().availableProcessors() * 2 : threadCount;</span>
    }

    int getManagementServerThreadCount() {
<span class="nc" id="L210">        Integer threadCount = getServerConfig(Integer.class, &quot;--management-server-threads&quot;);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        return threadCount == null ? 4 : threadCount;</span>
    }

    /**
     * Cleanup the DataStore files with names that are prefixes of the specified
     * fileName when so that the number of these files don't exceed the user-defined
     * retention limit. Cleanup is always done on files with lower epochs.
     */
    private void dataStoreFileCleanup(String fileName) {
<span class="nc" id="L220">        String logDirPath = getServerConfig(String.class, &quot;--log-path&quot;);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (logDirPath == null) {</span>
<span class="nc" id="L222">            return;</span>
        }

<span class="nc" id="L225">        File logDir = new File(logDirPath);</span>
<span class="nc" id="L226">        Set&lt;String&gt; prefixesToClean = getDsFilePrefixesForCleanup();</span>
<span class="nc" id="L227">        int numRetention = Integer.parseInt(getServerConfig(String.class, &quot;--metadata-retention&quot;));</span>

<span class="nc" id="L229">        prefixesToClean.stream()</span>
<span class="nc" id="L230">                .filter(fileName::startsWith)</span>
<span class="nc" id="L231">                .forEach(prefix -&gt; {</span>
<span class="nc" id="L232">                    File[] foundFiles = logDir.listFiles((dir, name) -&gt; name.startsWith(prefix));</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">                    if (foundFiles == null || foundFiles.length &lt;= numRetention) {</span>
<span class="nc" id="L234">                        log.debug(&quot;DataStore cleanup not started for prefix: {}.&quot;, prefix);</span>
<span class="nc" id="L235">                        return;</span>
                    }
<span class="nc" id="L237">                    log.debug(&quot;Start cleaning up DataStore files with prefix: {}.&quot;, prefix);</span>
<span class="nc" id="L238">                    Arrays.stream(foundFiles)</span>
<span class="nc" id="L239">                            .sorted(Comparator.comparingInt(file -&gt; {</span>
                                // Extract epoch number from file name and cast to int for comparision
<span class="nc" id="L241">                                Matcher matcher = Pattern.compile(&quot;\\d+&quot;).matcher(file.getName());</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                                return matcher.find(prefix.length()) ? Integer.parseInt(matcher.group()) : 0;</span>
                            }))
<span class="nc" id="L244">                            .limit(foundFiles.length - numRetention)</span>
<span class="nc" id="L245">                            .forEach(file -&gt; {</span>
                                try {
<span class="nc bnc" id="L247" title="All 2 branches missed.">                                    if (Files.deleteIfExists(file.toPath())) {</span>
<span class="nc" id="L248">                                        log.info(&quot;Removed DataStore file: {}&quot;, file.getName());</span>
                                    }
<span class="nc" id="L250">                                } catch (Exception e) {</span>
<span class="nc" id="L251">                                    log.error(&quot;Error when cleaning up DataStore files&quot;, e);</span>
<span class="nc" id="L252">                                }</span>
<span class="nc" id="L253">                            });</span>
<span class="nc" id="L254">                });</span>
<span class="nc" id="L255">    }</span>

    /**
     * Get the {@link ChannelImplementation} to use.
     *
     * @return The server channel type.
     */
    ChannelImplementation getChannelImplementation() {
<span class="nc" id="L263">        final String type = getServerConfig(String.class, &quot;--implementation&quot;);</span>
<span class="nc" id="L264">        return ChannelImplementation.valueOf(type.toUpperCase());</span>
    }

    /**
     * Get an instance of {@link CorfuRuntimeParameters} representing the default Corfu Runtime's
     * parameters.
     *
     * @return an instance of {@link CorfuRuntimeParameters}
     */
    public CorfuRuntimeParameters getManagementRuntimeParameters() {
<span class="nc" id="L274">        return CorfuRuntime.CorfuRuntimeParameters.builder()</span>
<span class="nc" id="L275">                .priorityLevel(PriorityLevel.HIGH)</span>
<span class="nc" id="L276">                .nettyEventLoop(clientGroup)</span>
<span class="nc" id="L277">                .shutdownNettyEventLoop(false)</span>
<span class="nc" id="L278">                .tlsEnabled((Boolean) serverConfig.get(&quot;--enable-tls&quot;))</span>
<span class="nc" id="L279">                .keyStore((String) serverConfig.get(&quot;--keystore&quot;))</span>
<span class="nc" id="L280">                .ksPasswordFile((String) serverConfig.get(&quot;--keystore-password-file&quot;))</span>
<span class="nc" id="L281">                .trustStore((String) serverConfig.get(&quot;--truststore&quot;))</span>
<span class="nc" id="L282">                .tsPasswordFile((String) serverConfig.get(&quot;--truststore-password-file&quot;))</span>
<span class="nc" id="L283">                .saslPlainTextEnabled((Boolean) serverConfig.get(&quot;--enable-sasl-plain-text-auth&quot;))</span>
<span class="nc" id="L284">                .usernameFile((String) serverConfig.get(&quot;--sasl-plain-text-username-file&quot;))</span>
<span class="nc" id="L285">                .passwordFile((String) serverConfig.get(&quot;--sasl-plain-text-password-file&quot;))</span>
<span class="nc" id="L286">                .bulkReadSize(Integer.parseInt((String) serverConfig.get(&quot;--batch-size&quot;)))</span>
<span class="nc" id="L287">                .build();</span>
    }

    /**
     * Generate a Node Id if not present.
     */
    private void generateNodeId() {
<span class="nc" id="L294">        String currentId = getDataStore().get(NODE_ID_RECORD);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (currentId == null) {</span>
<span class="nc" id="L296">            String idString = UuidUtils.asBase64(UUID.randomUUID());</span>
<span class="nc" id="L297">            log.info(&quot;No Node Id, setting to new Id={}&quot;, idString);</span>
<span class="nc" id="L298">            getDataStore().put(NODE_ID_RECORD, idString);</span>
<span class="nc" id="L299">        } else {</span>
<span class="nc" id="L300">            log.info(&quot;Node Id = {}&quot;, currentId);</span>
        }
<span class="nc" id="L302">    }</span>

    /**
     * Get the node id as an UUID.
     *
     * @return  A UUID for this node.
     */
    public UUID getNodeId() {
<span class="nc" id="L310">        return UuidUtils.fromBase64(getNodeIdBase64());</span>
    }

    /** Get the node id as a base64 string.
     *
     * @return A node ID for this node, as a base64 string.
     */
    public String getNodeIdBase64() {
<span class="nc" id="L318">        return getDataStore().get(NODE_ID_RECORD);</span>
    }

    /**
     * Get a field from the server configuration map.
     *
     * @param type          The type of the field.
     * @param optionName    The name of the option to retrieve.
     * @param &lt;T&gt;           The type of the field to return.
     * @return              The field with the give option name.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getServerConfig(Class&lt;T&gt; type, String optionName) {
<span class="nc" id="L331">        return (T) getServerConfig().get(optionName);</span>
    }


    /**
     * Install a single node layout if and only if no layout is currently installed.
     * Synchronized, so this method is thread-safe.
     *
     *  @return True, if a new layout was installed, false otherwise.
     */
    public synchronized boolean installSingleNodeLayoutIfAbsent() {
<span class="nc bnc" id="L342" title="All 4 branches missed.">        if ((Boolean) getServerConfig().get(&quot;--single&quot;) &amp;&amp; getCurrentLayout() == null) {</span>
<span class="nc" id="L343">            setCurrentLayout(getNewSingleNodeLayout());</span>
<span class="nc" id="L344">            return true;</span>
        }
<span class="nc" id="L346">        return false;</span>
    }

    /**
     * Get a new single node layout used for self-bootstrapping a server started with
     * the -s flag.
     *
     *  @returns A new single node layout with a unique cluster Id
     *  @throws IllegalArgumentException    If the cluster id was not auto, base64 or a UUID string
     */
    public Layout getNewSingleNodeLayout() {
<span class="nc" id="L357">        final String clusterIdString = (String) getServerConfig().get(&quot;--cluster-id&quot;);</span>
        UUID clusterId;
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (clusterIdString.equals(&quot;auto&quot;)) {</span>
<span class="nc" id="L360">            clusterId = UUID.randomUUID();</span>
        } else {
            // Is it a UUID?
            try {
<span class="nc" id="L364">                clusterId = UUID.fromString(clusterIdString);</span>
<span class="nc" id="L365">            } catch (IllegalArgumentException ignore) {</span>
                // Must be a base64 id, otherwise we will throw InvalidArgumentException again
<span class="nc" id="L367">                clusterId = UuidUtils.fromBase64(clusterIdString);</span>
<span class="nc" id="L368">            }</span>
        }
<span class="nc" id="L370">        log.info(&quot;getNewSingleNodeLayout: Bootstrapping with cluster Id {} [{}]&quot;,</span>
<span class="nc" id="L371">            clusterId, UuidUtils.asBase64(clusterId));</span>
<span class="nc" id="L372">        String localAddress = getServerConfig().get(&quot;--address&quot;) + &quot;:&quot;</span>
<span class="nc" id="L373">            + getServerConfig().get(&quot;&lt;port&gt;&quot;);</span>
<span class="nc" id="L374">        return new Layout(</span>
<span class="nc" id="L375">            Collections.singletonList(localAddress),</span>
<span class="nc" id="L376">            Collections.singletonList(localAddress),</span>
<span class="nc" id="L377">            Collections.singletonList(new LayoutSegment(</span>
                Layout.ReplicationMode.CHAIN_REPLICATION,
                0L,
                -1L,
<span class="nc" id="L381">                Collections.singletonList(</span>
                    new Layout.LayoutStripe(
<span class="nc" id="L383">                        Collections.singletonList(localAddress)</span>
                    )
                )
            )),
            0L,
            clusterId
        );
    }

    /**
     * Get the current {@link Layout} stored in the {@link DataStore}.
     *
     * @return The current stored {@link Layout}
     */
    public Layout getCurrentLayout() {
<span class="nc" id="L398">        return getDataStore().get(CURR_LAYOUT_RECORD);</span>
    }

    /**
     * Set the current {@link Layout} stored in the {@link DataStore}.
     *
     * @param layout The {@link Layout} to set in the {@link DataStore}.
     */
    public void setCurrentLayout(Layout layout) {
<span class="nc" id="L407">        getDataStore().put(CURR_LAYOUT_RECORD, layout);</span>
<span class="nc" id="L408">    }</span>

    /**
     * Get the list of servers registered in serverRouter
     *
     * @return A list of servers registered in serverRouter
     */
    public List&lt;AbstractServer&gt; getServers() {
<span class="nc" id="L416">        return serverRouter.getServers();</span>
    }

    /**
     * The epoch of this router. This is managed by the base server implementation.
     */
    public synchronized long getServerEpoch() {
<span class="nc" id="L423">        Long epoch = dataStore.get(SERVER_EPOCH_RECORD);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        return epoch == null ? 0 : epoch;</span>
    }

    /**
     * Set the serverRouter epoch.
     *
     * @param serverEpoch the epoch to set
     */
    public synchronized void setServerEpoch(long serverEpoch, IServerRouter r) {
<span class="nc" id="L433">        Long lastEpoch = dataStore.get(SERVER_EPOCH_RECORD);</span>
<span class="nc bnc" id="L434" title="All 4 branches missed.">        if (lastEpoch == null || lastEpoch &lt; serverEpoch) {</span>
<span class="nc" id="L435">            dataStore.put(SERVER_EPOCH_RECORD, serverEpoch);</span>
<span class="nc" id="L436">            r.setServerEpoch(serverEpoch);</span>
<span class="nc" id="L437">            getServers().forEach(s -&gt; s.sealServerWithEpoch(serverEpoch));</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        } else if (serverEpoch == lastEpoch) {</span>
            // Setting to the same epoch, don't need to do anything.
        } else {
            // Regressing, throw an exception.
<span class="nc" id="L442">            throw new WrongEpochException(lastEpoch);</span>
        }
<span class="nc" id="L444">    }</span>

    public void setLayoutInHistory(Layout layout) {
<span class="nc" id="L447">        KvRecord&lt;Layout&gt; currLayoutRecord = KvRecord.of(</span>
<span class="nc" id="L448">                PREFIX_LAYOUTS, String.valueOf(layout.getEpoch()), Layout.class</span>
        );
<span class="nc" id="L450">        dataStore.put(currLayoutRecord, layout);</span>
<span class="nc" id="L451">    }</span>

    /**
     * Persists the sequencer epoch. This is set only by the SequencerServer in the resetServer.
     * No lock required as it relies on the resetServer lock.
     *
     * @param sequencerEpoch Epoch to persist.
     */
    public void setSequencerEpoch(long sequencerEpoch) {
<span class="nc" id="L460">        dataStore.put(SEQUENCER_RECORD, sequencerEpoch);</span>
<span class="nc" id="L461">    }</span>

    /**
     * Fetch the persisted sequencer epoch.
     *
     * @return Sequencer epoch.
     */
    public long getSequencerEpoch() {
<span class="nc" id="L469">        Long epoch = dataStore.get(SEQUENCER_RECORD);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        return epoch == null ? Layout.INVALID_EPOCH : epoch;</span>
    }

    /**
     * Sets the management layout in the persistent datastore.
     *
     * @param newLayout Layout to be persisted
     */
    public synchronized Layout saveManagementLayout(Layout newLayout) {
<span class="nc" id="L479">        Layout currentLayout = copyManagementLayout();</span>

        // Cannot update with a null layout.
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (newLayout == null) {</span>
<span class="nc" id="L483">            log.warn(&quot;Attempted to update with null. Current layout: {}&quot;, currentLayout);</span>
<span class="nc" id="L484">            return currentLayout;</span>
        }

        // Update only if new layout has a higher epoch than the existing layout.
<span class="nc bnc" id="L488" title="All 4 branches missed.">        if (currentLayout == null || newLayout.getEpoch() &gt; currentLayout.getEpoch()) {</span>
<span class="nc" id="L489">            dataStore.put(MANAGEMENT_LAYOUT_RECORD, newLayout);</span>
<span class="nc" id="L490">            currentLayout = copyManagementLayout();</span>
<span class="nc" id="L491">            log.info(&quot;Update to new layout at epoch {}&quot;, currentLayout.getEpoch());</span>
<span class="nc" id="L492">            return currentLayout;</span>
        }

<span class="nc" id="L495">        return currentLayout;</span>

    }

    /**
     * Save detected failure in a history. History represents all cluster state changes.
     * Disabled by default.
     *
     * @param detector failure detector state
     */
    public synchronized void saveFailureDetectorMetrics(FailureDetectorMetrics detector) {
<span class="nc" id="L506">        boolean enabled = Boolean.parseBoolean(System.getProperty(&quot;corfu.failuredetector&quot;, Boolean.FALSE.toString()));</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (!enabled){</span>
<span class="nc" id="L508">            return;</span>
        }

<span class="nc" id="L511">        KvRecord&lt;FailureDetectorMetrics&gt; fdRecord = KvRecord.of(</span>
                PREFIX_FAILURE_DETECTOR,
<span class="nc" id="L513">                String.valueOf(getManagementLayout().getEpoch()),</span>
                FailureDetectorMetrics.class
        );

<span class="nc" id="L517">        dataStore.put(fdRecord, detector);</span>
<span class="nc" id="L518">    }</span>

    /**
     * Get latest change in a cluster state saved in data store. Or provide default value if history is disabled.
     *
     * @return latest failure saved in the history
     */
    public FailureDetectorMetrics getFailureDetectorMetrics() {
<span class="nc" id="L526">        boolean enabled = Boolean.parseBoolean(System.getProperty(&quot;corfu.failuredetector&quot;, Boolean.FALSE.toString()));</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if(!enabled){</span>
<span class="nc" id="L528">            return getDefaultFailureDetectorMetric(getManagementLayout());</span>
        }

<span class="nc" id="L531">        KvRecord&lt;FailureDetectorMetrics&gt; fdRecord = KvRecord.of(</span>
                PREFIX_FAILURE_DETECTOR,
<span class="nc" id="L533">                String.valueOf(getManagementLayout().getEpoch()),</span>
                FailureDetectorMetrics.class
        );

<span class="nc" id="L537">        return Optional</span>
<span class="nc" id="L538">                .ofNullable(dataStore.get(fdRecord))</span>
<span class="nc" id="L539">                .orElseGet(() -&gt; getDefaultFailureDetectorMetric(getManagementLayout()));</span>
    }

    /**
     * Provide default metric.
     * @param layout current layout
     * @return default value
     */
    private FailureDetectorMetrics getDefaultFailureDetectorMetric(Layout layout) {
<span class="nc" id="L548">        return FailureDetectorMetrics.builder()</span>
<span class="nc" id="L549">                .localNode(getLocalEndpoint())</span>
<span class="nc" id="L550">                .layout(layout.getLayoutServers())</span>
<span class="nc" id="L551">                .unresponsiveNodes(layout.getUnresponsiveServers())</span>
<span class="nc" id="L552">                .epoch(layout.getEpoch())</span>
<span class="nc" id="L553">                .build();</span>
    }

    /**
     * Fetches the management layout from the persistent datastore.
     *
     * @return The last persisted layout
     */
    public Layout getManagementLayout() {
<span class="nc" id="L562">        return dataStore.get(MANAGEMENT_LAYOUT_RECORD);</span>
    }

    /**
     * Sets the log unit epoch water mark.
     *
     * @param resetEpoch Epoch at which the reset command was received.
     */
    public synchronized void setLogUnitEpochWaterMark(long resetEpoch) {
<span class="nc" id="L571">        dataStore.put(LOG_UNIT_WATERMARK_RECORD, resetEpoch);</span>
<span class="nc" id="L572">    }</span>

    /**
     * Fetches the epoch at which the last epochWaterMark operation was received.
     *
     * @return Reset epoch.
     */
    public synchronized long getLogUnitEpochWaterMark() {
<span class="nc" id="L580">        Long resetEpoch = dataStore.get(LOG_UNIT_WATERMARK_RECORD);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        return resetEpoch == null ? Layout.INVALID_EPOCH : resetEpoch;</span>
    }

    /**
     * Fetches and creates a copy of the Management Layout from the local datastore.
     *
     * @return Copy of the management layout from the datastore.
     */
    public Layout copyManagementLayout() {
<span class="nc" id="L590">        Layout l = getManagementLayout();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L592">            return new Layout(l);</span>
        } else {
<span class="nc" id="L594">            return null;</span>
        }
    }

    /**
     * Get a new &quot;boss&quot; group, which services (accepts) incoming connections.
     *
     * @return A boss group.
     */
    private EventLoopGroup getNewBossGroup() {
<span class="nc" id="L604">        final ThreadFactory threadFactory = new ThreadFactoryBuilder()</span>
<span class="nc" id="L605">                .setNameFormat(getThreadPrefix() + &quot;accept-%d&quot;)</span>
<span class="nc" id="L606">                .build();</span>
<span class="nc" id="L607">        EventLoopGroup group = getChannelImplementation().getGenerator()</span>
<span class="nc" id="L608">                .generate(1, threadFactory);</span>
<span class="nc" id="L609">        log.info(&quot;getBossGroup: Type {}&quot;, group.getClass().getSimpleName());</span>
<span class="nc" id="L610">        return group;</span>
    }

    /**
     * Get a new &quot;worker&quot; group, which services incoming requests.
     *
     * @return A worker group.
     */
    private @Nonnull EventLoopGroup getNewWorkerGroup() {
<span class="nc" id="L619">        final ThreadFactory threadFactory = new ThreadFactoryBuilder()</span>
<span class="nc" id="L620">                .setNameFormat(getThreadPrefix() + &quot;worker-%d&quot;)</span>
<span class="nc" id="L621">                .build();</span>

<span class="nc" id="L623">        final int requestedThreads =</span>
<span class="nc" id="L624">                Integer.parseInt(getServerConfig(String.class, &quot;--Threads&quot;));</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        final int numThreads = requestedThreads == 0</span>
<span class="nc" id="L626">                ? Runtime.getRuntime().availableProcessors() * 2</span>
                : requestedThreads;
<span class="nc" id="L628">        EventLoopGroup group = getChannelImplementation().getGenerator()</span>
<span class="nc" id="L629">            .generate(numThreads, threadFactory);</span>

<span class="nc" id="L631">        log.info(&quot;getWorkerGroup: Type {} with {} threads&quot;,</span>
<span class="nc" id="L632">                group.getClass().getSimpleName(), numThreads);</span>
<span class="nc" id="L633">        return group;</span>
    }

    /**
     * Get a new &quot;client&quot; group, which services incoming client requests.
     *
     * @return A worker group.
     */
    private @Nonnull EventLoopGroup getNewClientGroup() {
<span class="nc" id="L642">        final ThreadFactory threadFactory = new ThreadFactoryBuilder()</span>
<span class="nc" id="L643">                .setNameFormat(getThreadPrefix() + &quot;client-%d&quot;)</span>
<span class="nc" id="L644">                .build();</span>

<span class="nc" id="L646">        final int requestedThreads =</span>
<span class="nc" id="L647">            Integer.parseInt(getServerConfig(String.class, &quot;--Threads&quot;));</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        final int numThreads = requestedThreads == 0</span>
<span class="nc" id="L649">            ? Runtime.getRuntime().availableProcessors() * 2</span>
            : requestedThreads;
<span class="nc" id="L651">        EventLoopGroup group = getChannelImplementation().getGenerator()</span>
<span class="nc" id="L652">            .generate(numThreads, threadFactory);</span>

<span class="nc" id="L654">        log.info(&quot;getClientGroup: Type {} with {} threads&quot;,</span>
<span class="nc" id="L655">            group.getClass().getSimpleName(), numThreads);</span>
<span class="nc" id="L656">        return group;</span>
    }

    /**
     * Get the prefix for threads this server creates.
     *
     * @return A string that should be prepended to threads this server creates.
     */
    public @Nonnull String getThreadPrefix() {
<span class="nc" id="L665">        final String prefix = getServerConfig(String.class, &quot;--Prefix&quot;);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (prefix.equals(&quot;&quot;)) {</span>
<span class="nc" id="L667">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L669">            return prefix + &quot;-&quot;;</span>
        }
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Cleans up and releases all resources (such as thread pools and files) opened
     * by this {@link ServerContext}.
     */
    @Override
    public void close() {
<span class="nc" id="L681">        CorfuRuntimeParameters params = getManagementRuntimeParameters();</span>
        // Shutdown the active event loops unless they were provided to us
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (!getChannelImplementation().equals(ChannelImplementation.LOCAL)) {</span>
<span class="nc" id="L684">            clientGroup.shutdownGracefully(</span>
<span class="nc" id="L685">                    params.getNettyShutdownQuitePeriod(),</span>
<span class="nc" id="L686">                    params.getNettyShutdownTimeout(),</span>
                    TimeUnit.MILLISECONDS
            );
<span class="nc" id="L689">            bossGroup.shutdownGracefully(</span>
<span class="nc" id="L690">                    params.getNettyShutdownQuitePeriod(),</span>
<span class="nc" id="L691">                    params.getNettyShutdownTimeout(),</span>
                    TimeUnit.MILLISECONDS
            );
<span class="nc" id="L694">            workerGroup.shutdownGracefully(</span>
<span class="nc" id="L695">                    params.getNettyShutdownQuitePeriod(),</span>
<span class="nc" id="L696">                    params.getNettyShutdownTimeout(),</span>
                    TimeUnit.MILLISECONDS
            );
        }
<span class="nc" id="L700">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>