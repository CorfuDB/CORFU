<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DataStore.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cmdlets</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">DataStore.java</span></div><h1>DataStore.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import static org.corfudb.infrastructure.utils.Persistence.syncDirectory;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.CacheWriter;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import com.github.benmanes.caffeine.cache.RemovalCause;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.runtime.exceptions.DataCorruptionException;
import org.corfudb.util.JsonUtils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Stores data as JSON.
 *
 * &lt;p&gt;Handle in-memory and persistent case differently:
 *
 * &lt;p&gt;In in-memory mode, the &quot;cache&quot; is actually the store, so we never evict anything from it.
 *
 * &lt;p&gt;In persistent mode, we use a {@link LoadingCache}, where an in-memory map is backed by disk.
 * In this scheme, the key for each value is also the name of the file where the value is stored.
 * The key is determined as (prefix + &quot;_&quot; + key).
 * The cache here serves mostly for easily managed synchronization of in-memory/file.
 * Some on-disk files will be deleted when their number exceed user specified limit.
 *
 * &lt;p&gt;If 'opts' either has '--memory=true' or a log-path for storing files is not provided,
 * the store is just an in memory cache.
 *
 * &lt;p&gt;Created by mdhawan on 7/27/16.
 */

<span class="nc" id="L49">@Slf4j</span>
public class DataStore implements IDataStore {

    static final String EXTENSION = &quot;.ds&quot;;

<span class="nc" id="L54">    @Getter</span>
    private final Cache&lt;String, Object&gt; cache;
    private final String logDirPath;

<span class="nc" id="L58">    @Getter</span>
    private final long dsCacheSize = 1_000; // size bound for in-memory cache for dataStore

    private final boolean inMem;

    private final Consumer&lt;String&gt; cleanupTask;

    /**
     * Return a new DataStore object.
     *
     * @param opts        map of option strings
     * @param cleanupTask method to cleanup DataStore files
     */
    public DataStore(@Nonnull Map&lt;String, Object&gt; opts,
<span class="nc" id="L72">                     @Nonnull Consumer&lt;String&gt; cleanupTask) {</span>

<span class="nc bnc" id="L74" title="All 6 branches missed.">        if ((opts.containsKey(&quot;--memory&quot;) &amp;&amp; (Boolean) opts.get(&quot;--memory&quot;)) || !opts.containsKey(&quot;--log-path&quot;)) {</span>
<span class="nc" id="L75">            this.logDirPath = null;</span>
<span class="nc" id="L76">            this.cleanupTask = fileName -&gt; { };</span>
<span class="nc" id="L77">            cache = buildMemoryDs();</span>
<span class="nc" id="L78">            inMem = true;</span>
        } else {
<span class="nc" id="L80">            this.logDirPath = (String) opts.get(&quot;--log-path&quot;);</span>
<span class="nc" id="L81">            this.cleanupTask = cleanupTask;</span>
<span class="nc" id="L82">            cache = buildPersistentDs();</span>
<span class="nc" id="L83">            inMem = false;</span>
        }
<span class="nc" id="L85">    }</span>

    /**
     * obtain an in-memory cache, no content loader, no writer, no size limit.
     *
     * @return new LoadingCache for the DataStore
     */
    private Cache&lt;String, Object&gt; buildMemoryDs() {
<span class="nc" id="L93">        return Caffeine.newBuilder().build(k -&gt; null);</span>
    }


    public static int getChecksum(byte[] bytes) {
<span class="nc" id="L98">        Hasher hasher = Hashing.crc32c().newHasher();</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        for (byte a : bytes) {</span>
<span class="nc" id="L100">            hasher.putByte(a);</span>
        }

<span class="nc" id="L103">        return hasher.hash().asInt();</span>
    }

    /**
     * obtain a {@link LoadingCache}.
     * The cache is backed up by file-per-key under {@link DataStore::logDirPath}.
     * The cache size is bounded by {@link DataStore::dsCacheSize}.
     *
     * @return the cache object
     */
    private Cache&lt;String, Object&gt; buildPersistentDs() {
<span class="nc" id="L114">        return Caffeine.newBuilder()</span>
<span class="nc" id="L115">                .recordStats()</span>
<span class="nc" id="L116">                .writer(new CacheWriter&lt;String, Object&gt;() {</span>
                    @Override
                    public synchronized void write(@Nonnull String key, @Nonnull Object value) {

<span class="nc bnc" id="L120" title="All 2 branches missed.">                        if (value == NullValue.NULL_VALUE) {</span>
<span class="nc" id="L121">                            return;</span>
                        }

                        try {
<span class="nc" id="L125">                            String dsFileName = key + EXTENSION;</span>
<span class="nc" id="L126">                            Path path = Paths.get(logDirPath, dsFileName);</span>
<span class="nc" id="L127">                            Path tmpPath = Paths.get(logDirPath, dsFileName + &quot;.tmp&quot;);</span>

<span class="nc" id="L129">                            String jsonPayload = JsonUtils.parser.toJson(value, value.getClass());</span>
<span class="nc" id="L130">                            byte[] bytes = jsonPayload.getBytes();</span>

<span class="nc" id="L132">                            ByteBuffer buffer = ByteBuffer.allocate(bytes.length</span>
                                    + Integer.BYTES);
<span class="nc" id="L134">                            buffer.putInt(getChecksum(bytes));</span>
<span class="nc" id="L135">                            buffer.put(bytes);</span>
<span class="nc" id="L136">                            Files.write(tmpPath, buffer.array(), StandardOpenOption.CREATE,</span>
                                    StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.SYNC);
<span class="nc" id="L138">                            Files.move(tmpPath, path, StandardCopyOption.REPLACE_EXISTING,</span>
                                    StandardCopyOption.ATOMIC_MOVE);
<span class="nc" id="L140">                            syncDirectory(logDirPath);</span>
                            // Invoking the cleanup on each disk file write is fine for performance
                            // since DataStore files are not supposed to change too frequently
<span class="nc" id="L143">                            cleanupTask.accept(dsFileName);</span>
<span class="nc" id="L144">                        } catch (IOException e) {</span>
<span class="nc" id="L145">                            throw new RuntimeException(e);</span>
<span class="nc" id="L146">                        }</span>
<span class="nc" id="L147">                    }</span>

                    @Override
                    public synchronized void delete(@Nonnull String key,
                                                    @Nullable Object value,
                                                    @Nonnull RemovalCause cause) {
                        try {
<span class="nc" id="L154">                            Path path = Paths.get(logDirPath, key);</span>
<span class="nc" id="L155">                            Files.deleteIfExists(path);</span>
<span class="nc" id="L156">                        } catch (IOException e) {</span>
<span class="nc" id="L157">                            throw new RuntimeException(e);</span>
<span class="nc" id="L158">                        }</span>
<span class="nc" id="L159">                    }</span>
                })
<span class="nc" id="L161">                .maximumSize(dsCacheSize)</span>
<span class="nc" id="L162">                .build();</span>
    }

    @Override
    public synchronized &lt;T&gt; void put(Class&lt;T&gt; tclass, String prefix, String key, T value) {
<span class="nc" id="L167">        put(new KvRecord&lt;&gt;(prefix, key, tclass), value);</span>
<span class="nc" id="L168">    }</span>

    private &lt;T&gt; T load(Class&lt;T&gt; tClass, String key) {
        try {
<span class="nc" id="L172">            Path path = Paths.get(logDirPath, key + EXTENSION);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (Files.notExists(path)) {</span>
<span class="nc" id="L174">                return null;</span>
            }
<span class="nc" id="L176">            byte[] bytes = Files.readAllBytes(path);</span>
<span class="nc" id="L177">            ByteBuffer buf = ByteBuffer.wrap(bytes);</span>
<span class="nc" id="L178">            int checksum = buf.getInt();</span>
<span class="nc" id="L179">            byte[] strBytes = Arrays.copyOfRange(bytes, 4, bytes.length);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (checksum != getChecksum(strBytes)) {</span>
<span class="nc" id="L181">                throw new DataCorruptionException();</span>
            }

<span class="nc" id="L184">            String json = new String(strBytes);</span>
<span class="nc" id="L185">            T val = JsonUtils.parser.fromJson(json, tClass);</span>
<span class="nc" id="L186">            return val;</span>
<span class="nc" id="L187">        } catch (IOException e) {</span>
<span class="nc" id="L188">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Since the cache can't maintain key-&gt;null mappings, this enum
     * is a place holder for null to allow keys to map to null.
     */
<span class="nc" id="L196">    private enum NullValue {</span>
<span class="nc" id="L197">        NULL_VALUE</span>
    }

    @Override
    public synchronized &lt;T&gt; T get(Class&lt;T&gt; tclass, String prefix, String key) {
<span class="nc" id="L202">        return get(new KvRecord&lt;&gt;(prefix, key, tclass));</span>
    }

    @Override
    public synchronized &lt;T&gt; void delete(Class&lt;T&gt; tclass, String prefix, String key) {
<span class="nc" id="L207">        delete(new KvRecord&lt;&gt;(prefix, key, tclass));</span>
<span class="nc" id="L208">    }</span>

    @Override
    public synchronized &lt;T&gt; void put(KvRecord&lt;T&gt; key, T value) {
<span class="nc" id="L212">        cache.put(key.getFullKeyName(), value);</span>
<span class="nc" id="L213">    }</span>

    @Override
    public synchronized &lt;T&gt; T get(KvRecord&lt;T&gt; key) {
<span class="nc" id="L217">        String path = key.getFullKeyName();</span>
<span class="nc" id="L218">        Object val = cache.get(path, k -&gt; {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (!inMem) {</span>
<span class="nc" id="L220">                T loadedVal = load(key.getDataType(), path);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (loadedVal != null) {</span>
<span class="nc" id="L222">                    return loadedVal;</span>
                }
            }

            // We need to maintain a path -&gt; null mapping for keys that were loaded, but
            // were empty. This is required to prevent loading an empty key more than once, which is expensive.
<span class="nc" id="L228">            return NullValue.NULL_VALUE;</span>
        });

<span class="nc bnc" id="L231" title="All 2 branches missed.">        return val == NullValue.NULL_VALUE ? null : (T) val;</span>
    }

    @Override
    public &lt;T&gt; T get(KvRecord&lt;T&gt; key, T defaultValue) {
<span class="nc" id="L236">        T value = get(key);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        return value == null ? defaultValue : value;</span>
    }

    @Override
    public synchronized &lt;T&gt; void delete(KvRecord&lt;T&gt; key) {
<span class="nc" id="L242">        cache.invalidate(key.getFullKeyName());</span>
<span class="nc" id="L243">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>