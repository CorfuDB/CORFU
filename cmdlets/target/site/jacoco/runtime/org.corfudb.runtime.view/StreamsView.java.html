<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StreamsView.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cmdlets</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.view</a> &gt; <span class="el_source">StreamsView.java</span></div><h1>StreamsView.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.view;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.wireprotocol.DataType;
import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.protocols.wireprotocol.LogData;
import org.corfudb.protocols.wireprotocol.TokenResponse;
import org.corfudb.protocols.wireprotocol.TxResolutionInfo;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.exceptions.AbortCause;
import org.corfudb.runtime.exceptions.AppendException;
import org.corfudb.runtime.exceptions.OverwriteException;
import org.corfudb.runtime.exceptions.StaleTokenException;
import org.corfudb.runtime.exceptions.TransactionAbortedException;
import org.corfudb.runtime.object.transactions.TransactionalContext;
import org.corfudb.runtime.view.stream.IStreamView;
import org.corfudb.util.Utils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Created by mwei on 12/11/15.
 */
<span class="nc" id="L32">@Slf4j</span>
public class StreamsView extends AbstractView {

    /**
     * Checkpoint of streams have their own stream id derived from the
     * stream id. We add the checkpoint suffix to the original stream id.
     */
    public static final String CHECKPOINT_SUFFIX = &quot;_cp&quot;;

<span class="nc" id="L41">    @Getter</span>
<span class="nc" id="L42">    Multimap&lt;UUID, IStreamView&gt; streamCache = Multimaps.synchronizedMultimap(HashMultimap.create());</span>

    public StreamsView(final CorfuRuntime runtime) {
<span class="nc" id="L45">        super(runtime);</span>
<span class="nc" id="L46">    }</span>

    /**
     * Get a view on a stream. The view has its own pointer to the stream.
     *
     * @param stream The UUID of the stream to get a view on.
     * @return A view
     */
    public IStreamView get(UUID stream) {
<span class="nc" id="L55">        return this.get(stream, StreamOptions.DEFAULT);</span>
    }

    /**
     * Since streams can also be used by higher level abstractions, some consumers implement
     * synchronization at a higher level, so the stream implementation doesn't have to
     * be thread-safe. Also, gc will not be called on unsafe streams therefore gc needs to
     * be managed by the consumer.
     *
     * @param stream stream id
     * @return an unsafe (not thread safe) stream implementation
     */
    public IStreamView getUnsafe(UUID stream) {
<span class="nc" id="L68">        return this.getUnsafe(stream, StreamOptions.DEFAULT);</span>
    }

    /**
     * Get a view on a stream. The view has its own pointer to the stream.
     *
     * @param stream The UUID of the stream to get a view on.
     * @return A view
     */
    public IStreamView get(UUID stream, StreamOptions options) {
<span class="nc" id="L78">        IStreamView streamView = runtime.getLayoutView().getLayout().getLatestSegment()</span>
<span class="nc" id="L79">                .getReplicationMode().getStreamView(runtime, stream, options);</span>
<span class="nc" id="L80">        streamCache.put(stream, streamView);</span>
<span class="nc" id="L81">        return streamView;</span>
    }

    public IStreamView getUnsafe(UUID stream, StreamOptions options) {
<span class="nc" id="L85">        return runtime.getLayoutView().getLayout().getLatestSegment()</span>
<span class="nc" id="L86">                .getReplicationMode().getUnsafeStreamView(runtime, stream, options);</span>
    }

    /**
     * Run garbage collection on all opened streams. Note that opened
     * unsafe streams will be excluded (because its unsafe for the garbage
     * collector thread to operate on them while being used by a different
     * thread).
     */
    public void gc(long trimMark) {
<span class="nc bnc" id="L96" title="All 2 branches missed.">        for (IStreamView streamView : getStreamCache().values()) {</span>
<span class="nc" id="L97">            streamView.gc(trimMark);</span>
<span class="nc" id="L98">        }</span>
<span class="nc" id="L99">    }</span>

    /**
     * Append to multiple streams simultaneously, possibly providing
     * information on how to resolve conflicts.
     *
     * @param streamIDs    The streams to append to.
     * @param object       The object to append to each stream.
     * @param conflictInfo Conflict information for the sequencer to check.
     * @param cacheOption  The caching mode for write/append
     * @return The address the entry was written to.
     * @throws TransactionAbortedException If the transaction was aborted by
     *                                     the sequencer.
     */
    public long append(@Nonnull Object object, @Nullable TxResolutionInfo conflictInfo,
                       @Nonnull CacheOption cacheOption, @Nonnull UUID... streamIDs) {

<span class="nc" id="L116">        final LogData ld = new LogData(DataType.DATA, object);</span>
<span class="nc" id="L117">        ld.checkMaxWriteSize(runtime.getParameters().getMaxWriteSize());</span>

<span class="nc" id="L119">        TokenResponse tokenResponse = null;</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        for (int x = 0; x &lt; runtime.getParameters().getWriteRetry(); x++) {</span>
            // Go to the sequencer, grab a token to write.
<span class="nc bnc" id="L122" title="All 2 branches missed.">            tokenResponse = conflictInfo == null</span>
<span class="nc" id="L123">                    ? runtime.getSequencerView().next(streamIDs) // Token w/o conflict info</span>
<span class="nc" id="L124">                    : runtime.getSequencerView().next(conflictInfo, streamIDs); // Token w/ conflict info</span>

            // Is our token a valid type?
<span class="nc" id="L127">            AbortCause abortCause = null;</span>
<span class="nc bnc" id="L128" title="All 5 branches missed.">            switch (tokenResponse.getRespType()) {</span>
                case TX_ABORT_CONFLICT:
<span class="nc" id="L130">                    abortCause = AbortCause.CONFLICT;</span>
<span class="nc" id="L131">                    break;</span>
                case TX_ABORT_NEWSEQ:
<span class="nc" id="L133">                    abortCause = AbortCause.NEW_SEQUENCER;</span>
<span class="nc" id="L134">                    break;</span>
                case TX_ABORT_SEQ_OVERFLOW:
<span class="nc" id="L136">                    abortCause = AbortCause.SEQUENCER_OVERFLOW;</span>
<span class="nc" id="L137">                    break;</span>
                case TX_ABORT_SEQ_TRIM:
<span class="nc" id="L139">                    abortCause = AbortCause.SEQUENCER_TRIM;</span>
                    break;
            }

<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (abortCause != null) {</span>
<span class="nc" id="L144">                throw new TransactionAbortedException(</span>
                        conflictInfo,
<span class="nc" id="L146">                        tokenResponse.getConflictKey(), tokenResponse.getConflictStream(),</span>
<span class="nc" id="L147">                        tokenResponse.getToken().getSequence(), abortCause,</span>
<span class="nc" id="L148">                        TransactionalContext.getCurrentContext());</span>
            }

            try {
                // Attempt to write to the log.
<span class="nc" id="L153">                runtime.getAddressSpaceView().write(tokenResponse, ld, cacheOption);</span>
                // If we're here, we succeeded, return the acquired token.
<span class="nc" id="L155">                return tokenResponse.getSequence();</span>
<span class="nc" id="L156">            } catch (OverwriteException oe) {</span>
                // We were overwritten, get a new token and try again.
<span class="nc" id="L158">                log.warn(&quot;append[{}]: Overwritten after {} retries, streams {}&quot;,</span>
<span class="nc" id="L159">                        tokenResponse.getSequence(), x,</span>
<span class="nc" id="L160">                        Arrays.stream(streamIDs).map(Utils::toReadableId).collect(Collectors.toSet()));</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (conflictInfo != null) {</span>
                    // On retry, check for conflicts only from the previous attempt position,
                    // otherwise the transaction will always conflict with itself.
<span class="nc" id="L165">                    conflictInfo.setSnapshotTimestamp(tokenResponse.getToken());</span>
                }

<span class="nc" id="L168">            } catch (StaleTokenException se) {</span>
                // the epoch changed from when we grabbed the token from sequencer
<span class="nc" id="L170">                log.warn(&quot;append[{}]: StaleToken, streams {}&quot;, tokenResponse.getSequence(),</span>
<span class="nc" id="L171">                        Arrays.stream(streamIDs).map(Utils::toReadableId).collect(Collectors.toSet()));</span>

<span class="nc" id="L173">                throw new TransactionAbortedException(</span>
                        conflictInfo,
<span class="nc" id="L175">                        tokenResponse.getConflictKey(), tokenResponse.getConflictStream(),</span>
<span class="nc" id="L176">                        tokenResponse.getToken().getSequence(),</span>
                        AbortCause.NEW_SEQUENCER, // in the future perhaps define a new AbortCause?
<span class="nc" id="L178">                        TransactionalContext.getCurrentContext());</span>
<span class="nc" id="L179">            }</span>
        }

<span class="nc bnc" id="L182" title="All 2 branches missed.">        log.error(&quot;append[{}]: failed after {} retries, streams {}, write size {} bytes&quot;,</span>
<span class="nc" id="L183">                tokenResponse == null ? -1 : tokenResponse.getSequence(),</span>
<span class="nc" id="L184">                runtime.getParameters().getWriteRetry(),</span>
<span class="nc" id="L185">                Arrays.stream(streamIDs).map(Utils::toReadableId).collect(Collectors.toSet()),</span>
<span class="nc" id="L186">                ILogData.getSerializedSize(object));</span>
<span class="nc" id="L187">        throw new AppendException();</span>
    }

    /**
     * Append to multiple streams and caches the result.
     *
     * @see StreamsView#append(Object, TxResolutionInfo, CacheOption, UUID...)
     */
    public long append(@Nonnull Object object, @Nullable TxResolutionInfo conflictInfo,
                       @Nonnull UUID... streamIDs) {
<span class="nc" id="L197">        return append(object, conflictInfo, CacheOption.WRITE_THROUGH, streamIDs);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>