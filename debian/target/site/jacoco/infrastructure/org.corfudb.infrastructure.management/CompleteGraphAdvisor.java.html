<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CompleteGraphAdvisor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure.management</a> &gt; <span class="el_source">CompleteGraphAdvisor.java</span></div><h1>CompleteGraphAdvisor.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure.management;

import com.google.common.collect.ImmutableList;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.infrastructure.management.failuredetector.ClusterGraph;
import org.corfudb.protocols.wireprotocol.ClusterState;
import org.corfudb.protocols.wireprotocol.failuredetector.NodeRank;

import java.util.List;
import java.util.Optional;

/**
 * This class is an implementation of {@link ClusterType} where the ideal state
 * of the Corfu cluster is a fully connected network (i.e. complete graph) in which there is an
 * active link amongst all nodes in the cluster. Failed and Healed nodes are recommended so that
 * the cluster remains fully connected.
 * &lt;p&gt;
 * Created by Sam Behnam on 10/27/18.
 */
<span class="nc" id="L21">@Slf4j</span>
public class CompleteGraphAdvisor implements ClusterAdvisor {

<span class="nc" id="L24">    private static final ClusterType CLUSTER_TYPE = ClusterType.COMPLETE_GRAPH;</span>

    private final String localEndpoint;

<span class="nc bnc" id="L28" title="All 2 branches missed.">    public CompleteGraphAdvisor(@NonNull String localEndpoint) {</span>
<span class="nc" id="L29">        this.localEndpoint = localEndpoint;</span>
<span class="nc" id="L30">    }</span>

    @Override
    public ClusterType getType() {
<span class="nc" id="L34">        return CLUSTER_TYPE;</span>
    }

    /**
     * Provides list of servers from a given layout(epoch) that this implementation of
     * COMPLETE_GRAPH algorithm has determined as failed. The implementation of the
     * algorithm in this method is an approach by executing the following steps:
     * &lt;p&gt;
     * The failed node is the recommendation of this strategy which their removal
     * from cluster will lead to a fully connected cluster.
     * &lt;p&gt;
     * To find a failed node:
     * - get decision maker
     * - find a failed node. Check if decision maker is not equal to failed node and failed node is not in unresponsive
     * servers already.
     *
     * @param clusterState        represents the state of connectivity amongst the Corfu cluster
     *                            nodes from a node's perspective.
     * @return a server considered as failed according to the underlying strategy.
     */
    @Override
    public Optional&lt;NodeRank&gt; failedServer(ClusterState clusterState) {

<span class="nc" id="L57">        log.trace(&quot;Detecting failed nodes for: ClusterState= {}&quot;, clusterState);</span>

<span class="nc" id="L59">        ClusterGraph graph = ClusterGraph.toClusterGraph(clusterState);</span>

<span class="nc" id="L61">        ClusterGraph symmetric = graph.toSymmetric();</span>
<span class="nc" id="L62">        Optional&lt;NodeRank&gt; maybeDecisionMaker = symmetric.getDecisionMaker();</span>

<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (!maybeDecisionMaker.isPresent()) {</span>
<span class="nc" id="L65">            log.error(&quot;Decision maker not found for graph: {}&quot;, symmetric.toJson());</span>
<span class="nc" id="L66">            return Optional.empty();</span>
        }

<span class="nc" id="L69">        NodeRank decisionMaker = maybeDecisionMaker.get();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (!decisionMaker.is(localEndpoint)) {</span>
<span class="nc" id="L71">            String message = &quot;The node can't be a decision maker, skip operation. Decision maker node is: {}&quot;;</span>
<span class="nc" id="L72">            log.debug(message, decisionMaker);</span>
<span class="nc" id="L73">            return Optional.empty();</span>
        }

<span class="nc" id="L76">        Optional&lt;NodeRank&gt; maybeFailedNode = symmetric.findFailedNode();</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (!maybeFailedNode.isPresent()) {</span>
<span class="nc" id="L78">            return Optional.empty();</span>
        }

<span class="nc" id="L81">        NodeRank failedNode = maybeFailedNode.get();</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (decisionMaker.equals(failedNode)) {</span>
<span class="nc" id="L84">            log.error(&quot;Decision maker and failed node are same node: {}&quot;, decisionMaker);</span>
<span class="nc" id="L85">            return Optional.empty();</span>
        }

<span class="nc" id="L88">        ImmutableList&lt;String&gt; unresponsiveNodes = clusterState.getUnresponsiveNodes();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (unresponsiveNodes.contains(failedNode.getEndpoint())) {</span>
<span class="nc" id="L90">            log.trace(&quot;Failed node already in the list of unresponsive nodes: {}&quot;, unresponsiveNodes);</span>
<span class="nc" id="L91">            return Optional.empty();</span>
        }

<span class="nc" id="L94">        log.debug(&quot;Failed node found: {}&quot;, failedNode);</span>
<span class="nc" id="L95">        return Optional.of(failedNode);</span>
    }

    /**
     * Provide a server considered to have healed in the Corfu cluster according to
     * the COMPLETE_GRAPH implementation of algorithm for
     * {@link ClusterType}.
     * &lt;p&gt;
     * The node can heal only itself. The node responsible only for itself, can't heal other nodes.
     * It simplifies healing algorithm and guaranties that if node became available it mark itself as a responsible
     * node in the layout. It helps us to simplify analysis/debugging process and brings simple and reliable algorithm
     * for healing process.
     *
     * @param clusterState        represents the state of connectivity amongst the Corfu cluster
     *                            nodes from a node's perspective.
     * @return a {@link List} of servers considered as healed according to the underlying
     * {@link ClusterType}.
     */
    @Override
    public Optional&lt;NodeRank&gt; healedServer(ClusterState clusterState) {

<span class="nc" id="L116">        log.trace(&quot;Detecting the healed nodes for: ClusterState: {}&quot;, clusterState);</span>

<span class="nc" id="L118">        ImmutableList&lt;String&gt; unresponsiveNodes = clusterState.getUnresponsiveNodes();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (unresponsiveNodes.isEmpty()) {</span>
<span class="nc" id="L120">            log.trace(&quot;All nodes responsive. Nothing to heal&quot;);</span>
<span class="nc" id="L121">            return Optional.empty();</span>
        }

<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (!unresponsiveNodes.contains(localEndpoint)) {</span>
<span class="nc" id="L125">            log.trace(&quot;Local node is responsive. Nothing to heal&quot;);</span>
<span class="nc" id="L126">            return Optional.empty();</span>
        }

        //Transform a ClusterState to the ClusterGraph and make it symmetric (symmetric failures)
<span class="nc" id="L130">        ClusterGraph symmetricGraph = ClusterGraph.toClusterGraph(clusterState).toSymmetric();</span>

        //See if local node is healed.
<span class="nc" id="L133">        return symmetricGraph.findFullyConnectedNode(localEndpoint);</span>
    }

    /**
     * Returns a new cluster graph from the cluster state
     *
     * @param clusterState a cluster state
     * @return a transformed cluster graph
     */
    @Override
    public ClusterGraph getGraph(ClusterState clusterState) {
<span class="nc" id="L144">        return ClusterGraph.toClusterGraph(clusterState).toSymmetric();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>