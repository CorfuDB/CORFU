<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FailureDetector.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure.management</a> &gt; <span class="el_source">FailureDetector.java</span></div><h1>FailureDetector.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure.management;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.infrastructure.RemoteMonitoringService;
import org.corfudb.infrastructure.management.ClusterStateContext.HeartbeatCounter;
import org.corfudb.protocols.wireprotocol.ClusterState;
import org.corfudb.protocols.wireprotocol.NodeState;
import org.corfudb.protocols.wireprotocol.SequencerMetrics;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.clients.IClientRouter;
import org.corfudb.runtime.clients.ManagementClient;
import org.corfudb.runtime.view.Layout;
import org.corfudb.util.CFUtils;
import org.corfudb.util.Sleep;

import javax.annotation.Nonnull;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * FailureDetector polls all the &quot;responsive members&quot; in the layout.
 * Responsive members: All endpoints that are responding to heartbeats. This list can be derived by
 * excluding unresponsiveServers from all endpoints.
 * For every poll method call invoked, it starts a polling round and generates a poll report.
 * Each polling round comprises of &quot;failureThreshold&quot; number of iterations.
 * - We asynchronously poll every known responsive member in the layout.
 * - Poll result aggregation.
 * - If we complete an iteration without detecting failures, we end the round successfully.
 * The management Server ensures only one instance of this class and hence this is NOT thread safe.
 * Created by zlokhandwala on 11/29/17.
 */
<span class="nc" id="L47">@Slf4j</span>
public class FailureDetector implements IDetector {


    /**
     * Number of iterations to execute to detect a failure in a round.
     */
<span class="nc" id="L54">    @Getter</span>
<span class="nc" id="L55">    @Setter</span>
    private int failureThreshold = 3;

    @NonNull
    private final HeartbeatCounter heartbeatCounter;

    @NonNull
    private final String localEndpoint;

<span class="nc" id="L64">    @NonNull</span>
    @Default
<span class="nc bnc" id="L66" title="All 2 branches missed.">    @Setter</span>
<span class="nc" id="L67">    private NetworkStretcher networkStretcher = NetworkStretcher.builder().build();</span>

<span class="nc" id="L69">    public FailureDetector(HeartbeatCounter heartbeatCounter, String localEndpoint) {</span>
<span class="nc" id="L70">        this.heartbeatCounter = heartbeatCounter;</span>
<span class="nc" id="L71">        this.localEndpoint = localEndpoint;</span>
<span class="nc" id="L72">    }</span>

    /**
     * Executes the policy once.
     * Checks for changes in the layout.
     * Then polls all the servers generates pollReport.
     *
     * @param layout Current Layout
     */
    public PollReport poll(
<span class="nc bnc" id="L82" title="All 2 branches missed.">            @Nonnull Layout layout, @Nonnull CorfuRuntime corfuRuntime, @NonNull SequencerMetrics sequencerMetrics) {</span>

<span class="nc" id="L84">        log.trace(&quot;Poll report. Layout: {}&quot;, layout);</span>

        Map&lt;String, IClientRouter&gt; routerMap;

        // Collect and set all responsive servers in the members array.
<span class="nc" id="L89">        Set&lt;String&gt; allServers = layout.getAllServers();</span>

        // Set up arrays for routers to the endpoints.
<span class="nc" id="L92">        routerMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L93">        allServers.forEach(s -&gt; {</span>
<span class="nc" id="L94">            IClientRouter router = corfuRuntime.getRouter(s);</span>
<span class="nc" id="L95">            router.setTimeoutResponse(networkStretcher.getCurrentPeriod().toMillis());</span>
<span class="nc" id="L96">            routerMap.put(s, router);</span>
<span class="nc" id="L97">        });</span>

        // Perform polling of all responsive servers.
<span class="nc" id="L100">        return pollRound(</span>
<span class="nc" id="L101">                layout.getEpoch(), allServers, routerMap, sequencerMetrics,</span>
<span class="nc" id="L102">                ImmutableList.copyOf(layout.getUnresponsiveServers())</span>
        );
    }

    /**
     * PollRound consists of iterations. In each iteration, the FailureDetector pings all the
     * responsive nodes in the layout and also collects their {@link NodeState}-s to provide {@link ClusterState}.
     * Failure detector collect a number of {@link PollReport}-s equals to failureThreshold number then
     * aggregates final {@link PollReport}.
     * Aggregation step:
     * - go through all reports
     * - aggregate all wrong epochs from all intermediate poll reports then remove all responsive nodes from the list.
     * If wrongEpochsAggregated variable still contains wrong epochs
     * then it will be corrected by {@link RemoteMonitoringService}
     * - Aggregate connected and failed nodes from all reports
     * - Timeouts tuning
     * - provide a poll report based on latest pollIteration report and aggregated values
     *
     * @return Poll Report with detected failed nodes and out of phase epoch nodes.
     */
    @VisibleForTesting
    PollReport pollRound(
            long epoch, Set&lt;String&gt; allServers, Map&lt;String, IClientRouter&gt; router,
            SequencerMetrics sequencerMetrics, ImmutableList&lt;String&gt; layoutUnresponsiveNodes) {

<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (failureThreshold &lt; 1) {</span>
<span class="nc" id="L128">            throw new IllegalStateException(&quot;Invalid failure threshold&quot;);</span>
        }

<span class="nc" id="L131">        List&lt;PollReport&gt; reports = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        for (int iteration = 0; iteration &lt; failureThreshold; iteration++) {</span>
<span class="nc" id="L133">            PollReport currReport = pollIteration(</span>
                    allServers, router, epoch, sequencerMetrics, layoutUnresponsiveNodes
            );
<span class="nc" id="L136">            reports.add(currReport);</span>

<span class="nc" id="L138">            Duration restInterval = networkStretcher.getRestInterval(currReport.getElapsedTime());</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (!currReport.getFailedNodes().isEmpty()) {</span>
<span class="nc" id="L140">                networkStretcher.modifyIterationTimeouts();</span>

<span class="nc" id="L142">                Set&lt;String&gt; allReachableNodes = currReport.getAllReachableNodes();</span>
<span class="nc" id="L143">                tuneRoutersResponseTimeout(</span>
<span class="nc" id="L144">                        router, allReachableNodes, networkStretcher.getCurrentPeriod()</span>
                );
            }

            // Sleep for the provided poll interval before starting the next iteration
<span class="nc" id="L149">            Sleep.sleepUninterruptibly(restInterval);</span>
        }

        //Aggregation step
<span class="nc" id="L153">        Map&lt;String, Long&gt; wrongEpochsAggregated = new HashMap&lt;&gt;();</span>
<span class="nc" id="L154">        Set&lt;String&gt; connectedNodesAggregated = new HashSet&lt;&gt;();</span>
<span class="nc" id="L155">        Set&lt;String&gt; failedNodesAggregated = new HashSet&lt;&gt;();</span>

<span class="nc" id="L157">        reports.forEach(report -&gt; {</span>
            //Calculate wrong epochs
<span class="nc" id="L159">            wrongEpochsAggregated.putAll(report.getWrongEpochs());</span>
<span class="nc" id="L160">            report.getReachableNodes().forEach(wrongEpochsAggregated::remove);</span>

            //Aggregate failed/connected nodes
<span class="nc" id="L163">            connectedNodesAggregated.addAll(report.getReachableNodes());</span>
<span class="nc" id="L164">            failedNodesAggregated.addAll(report.getFailedNodes());</span>
<span class="nc" id="L165">        });</span>

<span class="nc" id="L167">        failedNodesAggregated.removeAll(connectedNodesAggregated);</span>

<span class="nc" id="L169">        Set&lt;String&gt; allConnectedNodes = Sets.union(connectedNodesAggregated, wrongEpochsAggregated.keySet());</span>

<span class="nc" id="L171">        tunePollReportTimeouts(router, failedNodesAggregated, allConnectedNodes);</span>

<span class="nc" id="L173">        List&lt;ClusterState&gt; clusterStates = reports.stream()</span>
<span class="nc" id="L174">                .map(PollReport::getClusterState)</span>
<span class="nc" id="L175">                .collect(Collectors.toList());</span>

<span class="nc" id="L177">        ClusterStateAggregator aggregator = ClusterStateAggregator.builder()</span>
<span class="nc" id="L178">                .localEndpoint(localEndpoint)</span>
<span class="nc" id="L179">                .clusterStates(clusterStates)</span>
<span class="nc" id="L180">                .unresponsiveNodes(layoutUnresponsiveNodes)</span>
<span class="nc" id="L181">                .build();</span>

<span class="nc" id="L183">        Duration totalElapsedTime = reports.stream()</span>
<span class="nc" id="L184">                .map(PollReport::getElapsedTime)</span>
<span class="nc" id="L185">                .reduce(Duration.ZERO, Duration::plus);</span>

<span class="nc" id="L187">        final ClusterState aggregatedClusterState = aggregator.getAggregatedState();</span>
<span class="nc" id="L188">        return PollReport.builder()</span>
<span class="nc" id="L189">                .pollEpoch(epoch)</span>
<span class="nc" id="L190">                .elapsedTime(totalElapsedTime)</span>
<span class="nc" id="L191">                .pingResponsiveServers(aggregatedClusterState.getPingResponsiveNodes())</span>
<span class="nc" id="L192">                .wrongEpochs(ImmutableMap.copyOf(wrongEpochsAggregated))</span>
<span class="nc" id="L193">                .clusterState(aggregatedClusterState)</span>
<span class="nc" id="L194">                .build();</span>
    }

    /**
     * We can try to scale back the network latency time after every poll round.
     * If there are no failures, after a few rounds our polling period converges back to initPeriodDuration.
     *
     * @param clientRouters     clientRouters
     * @param failedNodes       list of failed nodes
     * @param allConnectedNodes all connected nodes
     */
    private void tunePollReportTimeouts(
            Map&lt;String, IClientRouter&gt; clientRouters, Set&lt;String&gt; failedNodes,
            Set&lt;String&gt; allConnectedNodes) {

<span class="nc" id="L209">        networkStretcher.modifyDecreasedPeriod();</span>
<span class="nc" id="L210">        tuneRoutersResponseTimeout(</span>
<span class="nc" id="L211">                clientRouters, allConnectedNodes, networkStretcher.getCurrentPeriod()</span>
        );

        // Reset the timeout of all the failed nodes to the max value to set a longer
        // timeout period to detect their response.
<span class="nc" id="L216">        tuneRoutersResponseTimeout(clientRouters, failedNodes, networkStretcher.getMaxPeriod());</span>
<span class="nc" id="L217">    }</span>

    /**
     * Poll iteration step, provides a {@link PollReport} composed from pings and {@link NodeState}-s collected by
     * this node from the cluster.
     * Algorithm:
     * - ping all nodes
     * - collect all node states
     * - collect wrong epochs
     * - collect connected/failed nodes
     * - calculate if current layout slot is unfilled
     * - build poll report
     *
     * @param allServers              all servers in the cluster
     * @param clientRouters           client clientRouters
     * @param epoch                   current epoch
     * @param sequencerMetrics        metrics
     * @param layoutUnresponsiveNodes all unresponsive servers in a cluster
     * @return a poll report
     */
    private PollReport pollIteration(
            Set&lt;String&gt; allServers, Map&lt;String, IClientRouter&gt; clientRouters, long epoch,
            SequencerMetrics sequencerMetrics, ImmutableList&lt;String&gt; layoutUnresponsiveNodes) {

<span class="nc" id="L241">        log.trace(&quot;Poll iteration. Epoch: {}&quot;, epoch);</span>

<span class="nc" id="L243">        long start = System.currentTimeMillis();</span>

<span class="nc" id="L245">        ClusterStateCollector clusterCollector = ClusterStateCollector.builder()</span>
<span class="nc" id="L246">                .localEndpoint(localEndpoint)</span>
<span class="nc" id="L247">                .clusterState(pollAsync(allServers, clientRouters, epoch))</span>
<span class="nc" id="L248">                .heartbeatCounter(heartbeatCounter)</span>
<span class="nc" id="L249">                .build();</span>

        //Cluster state internal map.
<span class="nc" id="L252">        ClusterState clusterState = clusterCollector.collectClusterState(</span>
                epoch, layoutUnresponsiveNodes, sequencerMetrics
        );

<span class="nc" id="L256">        Duration elapsedTime = Duration.ofMillis(System.currentTimeMillis() - start);</span>

<span class="nc" id="L258">        return PollReport.builder()</span>
<span class="nc" id="L259">                .pollEpoch(epoch)</span>
<span class="nc" id="L260">                .pingResponsiveServers(clusterState.getPingResponsiveNodes())</span>
<span class="nc" id="L261">                .wrongEpochs(clusterCollector.collectWrongEpochs())</span>
<span class="nc" id="L262">                .clusterState(clusterState)</span>
<span class="nc" id="L263">                .elapsedTime(elapsedTime)</span>
<span class="nc" id="L264">                .build();</span>
    }

    /**
     * Poll all members servers once asynchronously and store their futures in
     * pollCompletableFutures.
     *
     * @param allServers    All active members in the layout.
     * @param clientRouters Map of routers for all active members.
     * @param epoch         Current epoch for the polling round to stamp the ping messages.
     * @return Map of Completable futures for the pings.
     */
    private Map&lt;String, CompletableFuture&lt;NodeState&gt;&gt; pollAsync(
            Set&lt;String&gt; allServers, Map&lt;String, IClientRouter&gt; clientRouters, long epoch) {
        // Poll servers for health.  All ping activity will happen in the background.
<span class="nc" id="L279">        Map&lt;String, CompletableFuture&lt;NodeState&gt;&gt; clusterState = new HashMap&lt;&gt;();</span>
<span class="nc" id="L280">        allServers.forEach(s -&gt; {</span>
            try {
<span class="nc" id="L282">                clusterState.put(s, new ManagementClient(clientRouters.get(s), epoch).sendNodeStateRequest());</span>
<span class="nc" id="L283">            } catch (Exception e) {</span>
<span class="nc" id="L284">                CompletableFuture&lt;NodeState&gt; cf = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L285">                cf.completeExceptionally(e);</span>
<span class="nc" id="L286">                clusterState.put(s, cf);</span>
<span class="nc" id="L287">            }</span>
<span class="nc" id="L288">        });</span>

        //Ping all nodes in parallel.
        //Possible exceptions are held by their CompletableFutures. They will be handled in pollIteration method
        try {
<span class="nc" id="L293">            CFUtils.allOf(clusterState.values()).join();</span>
<span class="nc" id="L294">        } catch (Exception ex) {</span>
            //ignore
<span class="nc" id="L296">        }</span>

<span class="nc" id="L298">        return clusterState;</span>
    }

    /**
     * Set the timeoutResponse for all the routers connected to the given endpoints with the
     * given value.
     *
     * @param endpoints Router endpoints.
     * @param timeout   New timeout value.
     */
    private void tuneRoutersResponseTimeout(
            Map&lt;String, IClientRouter&gt; clientRouters, Set&lt;String&gt; endpoints, Duration timeout) {

<span class="nc" id="L311">        log.trace(&quot;Tuning router timeout responses for endpoints:{} to {}ms&quot;, endpoints, timeout);</span>
<span class="nc" id="L312">        endpoints.forEach(server -&gt; {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (clientRouters.get(server) != null) {</span>
<span class="nc" id="L314">                clientRouters.get(server).setTimeoutResponse(timeout.toMillis());</span>
            }
<span class="nc" id="L316">        });</span>
<span class="nc" id="L317">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>