<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LogMetadata.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure.log</a> &gt; <span class="el_source">LogMetadata.java</span></div><h1>LogMetadata.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure.log;

import lombok.Getter;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.logprotocol.CheckpointEntry;
import org.corfudb.protocols.wireprotocol.LogData;
import org.corfudb.runtime.view.stream.StreamAddressSpace;
import org.corfudb.runtime.view.Address;
import org.roaringbitmap.longlong.Roaring64NavigableMap;

import javax.annotation.concurrent.NotThreadSafe;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * A container object that holds log tail offsets and the global
 * log tail that has been seen. Note that holes don't belong to any
 * stream therefore the globalTail needs to be tracked separately.
 *
 * &lt;p&gt;Created by maithem on 10/15/18.
 */

@NotThreadSafe
<span class="nc" id="L27">@ToString</span>
<span class="fc" id="L28">@Slf4j</span>
public class LogMetadata {

<span class="fc" id="L31">    @Getter</span>
    private volatile long globalTail;

<span class="fc" id="L34">    @Getter</span>
    private final Map&lt;UUID, StreamAddressSpace&gt; streamsAddressSpaceMap;

<span class="fc" id="L37">    @Getter</span>
    private final Map&lt;UUID, Long&gt; streamTails;

<span class="fc" id="L40">    public LogMetadata() {</span>
<span class="fc" id="L41">        this.globalTail = Address.NON_ADDRESS;</span>
<span class="fc" id="L42">        this.streamTails = new HashMap&lt;&gt;();</span>
<span class="fc" id="L43">        this.streamsAddressSpaceMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L44">    }</span>

    public void update(List&lt;LogData&gt; entries) {
<span class="fc bfc" id="L47" title="All 2 branches covered.">        for (LogData entry : entries) {</span>
            // This API is only used on range writes for state transfer
            // On state transfer we need to inspect checkpoint streams (initialize = true),
            // to avoid losing data for streams that are completely checkpointed (no actual
            // log entry for the regular stream is present in the log).
<span class="fc" id="L52">            update(entry, true);</span>
<span class="fc" id="L53">        }</span>
<span class="fc" id="L54">    }</span>

    public void update(LogData entry, boolean initialize) {
<span class="fc" id="L57">        long entryAddress = entry.getGlobalAddress();</span>
        // Update log tail
<span class="fc" id="L59">        updateGlobalTail(entryAddress);</span>
        // For every stream present in entry update stream tail
<span class="fc bfc" id="L61" title="All 2 branches covered.">        for (UUID streamId : entry.getStreams()) {</span>
<span class="fc" id="L62">            updateStreamSpace(streamId, entryAddress);</span>
<span class="fc" id="L63">        }</span>

        // We should also consider checkpoint metadata while updating the tails and stream trim mark.
        // This is important because there could be streams which data is completely checkpointed,
        // i.e., no actual entries on the regular stream but only on the checkpoint stream.
        // If those streams are not updated with this info, then clients would observe those
        // streams as empty, which is not correct.
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (entry.hasCheckpointMetadata()) {</span>
<span class="fc" id="L71">            updateFromCheckpoint(entry, initialize);</span>
        }
<span class="fc" id="L73">    }</span>

    /**
     * Updates relevant info of a stream's space, concretely:
     * 1. Stream's tail, i.e., the last observed address for the stream.
     * 2. Stream's address space, i.e., space of all observed updates for the stream.
     *
     * @param streamId stream identifier.
     * @param entryAddress stream address.
     */
    private void updateStreamSpace(UUID streamId, long entryAddress) {
        // Update stream tails
<span class="fc" id="L85">        long currentStreamTail = streamTails.getOrDefault(streamId, Address.NON_ADDRESS);</span>
<span class="fc" id="L86">        streamTails.put(streamId, Math.max(currentStreamTail, entryAddress));</span>

        // Update stream address space (used for sequencer recovery), add this entry as a valid address for this stream.
<span class="fc" id="L89">        streamsAddressSpaceMap.compute(streamId, (id, addressSpace) -&gt; {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (addressSpace == null) {</span>
<span class="fc" id="L91">                Roaring64NavigableMap addressMap = new Roaring64NavigableMap();</span>
<span class="fc" id="L92">                addressMap.addLong(entryAddress);</span>
                // Note: stream trim mark is initialized to -6
                // its value will be computed as checkpoints for this stream are found in the log.
                // The presence of a checkpoint provides a valid trim mark for a stream.
<span class="fc" id="L96">                return new StreamAddressSpace(Address.NON_EXIST, addressMap);</span>
            }
<span class="fc" id="L98">            addressSpace.addAddress(entryAddress);</span>
<span class="fc" id="L99">            return addressSpace;</span>
        });
<span class="fc" id="L101">    }</span>

    /**
     * Update's relevant info of a stream's space from a checkpoint, concretely:
     * 1. Stream tail for those stream's that have all updates within a checkpoint.
     * 2. Stream trim mark, i.e., last observed address for a stream subsumed by a checkpoint.
     *
     * @param entry log entry
     * @param initialize true, if called on log unit initialization (full scan)
     *                   false, otherwise.
     */
    private void updateFromCheckpoint(LogData entry, boolean initialize) {
<span class="fc" id="L113">        UUID streamId = entry.getCheckpointedStreamId();</span>
<span class="fc" id="L114">        long lastUpdateToStream = entry.getCheckpointedStreamStartLogAddress();</span>

<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (Address.isAddress(lastUpdateToStream)) {</span>
            // 1. Update stream tail
<span class="fc" id="L118">            long currentStreamTail = streamTails.getOrDefault(streamId, Address.NON_ADDRESS);</span>
<span class="fc" id="L119">            streamTails.put(streamId, Math.max(currentStreamTail, lastUpdateToStream));</span>

            // 2. Update stream trim mark
            // This is only required on initialization as on all other paths trim mark will be set by
            // explicit trimming.
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if (initialize) {</span>
                // The trim mark is part of the address space information and is also required
                // so clients can observe updates to streams that have been completely checkpointed.
                // For instance, an empty address space with a stream trim mark != -6, requires data to be
                // loaded from a checkpoint (vs. no data ever written to this stream).

                // If we hit a checkpoint END record we can use this info to compute the stream trim mark,
                // i.e., last observed update to the stream that has already been checkpointed, hence
                // can be safely trimmed from the log.
<span class="nc bnc" id="L133" title="All 2 branches missed.">                if (entry.getCheckpointType() == CheckpointEntry.CheckpointEntryType.END) {</span>
<span class="nc" id="L134">                    streamsAddressSpaceMap.compute(streamId, (id, addressSpace) -&gt; {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                        if (addressSpace == null) {</span>
                            // If this entry still does not exist, means no updates have been observed for
                            // this stream yet. We can initialize the trim mark to the last observed update by the
                            // checkpoint. If further entries are observed they will be added to the address space.
<span class="nc" id="L139">                            return new StreamAddressSpace(lastUpdateToStream, new Roaring64NavigableMap());</span>
                        }
                        // We will hold the maximum of these observed updates as the stream trim mark (highest
                        // checkpointed address), as this guarantees data is available in a checkpoint (safe trim mark).
<span class="nc" id="L143">                        addressSpace.setTrimMark(Long.max(addressSpace.getTrimMark(), lastUpdateToStream));</span>
<span class="nc" id="L144">                        return addressSpace;</span>
                    });
                }
            }
        }
<span class="fc" id="L149">    }</span>

    public void updateGlobalTail(long newTail) {
<span class="fc" id="L152">        globalTail = Math.max(globalTail, newTail);</span>
<span class="fc" id="L153">    }</span>

    public void prefixTrim(long address) {
<span class="fc" id="L156">        log.info(&quot;prefixTrim: trim stream address maps up to address {}&quot;, address);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        for (Map.Entry&lt;UUID, StreamAddressSpace&gt; streamAddressMap : streamsAddressSpaceMap.entrySet()) {</span>
<span class="fc" id="L158">            log.trace(&quot;prefixTrim: trim address space for stream {} up to trim mark {}&quot;,</span>
<span class="fc" id="L159">                    streamAddressMap.getKey(), address);</span>
<span class="fc" id="L160">            streamAddressMap.getValue().trim(address);</span>
<span class="fc" id="L161">        }</span>
<span class="fc" id="L162">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>