<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LogUnitServer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">LogUnitServer.java</span></div><h1>LogUnitServer.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import com.google.common.annotations.VisibleForTesting;
import io.netty.channel.ChannelHandlerContext;
import lombok.Builder;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.infrastructure.log.InMemoryStreamLog;
import org.corfudb.infrastructure.log.StreamLog;
import org.corfudb.infrastructure.log.StreamLogCompaction;
import org.corfudb.infrastructure.log.StreamLogFiles;
import org.corfudb.protocols.wireprotocol.CorfuMsg;
import org.corfudb.protocols.wireprotocol.CorfuMsgType;
import org.corfudb.protocols.wireprotocol.CorfuPayloadMsg;
import org.corfudb.protocols.wireprotocol.ExceptionMsg;
import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.protocols.wireprotocol.KnownAddressRequest;
import org.corfudb.protocols.wireprotocol.LogData;
import org.corfudb.protocols.wireprotocol.MultipleReadRequest;
import org.corfudb.protocols.wireprotocol.PriorityLevel;
import org.corfudb.protocols.wireprotocol.RangeWriteMsg;
import org.corfudb.protocols.wireprotocol.ReadRequest;
import org.corfudb.protocols.wireprotocol.ReadResponse;
import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;
import org.corfudb.protocols.wireprotocol.TailsRequest;
import org.corfudb.protocols.wireprotocol.TailsResponse;
import org.corfudb.protocols.wireprotocol.TrimRequest;
import org.corfudb.protocols.wireprotocol.WriteRequest;
import org.corfudb.runtime.exceptions.DataCorruptionException;
import org.corfudb.runtime.exceptions.DataOutrankedException;
import org.corfudb.runtime.exceptions.LogUnitException;
import org.corfudb.runtime.exceptions.OverwriteException;
import org.corfudb.runtime.exceptions.TrimmedException;
import org.corfudb.runtime.exceptions.ValueAdoptedException;
import org.corfudb.runtime.exceptions.WrongEpochException;
import org.corfudb.runtime.view.stream.StreamAddressSpace;
import org.corfudb.util.Utils;

import java.lang.invoke.MethodHandles;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.corfudb.infrastructure.BatchWriterOperation.Type.LOG_ADDRESS_SPACE_QUERY;
import static org.corfudb.infrastructure.BatchWriterOperation.Type.PREFIX_TRIM;
import static org.corfudb.infrastructure.BatchWriterOperation.Type.RANGE_WRITE;
import static org.corfudb.infrastructure.BatchWriterOperation.Type.RESET;
import static org.corfudb.infrastructure.BatchWriterOperation.Type.SEAL;
import static org.corfudb.infrastructure.BatchWriterOperation.Type.TAILS_QUERY;
import static org.corfudb.infrastructure.BatchWriterOperation.Type.WRITE;


/**
 * Created by mwei on 12/10/15.
 *
 * &lt;p&gt;A Log Unit Server, which is responsible for providing the persistent storage for the Corfu
 * Distributed Shared Log.
 *
 * &lt;p&gt;All reads and writes go through a cache. For persistence, every 10,000 log entries are written
 * to individual files (logs), which are represented as FileHandles. Each FileHandle contains a
 * pointer to the tail of the file, a memory-mapped file channel, and a set of addresses known
 * to be in the file. To append an entry, the pointer to the tail is first extended to the
 * length of the entry, and the entry is added to the set of known addresses. A header is
 * written, which consists of the ASCII characters LE, followed by a set of flags, the log unit
 * address, the size of the entry, then the metadata size, metadata and finally the entry itself
 * . When the entry is complete, a written flag is set in the flags field.
 */
<span class="fc" id="L74">@Slf4j</span>
public class LogUnitServer extends AbstractServer {

    /**
     * The options map.
     */
    private final LogUnitServerConfig config;

    /**
     * The server context of the node.
     */
    private final ServerContext serverContext;

    /**
     * Handler for this server.
     */
<span class="fc" id="L90">    @Getter</span>
<span class="fc" id="L91">    private final CorfuMsgHandler handler = CorfuMsgHandler.generateHandler(MethodHandles.lookup(), this);</span>

    /**
     * This cache services requests for data at various addresses. In a memory implementation,
     * it is not backed by anything, but in a disk implementation it is backed by persistent
     * storage.
     */
    private final LogUnitServerCache dataCache;
    private final StreamLog streamLog;
    private final StreamLogCompaction logCleaner;
    private final BatchProcessor batchWriter;

    private ExecutorService executor;

    @Override
    public ExecutorService getExecutor(CorfuMsgType corfuMsgType) {
<span class="fc" id="L107">        return executor;</span>
    }

    @Override
    public List&lt;ExecutorService&gt; getExecutors() {
<span class="fc" id="L112">        return Collections.singletonList(executor);</span>
    }

    /**
     * Returns a new LogUnitServer.
     *
     * @param serverContext context object providing settings and objects
     */
<span class="fc" id="L120">    public LogUnitServer(ServerContext serverContext) {</span>
<span class="fc" id="L121">        this.serverContext = serverContext;</span>
<span class="fc" id="L122">        this.config = LogUnitServerConfig.parse(serverContext.getServerConfig());</span>
<span class="fc" id="L123">        executor = Executors.newFixedThreadPool(serverContext.getLogunitThreadCount(),</span>
                new ServerThreadFactory(&quot;LogUnit-&quot;, new ServerThreadFactory.ExceptionHandler()));

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (config.isMemoryMode()) {</span>
<span class="fc" id="L127">            log.warn(&quot;Log unit opened in-memory mode (Maximum size={}). &quot;</span>
                    + &quot;This should be run for testing purposes only. &quot;
                    + &quot;If you exceed the maximum size of the unit, old entries will be &quot;
                    + &quot;AUTOMATICALLY trimmed. &quot;
                    + &quot;The unit WILL LOSE ALL DATA if it exits.&quot;, Utils
<span class="fc" id="L132">                    .convertToByteStringRepresentation(config.getMaxCacheSize()));</span>
<span class="fc" id="L133">            streamLog = new InMemoryStreamLog();</span>
        } else {
<span class="fc" id="L135">            streamLog = new StreamLogFiles(serverContext, config.isNoVerify());</span>
        }

<span class="fc" id="L138">        dataCache = new LogUnitServerCache(config, streamLog);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        batchWriter = new BatchProcessor(streamLog, serverContext.getServerEpoch(), !config.isNoSync());</span>

<span class="fc" id="L141">        logCleaner = new StreamLogCompaction(streamLog, 10, 45, TimeUnit.MINUTES, ServerContext.SHUTDOWN_TIMER);</span>
<span class="fc" id="L142">    }</span>

    /**
     * Service an incoming request for maximum global address the log unit server has written.
     */
    @ServerHandler(type = CorfuMsgType.TAIL_REQUEST)
    public void handleTailRequest(CorfuPayloadMsg&lt;TailsRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L149">        log.debug(&quot;handleTailRequest: received a tail request {}&quot;, msg);</span>
<span class="fc" id="L150">        batchWriter.&lt;TailsResponse&gt;addTask(TAILS_QUERY, msg)</span>
<span class="fc" id="L151">                .thenAccept(tailsResp -&gt; r.sendResponse(ctx, msg, CorfuMsgType.TAIL_RESPONSE.payloadMsg(tailsResp)))</span>
<span class="fc" id="L152">                .exceptionally(ex -&gt; {</span>
<span class="nc" id="L153">                    handleException(ex, ctx, msg, r);</span>
<span class="nc" id="L154">                    return null;</span>
                });
<span class="fc" id="L156">    }</span>

    /**
     * Service an incoming request for log address space, i.e., the map of addresses for every stream in the log.
     * This is used on sequencer bootstrap to provide the address maps for initialization.
     */
    @ServerHandler(type = CorfuMsgType.LOG_ADDRESS_SPACE_REQUEST)
    public void handleLogAddressSpaceRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L164">        CorfuPayloadMsg&lt;Void&gt; payloadMsg = new CorfuPayloadMsg&lt;&gt;();</span>
<span class="fc" id="L165">        payloadMsg.copyBaseFields(msg);</span>
<span class="fc" id="L166">        log.debug(&quot;handleLogAddressSpaceRequest: received a log address space request {}&quot;, msg);</span>
<span class="fc" id="L167">        batchWriter.&lt;StreamsAddressResponse&gt;addTask(LOG_ADDRESS_SPACE_QUERY, payloadMsg)</span>
<span class="fc" id="L168">                .thenAccept(tailsResp -&gt; r.sendResponse(ctx, msg,</span>
<span class="fc" id="L169">                        CorfuMsgType.LOG_ADDRESS_SPACE_RESPONSE.payloadMsg(tailsResp)))</span>
<span class="fc" id="L170">                .exceptionally(ex -&gt; {</span>
<span class="fc" id="L171">                    handleException(ex, ctx, payloadMsg, r);</span>
<span class="fc" id="L172">                    return null;</span>
                });
<span class="fc" id="L174">    }</span>

    /**
     * Service an incoming request to retrieve the starting address of this logging unit.
     */
    @ServerHandler(type = CorfuMsgType.TRIM_MARK_REQUEST)
    public void handleTrimMarkRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L181">        log.debug(&quot;handleTrimMarkRequest: received a trim mark request {}&quot;, msg);</span>
<span class="fc" id="L182">        r.sendResponse(ctx, msg, CorfuMsgType.TRIM_MARK_RESPONSE.payloadMsg(streamLog.getTrimMark()));</span>
<span class="fc" id="L183">    }</span>

    /**
     * A helper function that maps an exception to the appropriate response message.
     */
    void handleException(Throwable ex, ChannelHandlerContext ctx, CorfuPayloadMsg msg, IServerRouter r) {
<span class="fc" id="L189">        log.trace(&quot;handleException: handling exception {} for {}&quot;, ex, msg);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (ex.getCause() instanceof WrongEpochException) {</span>
<span class="fc" id="L191">            WrongEpochException wee = (WrongEpochException) ex.getCause();</span>
<span class="fc" id="L192">            r.sendResponse(ctx, msg, new CorfuPayloadMsg&lt;&gt;(CorfuMsgType.WRONG_EPOCH, wee.getCorrectEpoch()));</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        } else if (ex.getCause() instanceof OverwriteException) {</span>
<span class="fc" id="L194">            OverwriteException owe = (OverwriteException) ex.getCause();</span>
<span class="fc" id="L195">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_OVERWRITE</span>
<span class="fc" id="L196">                    .payloadMsg(owe.getOverWriteCause().getId()));</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        } else if (ex.getCause() instanceof DataOutrankedException) {</span>
<span class="fc" id="L198">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_OUTRANKED.msg());</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        } else if (ex.getCause() instanceof ValueAdoptedException) {</span>
<span class="fc" id="L200">            ValueAdoptedException vae = (ValueAdoptedException) ex.getCause();</span>
<span class="fc" id="L201">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_VALUE_ADOPTED.payloadMsg(vae.getReadResponse()));</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        } else if (ex.getCause() instanceof TrimmedException) {</span>
<span class="nc" id="L203">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_TRIMMED.msg());</span>
        } else {
<span class="fc" id="L205">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_SERVER_EXCEPTION.payloadMsg(new ExceptionMsg(ex)));</span>
<span class="fc" id="L206">            throw new LogUnitException(ex);</span>
        }
<span class="fc" id="L208">    }</span>

    /**
     * Service an incoming write request.
     */
    @ServerHandler(type = CorfuMsgType.WRITE)
    public void write(CorfuPayloadMsg&lt;WriteRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L215">        LogData logData = (LogData) msg.getPayload().getData();</span>
<span class="fc" id="L216">        log.debug(&quot;log write: type: {}, address: {}, streams: {}&quot;, logData.getType(),</span>
<span class="fc" id="L217">                logData.getToken(), logData.getBackpointerMap());</span>

        // Its not clear that making all holes high priority is the right thing to do, but since
        // some reads will block until a hole is filled this is required (i.e. bypass quota checks)
        // because the requirement is to allow reads, but only block writes once the quota is exhausted
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (logData.isHole()) {</span>
<span class="fc" id="L223">            msg.setPriorityLevel(PriorityLevel.HIGH);</span>
        }

<span class="fc" id="L226">        batchWriter.addTask(WRITE, msg)</span>
<span class="fc" id="L227">                .thenRunAsync(() -&gt; {</span>
<span class="fc" id="L228">                    dataCache.put(msg.getPayload().getGlobalAddress(), logData);</span>
<span class="fc" id="L229">                    r.sendResponse(ctx, msg, CorfuMsgType.WRITE_OK.msg());</span>
<span class="fc" id="L230">                }, executor).exceptionally(ex -&gt; {</span>
<span class="fc" id="L231">                    handleException(ex, ctx, msg, r);</span>
<span class="fc" id="L232">                    return null;</span>
        });
<span class="fc" id="L234">    }</span>

    /**
     * Services incoming range write calls.
     */
    @ServerHandler(type = CorfuMsgType.RANGE_WRITE)
    public void rangeWrite(CorfuPayloadMsg&lt;RangeWriteMsg&gt; msg,
                           ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L242">        List&lt;LogData&gt; range = msg.getPayload().getEntries();</span>
<span class="fc" id="L243">        log.debug(&quot;rangeWrite: Writing {} entries [{}-{}]&quot;, range.size(),</span>
<span class="fc" id="L244">                range.get(0).getGlobalAddress(), range.get(range.size() - 1).getGlobalAddress());</span>

<span class="fc" id="L246">        batchWriter.addTask(RANGE_WRITE, msg)</span>
<span class="fc" id="L247">                .thenRun(() -&gt; r.sendResponse(ctx, msg, CorfuMsgType.WRITE_OK.msg()))</span>
<span class="fc" id="L248">                .exceptionally(ex -&gt; {</span>
<span class="fc" id="L249">                    handleException(ex, ctx, msg, r);</span>
<span class="fc" id="L250">                    return null;</span>
                });
<span class="fc" id="L252">    }</span>

    /**
     * Perform a prefix trim.
     * Here the token is not used to perform the trim as the epoch at which the checkpoint was completed
     * might be old. Hence, we use the msg epoch to perform the trim. This should be safe provided that the
     * trim is performed only on the token provided by the CheckpointWriter which ensures that the checkpoint
     * was persisted. Using any other address to perform a trim can cause data loss.
     */
    @ServerHandler(type = CorfuMsgType.PREFIX_TRIM)
    private void prefixTrim(CorfuPayloadMsg&lt;TrimRequest&gt; msg, ChannelHandlerContext ctx,
                            IServerRouter r) {
<span class="fc" id="L264">        log.debug(&quot;prefixTrim: trimming prefix to {}&quot;, msg.getPayload().getAddress());</span>
<span class="fc" id="L265">        batchWriter.addTask(PREFIX_TRIM, msg)</span>
<span class="fc" id="L266">                .thenRun(() -&gt; r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg()))</span>
<span class="fc" id="L267">                .exceptionally(ex -&gt; {</span>
<span class="nc" id="L268">                    handleException(ex, ctx, msg, r);</span>
<span class="nc" id="L269">                    return null;</span>
                });
<span class="fc" id="L271">    }</span>

    @ServerHandler(type = CorfuMsgType.READ_REQUEST)
    public void read(CorfuPayloadMsg&lt;ReadRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L275">        long address = msg.getPayload().getAddress();</span>
<span class="fc" id="L276">        boolean cacheable = msg.getPayload().isCacheReadResult();</span>
<span class="fc" id="L277">        log.trace(&quot;read: {}, cacheable: {}&quot;, msg.getPayload().getAddress(), cacheable);</span>

<span class="fc" id="L279">        ReadResponse rr = new ReadResponse();</span>
        try {
<span class="fc" id="L281">            ILogData logData = dataCache.get(address, cacheable);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (logData == null) {</span>
<span class="fc" id="L283">                rr.put(address, LogData.getEmpty(address));</span>
            } else {
<span class="fc" id="L285">                rr.put(address, (LogData) logData);</span>
            }
<span class="fc" id="L287">            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));</span>
<span class="fc" id="L288">        } catch (DataCorruptionException e) {</span>
<span class="fc" id="L289">            log.error(&quot;Data corruption exception while reading address {}&quot;, address, e);</span>
<span class="fc" id="L290">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));</span>
<span class="fc" id="L291">        }</span>
<span class="fc" id="L292">    }</span>

    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)
    public void multiRead(CorfuPayloadMsg&lt;MultipleReadRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L296">        boolean cacheable = msg.getPayload().isCacheReadResult();</span>
<span class="fc" id="L297">        log.trace(&quot;multiRead: {}, cacheable: {}&quot;, msg.getPayload().getAddresses(), cacheable);</span>

<span class="fc" id="L299">        ReadResponse rr = new ReadResponse();</span>
        try {
<span class="fc bfc" id="L301" title="All 2 branches covered.">            for (Long address : msg.getPayload().getAddresses()) {</span>
<span class="fc" id="L302">                ILogData logData = dataCache.get(address, cacheable);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                if (logData == null) {</span>
<span class="fc" id="L304">                    rr.put(address, LogData.getEmpty(address));</span>
                } else {
<span class="fc" id="L306">                    rr.put(address, (LogData) logData);</span>
                }
<span class="fc" id="L308">            }</span>
<span class="fc" id="L309">            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));</span>
<span class="nc" id="L310">        } catch (DataCorruptionException e) {</span>
<span class="nc" id="L311">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());</span>
<span class="fc" id="L312">        }</span>
<span class="fc" id="L313">    }</span>

    /**
     * Handles requests for known entries in specified range.
     * This is used by state transfer to catch up only the remainder of the segment.
     */
    @ServerHandler(type = CorfuMsgType.KNOWN_ADDRESS_REQUEST)
    private void getKnownAddressesInRange(CorfuPayloadMsg&lt;KnownAddressRequest&gt; msg,
                                          ChannelHandlerContext ctx, IServerRouter r) {

<span class="fc" id="L323">        KnownAddressRequest request = msg.getPayload();</span>
        try {
<span class="fc" id="L325">            Set&lt;Long&gt; knownAddresses = streamLog</span>
<span class="fc" id="L326">                    .getKnownAddressesInRange(request.getStartRange(), request.getEndRange());</span>
<span class="fc" id="L327">            r.sendResponse(ctx, msg,</span>
<span class="fc" id="L328">                    CorfuMsgType.KNOWN_ADDRESS_RESPONSE.payloadMsg(knownAddresses));</span>
<span class="nc" id="L329">        } catch (Exception e) {</span>
<span class="nc" id="L330">            handleException(e, ctx, msg, r);</span>
<span class="fc" id="L331">        }</span>
<span class="fc" id="L332">    }</span>

    @ServerHandler(type = CorfuMsgType.COMPACT_REQUEST)
    private void handleCompactRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L336">        log.debug(&quot;handleCompactRequest: received a compact request {}&quot;, msg);</span>
<span class="fc" id="L337">        streamLog.compact();</span>
<span class="fc" id="L338">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="fc" id="L339">    }</span>

    @ServerHandler(type = CorfuMsgType.FLUSH_CACHE)
    private void handleFlushCacheRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="fc" id="L343">        log.debug(&quot;handleFlushCacheRequest: received a cache flush request {}&quot;, msg);</span>
<span class="fc" id="L344">        dataCache.invalidateAll();</span>
<span class="fc" id="L345">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="fc" id="L346">    }</span>

    /**
     * Seal the server with the epoch.
     * &lt;p&gt;
     * - A seal operation is inserted in the queue and then we wait to flush all operations
     * in the queue before this operation.
     * - All operations after this operation but stamped with an older epoch will be failed.
     */
    @Override
    public void sealServerWithEpoch(long epoch) {
<span class="fc" id="L357">        CorfuPayloadMsg&lt;Long&gt; msg = new CorfuPayloadMsg&lt;&gt;();</span>
<span class="fc" id="L358">        msg.setEpoch(epoch);</span>
<span class="fc" id="L359">        msg.setPriorityLevel(PriorityLevel.HIGH);</span>
        try {
<span class="fc" id="L361">            batchWriter.addTask(SEAL, msg).join();</span>
<span class="fc" id="L362">        } catch (CompletionException ce) {</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            if (ce.getCause() instanceof WrongEpochException) {</span>
                // The BaseServer expects to observe this exception,
                // when it happens, so it needs to be unwrapped
<span class="fc" id="L366">                throw (WrongEpochException) ce.getCause();</span>
            }
<span class="fc" id="L368">        }</span>
<span class="fc" id="L369">        log.info(&quot;LogUnit sealServerWithEpoch: sealed and flushed with epoch {}&quot;, epoch);</span>
<span class="fc" id="L370">    }</span>

    @Override
    public boolean isServerReadyToHandleMsg(CorfuMsg msg) {
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        return getState() == ServerState.READY;</span>
    }

    /**
     * Resets the log unit server via the BatchProcessor.
     * Warning: Clears all data.
     * &lt;p&gt;
     * - The epochWaterMark is set to prevent resetting log unit multiple times during
     * same epoch.
     * - After this the reset operation is inserted which resets and clears all data.
     * - Finally the cache is invalidated to purge the existing entries.
     */
    @ServerHandler(type = CorfuMsgType.RESET_LOGUNIT)
    private synchronized void resetLogUnit(CorfuPayloadMsg&lt;Long&gt; msg,
                                           ChannelHandlerContext ctx, IServerRouter r) {

        // Check if the reset request is with an epoch greater than the last reset epoch seen to
        // prevent multiple reset in the same epoch. and should be equal to the current router
        // epoch to prevent stale reset requests from wiping out the data.
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (msg.getPayload() &gt; serverContext.getLogUnitEpochWaterMark()</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                &amp;&amp; msg.getPayload() == serverContext.getServerEpoch()) {</span>
<span class="fc" id="L395">            serverContext.setLogUnitEpochWaterMark(msg.getPayload());</span>
<span class="fc" id="L396">            batchWriter.addTask(RESET, msg)</span>
<span class="fc" id="L397">                    .thenRun(() -&gt; {</span>
<span class="fc" id="L398">                        dataCache.invalidateAll();</span>
<span class="fc" id="L399">                        log.info(&quot;LogUnit Server Reset.&quot;);</span>
<span class="fc" id="L400">                        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="fc" id="L401">                    }).exceptionally(ex -&gt; {</span>
<span class="nc" id="L402">                        handleException(ex, ctx, msg, r);</span>
<span class="nc" id="L403">                        return null;</span>
                    });
        } else {
<span class="nc" id="L406">            log.info(&quot;LogUnit Server Reset request received but reset already done.&quot;);</span>
<span class="nc" id="L407">            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
        }
<span class="fc" id="L409">    }</span>



    /**
     * Shutdown the server.
     */
    @Override
    public void shutdown() {
<span class="fc" id="L418">        super.shutdown();</span>
<span class="fc" id="L419">        logCleaner.shutdown();</span>
<span class="fc" id="L420">        batchWriter.close();</span>
<span class="fc" id="L421">    }</span>

    @VisibleForTesting
    public LogUnitServerCache getDataCache() {
<span class="fc" id="L425">        return dataCache;</span>
    }

    @VisibleForTesting
    long getMaxCacheSize() {
<span class="fc" id="L430">        return config.getMaxCacheSize();</span>
    }

    @VisibleForTesting
    BatchProcessor getBatchWriter() {
<span class="fc" id="L435">        return batchWriter;</span>
    }

    // The following methods should only be used for unit tests, ideally the executor should be
    // final, but this &quot;hack&quot; is needed to now when a task as completed
    @VisibleForTesting
    void startHandler() {
<span class="fc" id="L442">        executor = Executors.newFixedThreadPool(serverContext.getLogunitThreadCount(),</span>
                new ServerThreadFactory(&quot;LogUnit-&quot;, new ServerThreadFactory.ExceptionHandler()));
<span class="fc" id="L444">    }</span>

    @VisibleForTesting
    void stopHandler() throws Exception {
<span class="fc" id="L448">        executor.shutdown();</span>
<span class="fc" id="L449">        executor.awaitTermination(ServerContext.SHUTDOWN_TIMER.toMillis(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L450">    }</span>

    @VisibleForTesting
    StreamAddressSpace getStreamAddressSpace(UUID streamID) {
<span class="fc" id="L454">        return streamLog.getStreamsAddressSpace().getAddressMap().get(streamID);</span>
    }

    @VisibleForTesting
    void prefixTrim(long trimAddress) {
<span class="fc" id="L459">        streamLog.prefixTrim(trimAddress);</span>
<span class="fc" id="L460">    }</span>

    /**
     * Log unit server configuration class
     */
<span class="pc" id="L465">    @Builder</span>
    @Getter
    public static class LogUnitServerConfig {
<span class="nc" id="L468">        private final double cacheSizeHeapRatio;</span>
<span class="fc" id="L469">        private final long maxCacheSize;</span>
<span class="fc" id="L470">        private final boolean memoryMode;</span>
<span class="fc" id="L471">        private final boolean noVerify;</span>
<span class="fc" id="L472">        private final boolean noSync;</span>

        /**
         * Parse legacy configuration options
         *
         * @param opts legacy config
         * @return log unit configuration
         */
        public static LogUnitServerConfig parse(Map&lt;String, Object&gt; opts) {
<span class="fc" id="L481">            double cacheSizeHeapRatio = Double.parseDouble((String) opts.get(&quot;--cache-heap-ratio&quot;));</span>

<span class="fc" id="L483">            return LogUnitServerConfig.builder()</span>
<span class="fc" id="L484">                    .cacheSizeHeapRatio(cacheSizeHeapRatio)</span>
<span class="fc" id="L485">                    .maxCacheSize((long) (Runtime.getRuntime().maxMemory() * cacheSizeHeapRatio))</span>
<span class="fc" id="L486">                    .memoryMode(Boolean.valueOf(opts.get(&quot;--memory&quot;).toString()))</span>
<span class="fc" id="L487">                    .noVerify((Boolean) opts.get(&quot;--no-verify&quot;))</span>
<span class="fc" id="L488">                    .noSync((Boolean) opts.get(&quot;--no-sync&quot;))</span>
<span class="fc" id="L489">                    .build();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>