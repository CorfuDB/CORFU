package org.corfudb.logreplication.fsm;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.logreplication.transmitter.SnapshotTransmitter;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;

/**
 * A class that represents the in snapshot transmit state of the Log Replication FSM.
 *
 * In this state full logs are being synced to the remote site, based on a snapshot timestamp.
 */
@Slf4j
public class InSnapshotSyncState implements LogReplicationState {

    @Getter
    private LogReplicationFSM logReplicationFSM;

    SnapshotTransmitter snapshotTransmitter;

    Future<?> transmitFuture;

    public InSnapshotSyncState(LogReplicationFSM logReplicationFSM, SnapshotTransmitter snapshotTransmitter) {
        this.logReplicationFSM = logReplicationFSM;
        this.snapshotTransmitter = snapshotTransmitter;
    }

    @Override
    public LogReplicationState processEvent(LogReplicationEvent event) {
        switch (event.getType()) {
            // Case where another snapshot (full) transmit is requested.
            case SNAPSHOT_SYNC_REQUEST:
                /*
                  Cancel snapshot transmit if still in progress, if transmit cannot be canceled
                  we cannot transition to the new state.
                 */
                return cancelSnapshotSync("another snapshot transmit request.") ?
                        logReplicationFSM.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC) : this;
            case SNAPSHOT_SYNC_CANCEL:
                 /*
                  Cancel snapshot transmit if still in progress, if transmit cannot be canceled
                  we cannot transition to the new state.
                 */
                return cancelSnapshotSync("a explicit cancel by app.") ?
                        logReplicationFSM.getStates().get(LogReplicationStateType.IN_REQUIRE_SNAPSHOT_SYNC) : this;
            case TRIMMED_EXCEPTION:
                /*
                  Cancel snapshot transmit if still in progress, if transmit cannot be canceled
                  we cannot transition to the new state.
                 */
                return cancelSnapshotSync("trimmed exception.") ?
                        logReplicationFSM.getStates().get(LogReplicationStateType.IN_REQUIRE_SNAPSHOT_SYNC) : this;
            case SNAPSHOT_SYNC_COMPLETE:
                // TODO (Anny) should we confirm this complete was generated by this same state?
                /*
                  Cancel snapshot transmit if still in progress, if transmit cannot be canceled
                  we cannot transition to the new state.
                 */
                return cancelSnapshotSync("indication of completeness.") ?
                        logReplicationFSM.getStates().get(LogReplicationStateType.IN_LOG_ENTRY_SYNC) : this;
            case REPLICATION_STOP:
                /*
                  Cancel snapshot transmit if still in progress, if transmit cannot be canceled
                  we cannot transition to the new state.
                 */
                return cancelSnapshotSync("request to stop replication.") ?
                        logReplicationFSM.getStates().get(LogReplicationStateType.INITIALIZED) : this;
            case REPLICATION_TERMINATED:
                /*
                  Cancel snapshot transmit if still in progress, if transmit cannot be canceled
                  we cannot transition to the new state.
                 */
                return cancelSnapshotSync("replication terminated.") ?
                        logReplicationFSM.getStates().get(LogReplicationStateType.STOPPED) : this;
            default: {
                log.warn("Unexpected log replication event {} when in snapshot transmit state.", event.getType());
            }
        }
        return this;
    }

    private boolean cancelSnapshotSync(String cancelCause) {
        // Cancel snapshot transmit if still in progress
        if (transmitFuture != null && !transmitFuture.isDone()) {
            boolean cancel = transmitFuture.cancel(true);
            // Verify if task could not be canceled due to normal completion.
            if (!cancel && !transmitFuture.isDone()) {
                log.error("Snapshot transmit in progress could not be canceled.");
                return false;
            }
        }
        log.info("Snapshot transmit has been canceled due to {}", cancelCause);
        return true;
    }

    @Override
    public void onEntry(LogReplicationState from) {
        // Execute snapshot transaction for every table to be replicated
        try {
            transmitFuture = logReplicationFSM.getStateMachineWorker().submit(snapshotTransmitter::transmit);
        } catch (Throwable t) {
            log.error("Error on entry of InSnapshotSyncState.", t);
        }
    }

    @Override
    public void onExit(LogReplicationState to) {
    }

    @Override
    public LogReplicationStateType getType() {
        return LogReplicationStateType.IN_SNAPSHOT_SYNC;
    }
}
