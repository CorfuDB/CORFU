package org.corfudb.logreplication.fsm;

import com.google.common.reflect.TypeToken;
import org.corfudb.logreplication.transmitter.DataMessage;
import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;
import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.protocols.wireprotocol.TokenResponse;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.collections.CorfuTable;
import org.corfudb.runtime.view.AbstractViewTest;
import org.corfudb.util.serializer.Serializers;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class StreamLogEntryReaderWriterTest extends AbstractViewTest {
    static private final int NUM_KEYS = 1000;
    static private final int NUM_STREAMS = 4;
    static private final int NUM_TRANS = 1000;

    ExecutorService executorService = Executors.newFixedThreadPool(2);

    CorfuRuntime dataRuntime = null;
    CorfuRuntime readerRuntime = null;
    CorfuRuntime writerRuntime = null;

    Random random = new Random();
    HashMap<String, CorfuTable<Long, Long>> tables = new HashMap<>();

    /*
     * the in-memory data for corfutables for verification.
     */
    HashMap<String, HashMap<Long, Long>> hashMap = new HashMap<String, HashMap<Long, Long>>();

    /*
     * store message generated by streamsnapshot reader and will play it at the writer side.
     */
    List<DataMessage> msgQ = new ArrayList<>();

    @Before
    public void setRuntime() {
        dataRuntime = getDefaultRuntime().connect();
        dataRuntime = getNewRuntime(getDefaultNode()).connect();
        readerRuntime = getNewRuntime(getDefaultNode()).connect();
        writerRuntime = getNewRuntime(getDefaultNode()).connect();
    }

    void openStreams(CorfuRuntime rt) {
        for (int i = 0; i < NUM_STREAMS; i++) {
            String name = "test" + Integer.toString(i);

            CorfuTable<Long, Long> table = rt.getObjectsView()
                    .build()
                    .setStreamName(name)
                    .setTypeToken(new TypeToken<CorfuTable<Long, Long>>() {
                    })
                    .setSerializer(Serializers.PRIMITIVE)
                    .open();
            tables.put(name, table);
            hashMap.put(name, new HashMap<>());
        }
    }

    //Generate data and the same time push the data to the hashtable
    void generateData(int numKeys) {
        for (int i = 0; i < numKeys; i++) {
            for (String name : tables.keySet()) {
                long key = i;
                tables.get(name).put(key, key);
                ((HashMap<Long, Long>)hashMap.get(name)).put(key, key);
            }
        }
    }

    void setupLogEntryReader() {

    }

    /**
     *  Do updates to both the corfutable and hashtable at the same time
     */
    void generateTransactions() {
        for(long i = 0; i < NUM_TRANS; i++) {
            dataRuntime.getObjectsView().TXBegin();
            for (String name : tables.keySet()) {
                long val = random.nextLong();
                tables.get(name).put(i, val);
                hashMap.get(name).put(i, val);
            }
            dataRuntime.getObjectsView().TXEnd();
        }
    }


    @Test
    void test() {
        setRuntime();
        openStreams(dataRuntime);
        generateData(NUM_KEYS);

        //start one thread generate transactions
        //executorService.submit(generateTransactions());

        //start one thread to read entries and put into the queue
        setupLogEntryReader();

        //clear tables

        //replay message in the queue with the writer

    }
}
