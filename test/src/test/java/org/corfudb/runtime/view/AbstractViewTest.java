package org.corfudb.runtime.view;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.AbstractCorfuTest;
import org.corfudb.CorfuTestServers;
import org.corfudb.infrastructure.BaseServer;
import org.corfudb.infrastructure.IServerRouter;
import org.corfudb.infrastructure.LayoutServer;
import org.corfudb.infrastructure.LogUnitServer;
import org.corfudb.infrastructure.ManagementServer;
import org.corfudb.infrastructure.SequencerServer;
import org.corfudb.infrastructure.ServerContext;
import org.corfudb.infrastructure.ServerContextBuilder;
import org.corfudb.infrastructure.TestServerRouter;
import org.corfudb.protocols.wireprotocol.CorfuMsgType;
import org.corfudb.protocols.wireprotocol.CorfuPayloadMsg;
import org.corfudb.protocols.wireprotocol.LayoutBootstrapRequest;
import org.corfudb.protocols.wireprotocol.SequencerTailsRecoveryMsg;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.CorfuRuntime.CorfuRuntimeParameters;
import org.corfudb.runtime.clients.BaseHandler;
import org.corfudb.runtime.clients.IClientRouter;
import org.corfudb.runtime.clients.LayoutHandler;
import org.corfudb.runtime.clients.LogUnitHandler;
import org.corfudb.runtime.clients.ManagementHandler;
import org.corfudb.runtime.clients.SequencerHandler;
import org.corfudb.runtime.clients.TestClientRouter;
import org.corfudb.runtime.clients.TestRule;
import org.corfudb.util.NodeLocator;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * This class serves as a base class for most higher-level Corfu unit tests
 * providing several helper functions to reduce boilerplate code.
 *
 * For most tests, a CorfuRuntime can be obtained by calling getDefaultRuntime().
 * This instantiates a single-node in-memory Corfu server at port 9000, already
 * bootstrapped. If getDefaultRuntime() is not called, then no servers are
 * started.
 *
 * For all other tests, servers can be started using the addServer(port, options)
 * function. The bootstrapAllServers(layout) function can be used to
 * bootstrap the servers with a specific layout. These servers can be referred
 * to by a CorfuRuntime using the "test:<port number>" convention. For example,
 * calling new CorfuRuntime("test:9000"); will connect a CorfuRuntime to the
 * test server at port 9000.
 *
 * To access servers, call the getLogUnit(port), getLayoutServer(port) and
 * getSequencer(port). This allows access to the server class public fields
 * and methods.
 *
 * In addition to simulating Corfu servers, this class also permits installing
 * special rules, which can be used to simulate failures or reorder messages.
 * To install, use the addClientRule(testRule) and addServerRule(testRule)
 * methods.
 *
 * Created by mwei on 12/22/15.
 */
@Slf4j
public abstract class AbstractViewTest extends AbstractCorfuTest {

    /** The runtime generated by default, by getDefaultRuntime(). */
    @Getter
    CorfuRuntime runtime;

    /** A map of the current test servers, by endpoint name */
    final Map<NodeLocator, TestServer> testServerMap = new ConcurrentHashMap<>();

    /** A map of maps to endpoint->routers, mapped for each runtime instance captured */
    final Map<CorfuRuntime, Map<NodeLocator, TestClientRouter>> runtimeRouterMap = new ConcurrentHashMap<>();

    /** Initialize the AbstractViewTest. */
    public AbstractViewTest() {
        // Force all new CorfuRuntimes to override the getRouterFn
        CorfuRuntime.overrideGetRouterFunction = this::getRouterFunction;
        runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()
            .nettyEventLoop(NETTY_EVENT_LOOP)
            .build());
        // Default number of times to read before hole filling to 0
        // (most aggressive, to surface concurrency issues).
        runtime.getParameters().setHoleFillRetry(0);
    }

    public CorfuRuntime getNewRuntime(@Nonnull NodeLocator node) {
        return getNewRuntime(CorfuRuntimeParameters
                .builder()
                .layoutServer(NodeLocator.parseString(node.getHost() + ":" + node.getPort()))
                .build());
    }

    public CorfuRuntime getNewRuntime(@Nonnull CorfuRuntimeParameters parameters) {
        parameters.setNettyEventLoop(NETTY_EVENT_LOOP);
        return CorfuRuntime.fromParameters(parameters);
    }

    public NodeLocator getDefaultNode() {
        return SERVERS.ENDPOINT_0;
    }

    public void simulateEndpointDisconnected(CorfuRuntime runtime) {
        ((TestClientRouter) runtime.getRouter(getDefaultEndpoint()))
                .simulateDisconnectedEndpoint();
    }

    /**
     * Function for obtaining a router, given a runtime and an endpoint.
     *
     * @param runtime  The CorfuRuntime to obtain a router for.
     * @param endpoint An endpoint string for the router.
     * @return
     */
    protected IClientRouter getRouterFunction(CorfuRuntime runtime, NodeLocator endpoint) {
        runtimeRouterMap.putIfAbsent(runtime, new ConcurrentHashMap<>());
        CorfuTestServers.checkTestEndpoint(endpoint);

        return runtimeRouterMap.get(runtime).computeIfAbsent(endpoint,
                x -> {
                    TestClientRouter tcn = new TestClientRouter(testServerMap.get(endpoint).getServerRouter());
                    tcn.addClient(new BaseHandler())
                            .addClient(new SequencerHandler())
                            .addClient(new LayoutHandler())
                            .addClient(new LogUnitHandler())
                            .addClient(new ManagementHandler());
                    return tcn;
                }
        );
    }

    /**
     * Before each test, reset the tests.
     */
    @Before
    public void resetTests() {
        runtime.parseConfigurationString(getDefaultConfiguration().toEndpointUrl());
        runtime.getAddressSpaceView().resetCaches();
    }

    @After
    public void cleanupBuffers() {
        testServerMap.values().forEach(x -> {
            x.getLogUnitServer().shutdown();
            x.getManagementServer().shutdown();
        });
        // Abort any active transactions...
        while (runtime.getObjectsView().TXActive()) {
            runtime.getObjectsView().TXAbort();
        }

        runtimeRouterMap.keySet().forEach(CorfuRuntime::shutdown);
        runtimeRouterMap.clear();
        testServerMap.clear();
    }

    /** Add a server at a specific port, using the given configuration options.
     *
     * @param node      The node to use.
     * @param config    The configuration to use for the server.
     */
    public void addServer(NodeLocator node, Map<String, Object> config) {
        ServerContext sc = new ServerContext(config);
        sc.setServerRouter(new TestServerRouter(node));
        addServer(node, sc);
    }

    /**
     * Add a server to a specific port, using the given ServerContext.
     * @param node node locator
     * @param serverContext server contaxe
     */
    public void addServer(NodeLocator node, ServerContext serverContext) {
        new TestServer(serverContext, new TestServerRouter(node)).addToTest(node, this);
    }

    /** Add a default, in-memory unbootstrapped server at a specific port.
     *
     * @param node      The node to use.
     */
    public void addServer(NodeLocator node) {
        TestServerRouter serverRouter = new TestServerRouter(node);
        ServerContext serverContext = new ServerContextBuilder(node)
                .setSingle(false)
                .setServerRouter(serverRouter)
                .build();
        new TestServer(serverContext, serverRouter).addToTest(node, this);
    }


    /**
     * Add a default, in-memory bootstrapped single node server at a specific port.
     *
     * @param node The node to use.
     */
    public void addSingleServer(NodeLocator node) {
        new TestServer(node).addToTest(node, this);
    }


    /** Get a instance of a test server, which provides access to the underlying components and server router.
     *
     * @param node      The node of the test server to retrieve.
     * @return          A test server instance.
     */
    public TestServer getServer(NodeLocator node) {
        return testServerMap.get(node);
    }

    /** Get a instance of a logging unit, given a port.
     *
     * @param node      The node of the logging unit to retrieve.
     * @return          A logging unit instance.
     */
    public LogUnitServer getLogUnit(NodeLocator node) {
        return getServer(node).getLogUnitServer();
    }

    /** Get a instance of a sequencer, given a port.
     *
     * @param node      The node of the sequencer to retrieve.
     * @return          A sequencer instance.
     */
    public SequencerServer getSequencer(NodeLocator node) {
        return getServer(node).getSequencerServer();
    }

    /** Get a instance of a layout server, given a port.
     *
     * @param node      The node of the layout server to retrieve.
     * @return          A layout server instance.
     */
    public LayoutServer getLayoutServer(NodeLocator node) {
        return getServer(node).getLayoutServer();
    }

    /**
     * Get an instance of the management server, given a port
     *
     * @param node The node of the management server to retrieve
     * @return A management server instance.
     */
    public ManagementServer getManagementServer(NodeLocator node) {
        return getServer(node).getManagementServer();
    }

    /** Get a instance of base server, given a port.
     *
     * @param node      The node of the base server to retrieve.
     * @return          A base server instance.
     */
    public BaseServer getBaseServer(NodeLocator node) {
        return getServer(node).getBaseServer();
    }

    public IServerRouter getServerRouter(NodeLocator node) {
        return getServer(node).getServerRouter();
    }

    /** Bootstraps all servers with a particular layout.
     *
     * @param l         The layout to bootstrap all servers with.
     */
    public void bootstrapAllServers(Layout l) {
        log.debug("Bootstrap all servers: {}", l.getAllServers());

        testServerMap.values().parallelStream()
                .forEach(e -> {
                    e.layoutServer.handleMessage(
                            CorfuMsgType.LAYOUT_BOOTSTRAP.payloadMsg(new LayoutBootstrapRequest(l)), null, e.serverRouter
                    );
                    e.managementServer.handleMessage(
                            CorfuMsgType.MANAGEMENT_BOOTSTRAP_REQUEST.payloadMsg(l), null, e.serverRouter
                    );
                });
        TestServer primarySequencerNode = testServerMap.get(l.getPrimarySequencerNode());

        CorfuPayloadMsg<SequencerTailsRecoveryMsg> msg = CorfuMsgType.BOOTSTRAP_SEQUENCER.payloadMsg(
                new SequencerTailsRecoveryMsg(0L, Collections.emptyMap(), l.getEpoch(), false)
        );
        primarySequencerNode.sequencerServer.handleMessage(msg, null, primarySequencerNode.serverRouter);
    }

    /** Get a default CorfuRuntime. The default CorfuRuntime is connected to a single-node
     * in-memory server at port 9000.
     * @return  A default CorfuRuntime
     */
    public CorfuRuntime getDefaultRuntime() {
        if (!testServerMap.containsKey(SERVERS.ENDPOINT_0)) {
            addSingleServer(SERVERS.ENDPOINT_0);
        }
        return getRuntime().connect();
    }

    static EventLoopGroup NETTY_EVENT_LOOP;

    @BeforeClass
    public static void initEventGroup() {
        NETTY_EVENT_LOOP =
            new DefaultEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2,
                new ThreadFactoryBuilder()
                    .setNameFormat("netty-%d")
                    .setDaemon(true)
                    .setUncaughtExceptionHandler((thread, throwable) -> {
                        assertThat(false)
                            .as("Thread " + thread.getName()
                                + " unexpectedly terminated with "
                                + throwable.getClass().getSimpleName())
                            .isTrue();
                    })
                .build());
    }

    @AfterClass
    public static void cleanEventGroup() {
        NETTY_EVENT_LOOP.shutdownGracefully().syncUninterruptibly();
    }

    /**
     * Create a runtime based on the provided layout.
     * @param l
     * @return
     */
    public CorfuRuntime getRuntime(Layout l) {
        CorfuRuntimeParameters parameters = CorfuRuntimeParameters.builder()
                .nettyEventLoop(NETTY_EVENT_LOOP)
                .layoutServers(new ArrayList<>(l.getLayoutServersNodes()))
                .build();
        return CorfuRuntime.fromParameters(parameters);
    }

    /** Clear installed rules for the default runtime.
     */
    public void clearClientRules() {
        clearClientRules(getRuntime());
    }

    /** Clear installed rules for a given runtime.
     *
     * @param r     The runtime to clear rules for.
     */
    public void clearClientRules(CorfuRuntime r) {
        runtimeRouterMap.get(r).values().forEach(x -> x.rules.clear());
    }

    /** Add a rule for the default runtime.
     *
     * @param rule  The rule to install
     */
    public void addClientRule(TestRule rule) {
        addClientRule(getRuntime(), rule);
    }

    /** Add a rule for a particular runtime.
     *
     * @param r     The runtime to install the rule to
     * @param rule  The rule to install.
     */
    public void addClientRule(CorfuRuntime r, TestRule rule) {
        runtimeRouterMap.get(r).values().forEach(x -> x.rules.add(rule));
    }

    /** Add a rule to a particular router in a particular runtime.
     *
     * @param r                     The runtime to install the rule to
     * @param clientRouterEndpoint  The Client router endpoint to install the rule to
     * @param rule                  The rule to install.
     */
    public void addClientRule(CorfuRuntime r, NodeLocator clientRouterEndpoint, TestRule rule) {
        runtimeRouterMap.get(r).get(clientRouterEndpoint).rules.add(rule);
    }

    /** Clear rules for a particular server.
     *
     * @param node  The node of the server to clear rules for.
     */
    public void clearServerRules(NodeLocator node) {
        getServer(node).getServerRouter().rules.clear();
    }

    /** Install a rule to a particular server.
     *
     * @param node  The node of the server to install the rule to.
     * @param rule  The rule to install.
     */
    public void addServerRule(NodeLocator node, TestRule rule) {
        getServer(node).getServerRouter().rules.add(rule);
    }

    /** The configuration string used for the default runtime.
     *
     * @return  The configuration string used for the default runtime.
     */
    public NodeLocator getDefaultConfiguration() {
        return getDefaultEndpoint();
    }

    /** The default endpoint (single server) used for the default runtime.
     *
     * @return  Returns the default endpoint.
     */
    public NodeLocator getDefaultEndpoint() {
        return SERVERS.ENDPOINT_0;
    }

    /** Get the endpoint string, given a port number.
     *
     * @param port  The port number to get an endpoint string for.
     * @return      The endpoint string.
     */
    public NodeLocator getEndpoint(int port) {
        return CorfuTestServers.buildTestEndpoint(port);
    }

    // Private

    /**
     * This class holds instances of servers used for test.
     */
    @Data
    private static class TestServer {
        ServerContext serverContext;
        BaseServer baseServer;
        SequencerServer sequencerServer;
        LayoutServer layoutServer;
        LogUnitServer logUnitServer;
        ManagementServer managementServer;
        IServerRouter serverRouter;
        int port;

        TestServer(Map<String, Object> optsMap, TestServerRouter router) {
            this(new ServerContext(optsMap), router);
            serverContext.setServerRouter(router);
        }

        TestServer(ServerContext serverContext, TestServerRouter router) {
            this.serverContext = serverContext;
            this.serverRouter = router;
            this.baseServer = new BaseServer(serverContext);
            this.sequencerServer = new SequencerServer(serverContext);
            this.layoutServer = new LayoutServer(serverContext);
            this.logUnitServer = new LogUnitServer(serverContext);
            this.managementServer = new ManagementServer(serverContext);

            this.serverRouter.addServer(baseServer);
            this.serverRouter.addServer(sequencerServer);
            this.serverRouter.addServer(layoutServer);
            this.serverRouter.addServer(logUnitServer);
            this.serverRouter.addServer(managementServer);
        }

        TestServer(NodeLocator node) {
            this(ServerContextBuilder.defaultTestContext(node).getServerConfig(), new TestServerRouter(node));
        }

        void addToTest(NodeLocator node, AbstractViewTest test) {
            if (test.testServerMap.putIfAbsent(node, this) != null) {
                throw new RuntimeException("Server already registered at port " + node.getPort());
            }

        }

        public TestServerRouter getServerRouter() {
            return (TestServerRouter) this.serverRouter;
        }
    }
}
