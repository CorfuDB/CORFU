<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CorfuQueue.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">samples</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.collections</a> &gt; <span class="el_source">CorfuQueue.java</span></div><h1>CorfuQueue.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.collections;

import com.google.common.reflect.TypeToken;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.object.transactions.TransactionType;
import org.corfudb.runtime.object.transactions.TransactionalContext;
import org.corfudb.runtime.view.CorfuGuidGenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * Persisted Queue supported by CorfuDB using distributed State Machine Replication.
 * Entries enqueued are backed by a CorfuTable with a LinkedHashMap where each entry
 * is mapped to a unique generated id that is returned upon successful &lt;b&gt;enqueue()&lt;/b&gt;.
 * &lt;b&gt;entryList()&lt;/b&gt; returns the enqueued entries along with their special ids which can
 * not only identify the element for removal but also has a global ordering defined by
 * the order in which their &lt;b&gt;enqueue()&lt;/b&gt; operations materialized.
 * Instead of a dequeue() this Queue supports a &lt;b&gt;remove()&lt;/b&gt; which accepts the id of the element.
 * Entries cannot be modified in-place (or will lose ordering) but can be removed from anywhere
 * from the persisted queue.
 *
 * Created by hisundar on 5/8/19.
 *
 * @param &lt;E&gt;   Type of the entry to be enqueued into the persisted queue
 */
<span class="nc" id="L33">@Slf4j</span>
public class CorfuQueue&lt;E&gt; {
    /**
     * The main CorfuTable which contains the primary key-value mappings.
     */
    private final CorfuTable&lt;Long, E&gt; corfuTable;
    private final CorfuRuntime runtime;
    private final CorfuGuidGenerator guidGenerator;

<span class="nc" id="L42">    public CorfuQueue(CorfuRuntime runtime, String streamName) {</span>
<span class="nc" id="L43">        this.runtime = runtime;</span>
<span class="nc" id="L44">        corfuTable = runtime.getObjectsView().build()</span>
<span class="nc" id="L45">                .setTypeToken(new TypeToken&lt;CorfuTable&lt;Long, E&gt;&gt;() {})</span>
<span class="nc" id="L46">                .setStreamName(streamName)</span>
<span class="nc" id="L47">                .setArguments(CorfuTable.IndexRegistry.empty(), new LinkedHashMap&lt;Long, E&gt;())</span>
<span class="nc" id="L48">                .open();</span>
<span class="nc" id="L49">        guidGenerator = new CorfuGuidGenerator(runtime);</span>
<span class="nc" id="L50">    }</span>

    /**
     * Returns the size of the queue at a given point in time.
     */
    public int size() {
<span class="nc" id="L56">        return corfuTable.size();</span>
    }

    /**
     * Each entry in the Queue is tagged with a unique Id. Internally this Id is a long.
     * However, once we get all the entries out via entryList() api, these Ids are prefixed
     * with their snapshot+index id (also a long) which represents a global comparable ordering.
     * This class encapsulates these two longs into one Id and add rules on comparability.
     */
    public static class CorfuRecordId implements Comparable&lt;CorfuRecordId&gt; {
        private final UUID id;
<span class="nc" id="L67">        public CorfuRecordId(long ordering, long uniqueId) {</span>
<span class="nc" id="L68">            this.id = new UUID(ordering, uniqueId);</span>
<span class="nc" id="L69">        }</span>

        /**
         * @return Return only the unique part of the id without the ordering
         */
        public long getEntryId() {
<span class="nc" id="L75">            return id.getLeastSignificantBits();</span>
        }

        /**
         * @return Return only the ordering part of the entry without the id.
         */
        public long getOrdering() {
<span class="nc" id="L82">            return id.getMostSignificantBits();</span>
        }

        /**
         * It's NOT ok to compare two objects if their ordering metadata is dissimilar.
         * @param o object to compare against.
         * @throws IllegalArgumentException if the two Ids are not comparable.
         * @return results of comparison.
         */
        @Override
        public int compareTo(CorfuRecordId o) {
<span class="nc bnc" id="L93" title="All 4 branches missed.">            if (this.id.getMostSignificantBits() == 0 &amp;&amp; o.id.getMostSignificantBits() != 0) {</span>
<span class="nc" id="L94">                throw new IllegalArgumentException(</span>
                        &quot;Incompatible CorfuRecordId comparison: ordering unavailable&quot;);
            }
<span class="nc bnc" id="L97" title="All 4 branches missed.">            if (this.id.getMostSignificantBits() !=0 &amp;&amp; o.id.getMostSignificantBits() == 0) {</span>
<span class="nc" id="L98">               throw new IllegalArgumentException(</span>
                       &quot;Incompatible CorfuRecordId comparison: order of compared object unknown&quot;);
            }
<span class="nc bnc" id="L101" title="All 2 branches missed.">            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {</span>
<span class="nc" id="L102">                return 0;</span>
            }
<span class="nc" id="L104">            return id.compareTo(o.id);</span>
        }

        /**
         * It is ok to check equality of a CorfuRecordId with ordering data against one without.
         * @param o object to compare against.
         * @return
         */
        public boolean equals(CorfuRecordId o) {
<span class="nc bnc" id="L113" title="All 2 branches missed.">            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();</span>
        }

        public String toString() {
<span class="nc" id="L117">            return id.toString();</span>
        }
    }

    /**
     * Appends the specified element at the end of this unbounded queue.
     * In a distributed system, the linearizable order of insertions cannot be guaranteed
     * unless a transaction is used.
     * Capacity restrictions and backoffs must be implemented outside this
     * interface. Consider validating the size of the queue against a high
     * watermark before enqueue.
     *
     * @param e the element to add
     * @throws IllegalArgumentException if some property of the specified
     *         element prevents it from being added to this queue
     * @return Unique ID representing this entry in the persistent queue
     * WARNING: The ID returned by this function will NOT be the comparable with the ID
     *          returned by the CorfuQueueRecord from entryList() method because if this
     *          method executes within a transaction, the comparable ordering is not
     *          known until the transaction commits.
     *          The ID returned here is only really useful for remove() operations.
     */
    public CorfuRecordId enqueue(E e) {
<span class="nc" id="L140">        final Long id = guidGenerator.nextLong();</span>
<span class="nc" id="L141">        corfuTable.put(id, e);</span>
<span class="nc" id="L142">        return new CorfuRecordId(0, id);</span>
    }

    /**
     * CorfuQueueRecord encapsulates each entry enqueued into CorfuQueue with its unique ID.
     * It is a read-only type returned by the entryList() method.
     * The ID returned here can be used for both point get()s as well as remove() operations
     * on this Queue.
     *
     * @param &lt;E&gt;
     */
    public static class CorfuQueueRecord&lt;E&gt; implements Comparable&lt;CorfuQueueRecord&lt;? extends E&gt;&gt; {
        /**
         * This ID represents the entry and its order in the Queue.
         * This implies that it is unique and comparable with other IDs
         * returned from CorfuQueue methods with respect to its enqueue order.
         * However it cannot be compared with ID returned from the enqueue method for ordering
         * because if this method is wrapped in a transaction, the order is established only later.
         */
<span class="nc" id="L161">        @Getter</span>
        private final CorfuRecordId recordId;

<span class="nc" id="L164">        @Getter</span>
        private final E entry;

        public String toString() {
<span class="nc" id="L168">            return String.format(&quot;%s=&gt;%s&quot;, recordId, entry);</span>
        }

<span class="nc" id="L171">        CorfuQueueRecord(long ordering, long entryId, E entry) {</span>
<span class="nc" id="L172">            this.recordId = new CorfuRecordId(ordering, entryId);</span>
<span class="nc" id="L173">            this.entry = entry;</span>
<span class="nc" id="L174">        }</span>

        @Override
        public int compareTo(CorfuQueueRecord&lt;? extends E&gt; o) {
<span class="nc" id="L178">            return this.recordId.compareTo(o.getRecordId());</span>
        }
    }

    /**
     * We need to encode 2 pieces of information into an 8 byte long to represent ordering.
     * 1. We use 40 bits for CorfuQueue's snapshot version information.
     * 2. We use 24 bits for the index within that CorfuQueue's snapshot.
     */
    final private static int MAX_BITS_FOR_INDEX = 24;
    final private static int MAX_INDEX_ENTRIES = (1&lt;&lt;MAX_BITS_FOR_INDEX) - 1;

    /**
     * Returns a List of CorfuQueueRecords sorted by the order in which the enqueue materialized.
     * This is the primary method of consumption of entries enqueued into CorfuQueue.
     *
     * To re-constitute the commit order in the presence of transactions the CorfuRecords returned
     * here have their UUID fields composed of two parts:
     *     +----------------------------------------------------------------------------+
     *     | Stream snapshot |Index in snapshot|     ID of the entry in the map        |
     *     +----------------------------------------------------------------------------+
     *     &lt;----5 bytes------&gt;&lt;----3 bytes-----&gt;&lt;------- 8 bytes -----------------------&gt;
     *
     * &lt;p&gt;Note: The ordering returned can be different based on the call. For example:
     * Queue contents at start:
     *         --- id1-&gt;R1 ----
     * thread1: snapshot at 99
     * id2 = enqueue(R2);
     * list1 = entryList(); // contents returned are [99|0+id1 =&gt; R1, 99|1+id2 =&gt; R2]
     *
     * thread2: snapshot at 100
     * list2 = entryList(); // contents returned are [100|0+id1 =&gt; R1]
     *
     * As seen above R1 returned to thread1 and thread2 have same id but different order.
     * &lt;/p&gt;
     *
     * &lt;p&gt;This function currently does not return a view like the java.util implementation,
     * and changes to the entryList will *not* be reflected in the map. &lt;/p&gt;
     *
     * @param maxEntries - Limit the number of entries returned from start of the queue
     * @throws IllegalArgumentException if maxEntries is negative.
     * @return List of Entries sorted by their enqueue order
     */
    public List&lt;CorfuQueueRecord&lt;E&gt;&gt; entryList(int maxEntries) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (maxEntries &lt;= 0) {</span>
<span class="nc" id="L223">            throw new IllegalArgumentException(&quot;entryList given negative maxEntries&quot;);</span>
        }
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (maxEntries &gt; MAX_INDEX_ENTRIES) {</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(</span>
                    &quot;entryList can't return more than &quot;+MAX_INDEX_ENTRIES+&quot; entries&quot;
            );
        }

        // Bind the iteration order to a snapshot of the Queue using a transaction.
        long snapshotVersion;
<span class="nc" id="L233">        boolean startedNewTransaction = false;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (TransactionalContext.isInTransaction()) {</span>
<span class="nc" id="L235">            snapshotVersion = TransactionalContext.getCurrentContext()</span>
<span class="nc" id="L236">                    .getSnapshotTimestamp().getSequence();</span>
        } else {
<span class="nc" id="L238">            runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE)</span>
<span class="nc" id="L239">                    .build()</span>
<span class="nc" id="L240">                    .begin();</span>
<span class="nc" id="L241">            snapshotVersion = TransactionalContext.getCurrentContext()</span>
<span class="nc" id="L242">                    .getSnapshotTimestamp().getSequence();</span>
<span class="nc" id="L243">            startedNewTransaction = true;</span>
        }
<span class="nc" id="L245">        List&lt;CorfuQueueRecord&lt;E&gt;&gt; copy = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L246">                Math.min(corfuTable.size(), maxEntries)</span>
        );
<span class="nc" id="L248">        int index = 0;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (Map.Entry&lt;Long, E&gt; entry : corfuTable.entrySet()) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (++index &gt;= maxEntries) {</span>
<span class="nc" id="L251">                break;</span>
            }
            // Note that index is already limited to fit within MAX_BITS_FOR_INDEX
<span class="nc" id="L254">            long ordering = (snapshotVersion &lt;&lt; MAX_BITS_FOR_INDEX) | index;</span>
<span class="nc" id="L255">            long entryId = entry.getKey();</span>
<span class="nc" id="L256">            CorfuQueueRecord&lt;E&gt; record = new CorfuQueueRecord&lt;&gt;(</span>
<span class="nc" id="L257">                    ordering, entryId, entry.getValue()</span>
            );
<span class="nc" id="L259">            copy.add(record);</span>
<span class="nc" id="L260">        }</span>
        // Given that we are using a WRITE_AFTER_WRITE on a read-only txn, we expect no aborts.
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (startedNewTransaction) {</span>
<span class="nc" id="L263">            runtime.getObjectsView().TXEnd();</span>
        }
<span class="nc" id="L265">        return copy;</span>
    }

    /**
     * @return all the entries in the Queue
     */
    public List&lt;CorfuQueueRecord&lt;E&gt;&gt; entryList() {
<span class="nc" id="L272">        return this.entryList(MAX_INDEX_ENTRIES);</span>
    }

    public boolean isEmpty() {
<span class="nc" id="L276">        return corfuTable.isEmpty();</span>
    }

    public boolean containsKey(CorfuRecordId key) {
<span class="nc" id="L280">        return corfuTable.containsKey(key.id.getLeastSignificantBits());</span>
    }

    /**
     * Directly retrieve the enqueued element from the CorfuTable
     * @param key
     * @return
     */
    public E get(CorfuRecordId key) {
<span class="nc" id="L289">        return corfuTable.get(key.id.getLeastSignificantBits());</span>
    }

    /**
     * Removes a specific element identified by the ID returned via enqueue() or entryList()'s CorfuRecord.
     *
     * @return The entry that was successfully removed or null if there was no mapping.
     */
    public E removeEntry(CorfuRecordId entryId) {
<span class="nc" id="L298">        return corfuTable.remove(entryId.id.getLeastSignificantBits());</span>
    }

    /**
     * Remove all entries from the Queue.
     */
    public void clear() {
<span class="nc" id="L305">        corfuTable.clear();</span>
<span class="nc" id="L306">    }</span>

    public int hashCode() {
<span class="nc" id="L309">        return Objects.hash(this);</span>
    }

    public boolean equals(Object o){
<span class="nc bnc" id="L313" title="All 2 branches missed.">        return o.hashCode() == Objects.hash(this);</span>
    }

    public String toString(){
<span class="nc" id="L317">        StringBuilder stringBuilder = new StringBuilder(corfuTable.size());</span>
<span class="nc" id="L318">        stringBuilder.append(&quot;{&quot;);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (Map.Entry&lt;Long, E&gt; entry : corfuTable.entrySet()) {</span>
<span class="nc" id="L320">            stringBuilder.append(entry.toString()).append(&quot;, &quot;);</span>
<span class="nc" id="L321">        }</span>
<span class="nc" id="L322">        stringBuilder.append(&quot;}&quot;);</span>
<span class="nc" id="L323">        return stringBuilder.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>