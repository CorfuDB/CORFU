<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WriteSetSMRStream.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">samples</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.object.transactions</a> &gt; <span class="el_source">WriteSetSMRStream.java</span></div><h1>WriteSetSMRStream.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.object.transactions;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Stream;

import lombok.extern.slf4j.Slf4j;

import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.protocols.wireprotocol.TokenResponse;
import org.corfudb.runtime.object.ISMRStream;
import org.corfudb.runtime.view.Address;
import org.corfudb.util.Utils;

/**
 * Created by mwei on 3/13/17.
 *
 * &lt;p&gt;SMRStreamAdapter wraps an optimistic transaction execution context, per
 * object, with an SMRStream API.
 *
 * &lt;p&gt;The main purpose of wrapping the write-set of optimistic transactions as an
 * SMRStream is to provide the abstraction of a stream of SMREntries. The
 * SMRStream maintains for us a position in the sequence. We can consume it
 * in a forward direction, and scroll back to previously read entries.
 *
 * &lt;p&gt;First, forget about nested transactions for now, and neglect the contexts
 * stack; that is, assume the stack has size 1.
 *
 * &lt;p&gt;A reminder from AbstractTransactionalContext about the write-set of a
 * transaction:
 * * A write-set is a key component of a transaction.
 * * We collect the write-set as a map, organized by streams.
 * * For each stream, we record a pair:
 * *  - a set of conflict-parameters modified by this transaction on the
 * *  stream,
 * *  - a list of SMR updates by this transaction on the stream.
 * *
 *
 * &lt;p&gt;The implementation of the current() method looks at the write-set, picks
 * the list of SMRentries corresponding to the current object id, and returns
 * the entry in the list corresponding the the current SMRStream position.
 *
 * &lt;p&gt;previous() decrements the current SMRStream position and returns the entry
 * corresponding to it.
 *
 * &lt;p&gt;RemainingUpTo() returns a list of entries.
 *
 * &lt;p&gt;WriteSetSMRStream does not support the full API - neither append nor seek are
 * supported.
 *
 * &lt;p&gt;Enter nested transactions.
 *
 * &lt;p&gt;WriteSetSMRStream maintains the abstractions also across nested transactions.
 * It supports navigating forward/backward across the SMREntries in the entire transaction stack.
 *
 */
<span class="fc" id="L60">@Slf4j</span>
@SuppressWarnings(&quot;checkstyle:abbreviationaswordinname&quot;)
public class WriteSetSMRStream implements ISMRStream {

    private List&lt;AbstractTransactionalContext&gt; contexts;

<span class="fc" id="L66">    int currentContext = 0;</span>

    /**
     * Current position in {@link WriteSetSMRStream#contexts}
     */
    private long currentContextPos;

    /**
     * Current write position in an SMREntry
     */
    private long writePos;

    // the specific stream-id for which this SMRstream wraps the write-set
    private final UUID id;

    /**
     * Returns a new WriteSetSMRStream containing transactional contexts and stream id.
     * @param contexts  list of transactional contexts
     * @param id  stream id
     */
    public WriteSetSMRStream(List&lt;AbstractTransactionalContext&gt; contexts,
<span class="fc" id="L87">                             UUID id) {</span>
<span class="fc" id="L88">        this.contexts = contexts;</span>
<span class="fc" id="L89">        this.id = id;</span>
<span class="fc" id="L90">        reset();</span>
<span class="fc" id="L91">    }</span>

    /** Return whether stream current transaction is the thread current transaction.
     *
     * &lt;p&gt;This is validated by checking whether the current context
     * for this stream is the same as the current context for this thread.
     *
     * @return  True, if the stream current context is the thread current context.
     *          False otherwise.
     */
    public boolean isStreamCurrentContextThreadCurrentContext() {
<span class="fc" id="L102">        return contexts.get(currentContext)</span>
<span class="fc" id="L103">                .equals(TransactionalContext.getCurrentContext());</span>
    }

    /** Return whether we are the stream for this current thread
     *
     * &lt;p&gt;This is validated by checking whether the root context
     * for this stream is the same as the root context for this thread.
     *
     * @return  True, if the thread owns the optimistic stream
     *          False otherwise.
     */
    public boolean isStreamForThisThread() {
<span class="fc" id="L115">        return contexts.get(0)</span>
<span class="fc" id="L116">                .equals(TransactionalContext.getRootContext());</span>
    }

    void mergeTransaction() {
<span class="nc" id="L120">        contexts.remove(contexts.size() - 1);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (currentContext == contexts.size()) {</span>
            // recalculate the pos based on the write pointer
            // TODO add explanation, code below very confusing!
<span class="nc" id="L124">            long readPos = Address.maxNonAddress();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            for (int i = 0; i &lt; contexts.size(); i++) {</span>
<span class="nc" id="L126">                readPos += contexts.get(i).getWriteSetEntryList(id).size();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (readPos &gt;= writePos) {</span>
<span class="nc" id="L128">                    currentContextPos = contexts.get(i).getWriteSetEntryList(id).size()</span>
                                        - (writePos - readPos) - 1;
                }
            }
<span class="nc" id="L132">            currentContext--;</span>
        }
<span class="nc" id="L134">    }</span>

    @Override
    public void gc(long trimMark) {
        //no-op
<span class="nc" id="L139">    }</span>

    @Override
    public List&lt;SMREntry&gt; remainingUpTo(long maxGlobal) {
        // Check for any new contexts
<span class="fc" id="L144">        if (TransactionalContext.getTransactionStack().size()</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">                &gt; contexts.size()) {</span>
<span class="nc" id="L146">            contexts = TransactionalContext.getTransactionStackAsList();</span>
<span class="fc" id="L147">        } else if (TransactionalContext.getTransactionStack().size()</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">                &lt; contexts.size()) {</span>
<span class="nc" id="L149">            mergeTransaction();</span>
        }
<span class="fc" id="L151">        List&lt;SMREntry&gt; entryList = new LinkedList&lt;&gt;();</span>


<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (int i = currentContext; i &lt; contexts.size(); i++) {</span>
<span class="fc" id="L155">            final List&lt;SMREntry&gt; writeSet = contexts.get(i)</span>
<span class="fc" id="L156">                    .getWriteSetEntryList(id);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            long readContextStart = i == currentContext ? currentContextPos + 1 : 0;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            for (long j = readContextStart; j &lt; writeSet.size(); j++) {</span>
<span class="fc" id="L159">                entryList.add(writeSet.get((int) j));</span>
<span class="fc" id="L160">                writePos++;</span>
            }
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (writeSet.size() &gt; 0) {</span>
<span class="fc" id="L163">                currentContext = i;</span>
<span class="fc" id="L164">                currentContextPos = writeSet.size() - 1;</span>
            }
        }
<span class="fc" id="L167">        return entryList;</span>
    }

    @Override
    public List&lt;SMREntry&gt; current() {
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (Address.nonAddress(writePos)) {</span>
<span class="nc" id="L173">            return Collections.emptyList();</span>
        }

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (Address.nonAddress(currentContextPos)) {</span>
<span class="nc" id="L177">            currentContextPos = -1;</span>
        }

<span class="fc" id="L180">        return Collections.singletonList(contexts</span>
<span class="fc" id="L181">                .get(currentContext)</span>
<span class="fc" id="L182">                .getWriteSetEntryList(id)</span>
<span class="fc" id="L183">                .get((int)(currentContextPos)));</span>
    }

    @Override
    public List&lt;SMREntry&gt; previous() {
<span class="fc" id="L188">        writePos--;</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (writePos &lt;= Address.maxNonAddress()) {</span>
<span class="fc" id="L191">            writePos = Address.maxNonAddress();</span>
<span class="fc" id="L192">            return Collections.emptyList();</span>
        }

<span class="fc" id="L195">        currentContextPos--;</span>
        // Pop the context if we're at the beginning of it
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (currentContextPos &lt;= Address.maxNonAddress()) {</span>
            do {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">                if (currentContext == 0) {</span>
<span class="nc" id="L200">                    throw new RuntimeException(</span>
<span class="nc" id="L201">                            &quot;Attempted to pop first context (pos=&quot; + pos() + &quot;)&quot;);</span>
                } else {
<span class="fc" id="L203">                    currentContext--;</span>
                }
<span class="fc" id="L205">            } while (contexts</span>
<span class="fc" id="L206">                    .get(currentContext)</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                    .getWriteSetEntrySize(id) == 0);</span>
<span class="fc" id="L208">            currentContextPos = contexts</span>
<span class="fc" id="L209">                    .get(currentContext)</span>
<span class="fc" id="L210">                    .getWriteSetEntrySize(id) - 1 ;</span>
        }

<span class="fc" id="L213">        return current();</span>
    }

    @Override
    public long pos() {
<span class="fc" id="L218">        return writePos;</span>
    }

    @Override
    public void reset() {
<span class="fc" id="L223">        writePos = Address.maxNonAddress();</span>
<span class="fc" id="L224">        currentContext = 0;</span>
<span class="fc" id="L225">        currentContextPos = Address.maxNonAddress();</span>
<span class="fc" id="L226">    }</span>

    @Override
    public void seek(long globalAddress) {
<span class="nc" id="L230">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Stream&lt;SMREntry&gt; stream() {
<span class="nc" id="L235">        return streamUpTo(Address.MAX);</span>
    }

    @Override
    public Stream&lt;SMREntry&gt; streamUpTo(long maxGlobal) {
<span class="fc" id="L240">        return remainingUpTo(maxGlobal)</span>
<span class="fc" id="L241">                .stream();</span>
    }

    @Override
    public long append(SMREntry entry,
                       Function&lt;TokenResponse, Boolean&gt; acquisitionCallback,
                       Function&lt;TokenResponse, Boolean&gt; deacquisitionCallback) {
<span class="nc" id="L248">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public UUID getID() {
<span class="nc" id="L253">        return id;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L258">        return &quot;WSSMRStream[&quot; + Utils.toReadableId(getID()) + &quot;]&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>