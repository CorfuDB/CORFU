<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NettyClientRouter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">samples</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.clients</a> &gt; <span class="el_source">NettyClientRouter.java</span></div><h1>NettyClientRouter.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.clients;

import com.codahale.metrics.Timer;
import com.google.common.collect.ImmutableMap;
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.timeout.IdleState;
import io.netty.handler.timeout.IdleStateEvent;
import io.netty.handler.timeout.IdleStateHandler;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;

import javax.annotation.Nonnull;
import javax.net.ssl.SSLException;

import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.protocols.wireprotocol.ClientHandshakeHandler;
import org.corfudb.protocols.wireprotocol.ClientHandshakeHandler.ClientHandshakeEvent;
import org.corfudb.protocols.wireprotocol.CorfuMsg;
import org.corfudb.protocols.wireprotocol.CorfuMsgType;
import org.corfudb.protocols.wireprotocol.InboundMsgFilterHandler;
import org.corfudb.protocols.wireprotocol.NettyCorfuMessageDecoder;
import org.corfudb.protocols.wireprotocol.NettyCorfuMessageEncoder;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.CorfuRuntime.CorfuRuntimeParameters;
import org.corfudb.runtime.exceptions.NetworkException;
import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;
import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuInterruptedError;
import org.corfudb.security.sasl.SaslUtils;
import org.corfudb.security.sasl.plaintext.PlainTextSaslNettyClient;
import org.corfudb.security.tls.SslContextConstructor;
import org.corfudb.util.CFUtils;
import org.corfudb.util.CorfuComponent;
import org.corfudb.util.MetricsUtils;
import org.corfudb.util.NodeLocator;
import org.corfudb.util.Sleep;


/**
 * A client router which multiplexes operations over the Netty transport.
 *
 * &lt;p&gt;Created by mwei on 12/8/15.
 */
<span class="fc" id="L70">@Slf4j</span>
@ChannelHandler.Sharable
public class NettyClientRouter extends SimpleChannelInboundHandler&lt;CorfuMsg&gt;
        implements IClientRouter {

    /**
     * New connection timeout (milliseconds).
     */
<span class="nc" id="L78">    @Getter</span>
<span class="nc" id="L79">    @Setter</span>
    public long timeoutConnect;

    /**
     * Sync call response timeout (milliseconds).
     */
<span class="nc" id="L85">    @Getter</span>
<span class="nc" id="L86">    @Setter</span>
    public long timeoutResponse;

    /**
     * Retry interval after timeout (milliseconds).
     */
<span class="nc" id="L92">    @Getter</span>
<span class="nc" id="L93">    @Setter</span>
    public long timeoutRetry;

    /**
     * The current request ID.
     */
<span class="nc" id="L99">    @Getter</span>
    @SuppressWarnings(&quot;checkstyle:abbreviation&quot;)
    public AtomicLong requestID;
    /**
     * The handlers registered to this router.
     */
    public final Map&lt;CorfuMsgType, IClient&gt; handlerMap;
    /**
     * The clients registered to this router.
     */
    public final List&lt;IClient&gt; clientList;

    /**
     * The outstanding requests on this router.
     */
    public final Map&lt;Long, CompletableFuture&gt; outstandingRequests;

    /**
     * The currently registered channel.
     */
<span class="fc" id="L119">    private volatile Channel channel = null;</span>

    /** Whether to shutdown the {@code eventLoopGroup} or not. Only applies when
     *  a deprecated constructor (which generates its own {@link EventLoopGroup} is used.
     */
<span class="fc" id="L124">    private boolean shutdownEventLoop = false;</span>

    /**
     * Whether or not this router is shutdown.
     */
    public volatile boolean shutdown;

    /** The {@link NodeLocator} which represents the remote node this
     *  {@link NettyClientRouter} connects to.
     */
<span class="nc" id="L134">    @Getter</span>
    private final NodeLocator node;

    /** The {@link CorfuRuntimeParameters} used to configure the
     *  router.
     */
    private final CorfuRuntimeParameters parameters;

    /** A {@link CompletableFuture} which is completed when a connection,
     *  including a successful handshake completes and messages can be sent
     *  to the remote node.
     */
<span class="fc" id="L146">    @Getter</span>
    volatile CompletableFuture&lt;Void&gt; connectionFuture;

    private SslContext sslContext;
    private final Map&lt;CorfuMsgType, String&gt; timerNameCache;

    /**
     * Creates a new NettyClientRouter connected to the specified host and port with the
     * specified tls and sasl options. The new {@link this} will attempt connection to
     * the node until {@link this#stop()} is called.
     *
     * @param node           The node to connect to.
     * @param eventLoopGroup The {@link EventLoopGroup} for servicing I/O.
     * @param parameters     A {@link CorfuRuntimeParameters} with the desired configuration.
     */
    public NettyClientRouter(@Nonnull NodeLocator node,
        @Nonnull EventLoopGroup eventLoopGroup,
<span class="fc" id="L163">        @Nonnull CorfuRuntimeParameters parameters) {</span>
<span class="fc" id="L164">        this.node = node;</span>
<span class="fc" id="L165">        this.parameters = parameters;</span>

        // Set timer mapping
<span class="fc" id="L168">        ImmutableMap.Builder&lt;CorfuMsgType, String&gt; mapBuilder = ImmutableMap.builder();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (CorfuMsgType type : CorfuMsgType.values()) {</span>
<span class="fc" id="L170">            mapBuilder.put(type,</span>
<span class="fc" id="L171">                    CorfuComponent.CLIENT_ROUTER.toString() + type.name().toLowerCase());</span>
        }

<span class="fc" id="L174">        timerNameCache = mapBuilder.build();</span>

<span class="fc" id="L176">        timeoutConnect = parameters.getConnectionTimeout().toMillis();</span>
<span class="fc" id="L177">        timeoutResponse = parameters.getRequestTimeout().toMillis();</span>
<span class="fc" id="L178">        timeoutRetry = parameters.getConnectionRetryRate().toMillis();</span>

<span class="fc" id="L180">        connectionFuture = new CompletableFuture&lt;&gt;();</span>

<span class="fc" id="L182">        handlerMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L183">        clientList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L184">        requestID = new AtomicLong();</span>
<span class="fc" id="L185">        outstandingRequests = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L186">        shutdown = true;</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (parameters.isTlsEnabled()) {</span>
            try {
<span class="fc" id="L190">                sslContext = SslContextConstructor.constructSslContext(false,</span>
<span class="fc" id="L191">                    parameters.getKeyStore(),</span>
<span class="fc" id="L192">                    parameters.getKsPasswordFile(),</span>
<span class="fc" id="L193">                    parameters.getTrustStore(),</span>
<span class="fc" id="L194">                    parameters.getTsPasswordFile());</span>
<span class="nc" id="L195">            } catch (SSLException e) {</span>
<span class="nc" id="L196">                throw new UnrecoverableCorfuError(e);</span>
<span class="fc" id="L197">            }</span>
        }

<span class="fc" id="L200">        addClient(new BaseHandler());</span>


        // Initialize the channel
<span class="fc" id="L204">        shutdown = false;</span>
<span class="fc" id="L205">        Bootstrap b = new Bootstrap();</span>
<span class="fc" id="L206">        b.group(eventLoopGroup);</span>
<span class="fc" id="L207">        b.channel(parameters.getSocketType().getChannelClass());</span>
<span class="fc" id="L208">        parameters.getNettyChannelOptions().forEach(b::option);</span>
<span class="fc" id="L209">        b.handler(getChannelInitializer());</span>
<span class="fc" id="L210">        b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, (int) timeoutConnect);</span>

        // Asynchronously connect, retrying until shut down.
        // Once connected, connectionFuture will be completed.
<span class="fc" id="L214">        connectAsync(b);</span>
<span class="fc" id="L215">    }</span>

    /**
     * Add a new client to the router.
     *
     * @param client The client to add to the router.
     * @return This NettyClientRouter, to support chaining and the builder pattern.
     */
    public IClientRouter addClient(IClient client) {
        // Set the client's router to this instance.
<span class="fc" id="L225">        client.setRouter(this);</span>

        // Iterate through all types of CorfuMsgType, registering the handler
<span class="fc" id="L228">        client.getHandledTypes().stream()</span>
<span class="fc" id="L229">            .forEach(x -&gt; {</span>
<span class="fc" id="L230">                handlerMap.put(x, client);</span>
<span class="fc" id="L231">                log.trace(&quot;Registered {} to handle messages of type {}&quot;, client, x);</span>
<span class="fc" id="L232">            });</span>

        // Register this type
<span class="fc" id="L235">        clientList.add(client);</span>
<span class="fc" id="L236">        return this;</span>
    }

    /**
     * Gets a client that matches a particular type.
     *
     * @param clientType The class of the client to match.
     * @param &lt;T&gt;        The type of the client to match.
     * @return The first client that matches that type.
     * @throws NoSuchElementException If there are no clients matching that type.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends IClient&gt; T getClient(Class&lt;T&gt; clientType) {
<span class="nc" id="L249">        return (T) clientList.stream()</span>
<span class="nc" id="L250">            .filter(clientType::isInstance)</span>
<span class="nc" id="L251">            .findFirst().get();</span>
    }

    /**
     * {@inheritDoc}.
     *
     * @deprecated The router automatically starts now, so this function call is no
     *             longer necessary
     */
    @Override
    @Deprecated
    public synchronized void start() {
        // Do nothing, legacy call
<span class="nc" id="L264">    }</span>

    /** Get the {@link ChannelInitializer} used for initializing the Netty channel pipeline.
     *
     * @return A {@link ChannelInitializer} which initializes the pipeline.
     */
    private ChannelInitializer getChannelInitializer() {
<span class="fc" id="L271">        return new ChannelInitializer() {</span>
            @Override
            protected void initChannel(@Nonnull Channel ch) throws Exception {
<span class="fc" id="L274">                ch.pipeline().addLast(new IdleStateHandler(parameters.getIdleConnectionTimeout(),</span>
<span class="fc" id="L275">                        parameters.getKeepAlivePeriod(), 0));</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                if (parameters.isTlsEnabled()) {</span>
<span class="fc" id="L277">                    ch.pipeline().addLast(&quot;ssl&quot;, sslContext.newHandler(ch.alloc()));</span>
                }
<span class="fc" id="L279">                ch.pipeline().addLast(new LengthFieldPrepender(4));</span>
<span class="fc" id="L280">                ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,</span>
                    0, 4, 0,
                    4));
<span class="fc bfc" id="L283" title="All 2 branches covered.">                if (parameters.isSaslPlainTextEnabled()) {</span>
<span class="fc" id="L284">                    PlainTextSaslNettyClient saslNettyClient =</span>
<span class="fc" id="L285">                        SaslUtils.enableSaslPlainText(parameters.getUsernameFile(),</span>
<span class="fc" id="L286">                            parameters.getPasswordFile());</span>
<span class="fc" id="L287">                    ch.pipeline().addLast(&quot;sasl/plain-text&quot;, saslNettyClient);</span>
                }
<span class="fc" id="L289">                ch.pipeline().addLast(new NettyCorfuMessageDecoder());</span>
<span class="fc" id="L290">                ch.pipeline().addLast(new NettyCorfuMessageEncoder());</span>
<span class="fc" id="L291">                ch.pipeline().addLast(new ClientHandshakeHandler(parameters.getClientId(),</span>
<span class="fc" id="L292">                    node.getNodeId(), parameters.getHandshakeTimeout()));</span>

                // If parameters include message filters, add corresponding filter handler
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                if (parameters.getNettyClientInboundMsgFilters() != null) {</span>
<span class="nc" id="L296">                    final InboundMsgFilterHandler inboundMsgFilterHandler =</span>
<span class="nc" id="L297">                            new InboundMsgFilterHandler(parameters.getNettyClientInboundMsgFilters());</span>
<span class="nc" id="L298">                    ch.pipeline().addLast(inboundMsgFilterHandler);</span>
                }
<span class="fc" id="L300">                ch.pipeline().addLast(NettyClientRouter.this);</span>
<span class="fc" id="L301">            }</span>
        };
    }

    /** Add a future which reconnects the server.
     *
     * @param channel       The channel to use
     * @param bootstrap     The channel bootstrap to use
     */
    private void addReconnectionOnCloseFuture(@Nonnull Channel channel,
            @Nonnull Bootstrap bootstrap) {
<span class="fc" id="L312">        channel.closeFuture().addListener((r) -&gt; {</span>
<span class="fc" id="L313">            log.debug(&quot;addReconnectionOnCloseFuture[{}]: disconnected&quot;, node);</span>
            // Remove the current completion future, forcing clients to wait for reconnection.
<span class="fc" id="L315">            connectionFuture = new CompletableFuture&lt;&gt;();</span>
            // Exceptionally complete all requests that were waiting for a completion.
<span class="fc" id="L317">            outstandingRequests.forEach((reqId, reqCompletableFuture) -&gt; {</span>
<span class="nc" id="L318">                reqCompletableFuture.completeExceptionally(</span>
                        new NetworkException(&quot;Disconnected&quot;, node));
            // And also remove them.
<span class="nc" id="L321">            outstandingRequests.remove(reqId);</span>
<span class="nc" id="L322">            });</span>
            // If we aren't shutdown, reconnect.
<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (!shutdown) {</span>
<span class="fc" id="L325">                Sleep.sleepUninterruptibly(parameters.getConnectionRetryRate());</span>
<span class="fc" id="L326">                log.debug(&quot;addReconnectionOnCloseFuture[{}]: reconnecting...&quot;, node);</span>
                // Asynchronously connect again.
<span class="fc" id="L328">                connectAsync(bootstrap);</span>
            }
<span class="fc" id="L330">        });</span>
<span class="fc" id="L331">    }</span>

    /**
     * Connect to a remote server asynchronously.
     *
     * @param bootstrap The channel bootstrap to use
     */
    private void connectAsync(@Nonnull Bootstrap bootstrap) {
        // If shutdown, return a ChannelFuture that is exceptionally completed.
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (shutdown) {</span>
<span class="fc" id="L341">            return;</span>
        }
        // Use the bootstrap to create a new channel.
<span class="fc" id="L344">        ChannelFuture f = bootstrap.connect(node.getHost(), node.getPort());</span>
<span class="fc" id="L345">        f.addListener((ChannelFuture cf) -&gt; channelConnectionFutureHandler(cf, bootstrap));</span>
<span class="fc" id="L346">    }</span>

    /** Handle when a channel is connected.
     *
     * @param future        The future that is completed when the channel is connected/
     * @param bootstrap     The bootstrap to connect a new channel (used on reconnect).
     */
    private void channelConnectionFutureHandler(@Nonnull ChannelFuture future,
                                                @Nonnull Bootstrap bootstrap) {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (future.isSuccess()) {</span>
            // Register a future to reconnect in case we get disconnected
<span class="fc" id="L357">            addReconnectionOnCloseFuture(future.channel(), bootstrap);</span>
<span class="fc" id="L358">            log.debug(&quot;connectAsync[{}]: Channel connected.&quot;, node);</span>
        } else {
            // Otherwise, the connection failed. If we're not shutdown, try reconnecting after
            // a sleep period.
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (!shutdown) {</span>
<span class="nc" id="L363">                Sleep.sleepUninterruptibly(parameters.getConnectionRetryRate());</span>
<span class="nc" id="L364">                log.debug(&quot;connectAsync[{}]: Channel connection failed, reconnecting...&quot;, node);</span>
                // Call connect, which will retry the call again.
                // Note that this is not recursive, because it is called in the
                // context of the handler future.
<span class="nc" id="L368">                connectAsync(bootstrap);</span>
            }
        }
<span class="fc" id="L371">    }</span>

    /**
     * Stops routing requests.
     */
    @Override
    public void stop() {
<span class="fc" id="L378">        log.debug(&quot;stop: Shutting down router for {}&quot;, node);</span>
<span class="fc" id="L379">        shutdown = true;</span>
<span class="fc" id="L380">        connectionFuture.completeExceptionally(new NetworkException(&quot;Router stopped&quot;, node));</span>
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">        if (channel != null &amp;&amp; channel.isOpen()) {</span>
<span class="fc" id="L382">            channel.close();</span>
        }
<span class="fc" id="L384">    }</span>

    /** {@inheritDoc}
     *  @deprecated  Deprecated, stopping a router without shutting it down is no longer supported.
     *               Please use {@link this#stop()}.
     */
    @Override
    @Deprecated
    public void stop(boolean shutdown) {
<span class="nc" id="L393">        stop();</span>
<span class="nc" id="L394">    }</span>

    /**
     * Send a message and get a completable future to be fulfilled by the reply.
     *
     * @param ctx     The channel handler context to send the message under.
     * @param message The message to send.
     * @param &lt;T&gt;     The type of completable to return.
     * @return A completable future which will be fulfilled by the reply,
     *     or a timeout in the case there is no response.
     */
    public &lt;T&gt; CompletableFuture&lt;T&gt; sendMessageAndGetCompletable(ChannelHandlerContext ctx,
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        @NonNull CorfuMsg message) {</span>
<span class="fc" id="L407">        boolean isEnabled = MetricsUtils.isMetricsCollectionEnabled();</span>

        // Check the connection future. If connected, continue with sending the message.
        // If timed out, return a exceptionally completed with the timeout.
        try {
<span class="fc" id="L412">            connectionFuture</span>
<span class="fc" id="L413">                .get(parameters.getConnectionTimeout().toMillis(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L414">        } catch (InterruptedException e) {</span>
<span class="nc" id="L415">            throw new UnrecoverableCorfuInterruptedError(e);</span>
<span class="fc" id="L416">        } catch (TimeoutException te) {</span>
<span class="fc" id="L417">            CompletableFuture&lt;T&gt; f = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L418">            f.completeExceptionally(te);</span>
<span class="fc" id="L419">            return f;</span>
<span class="nc" id="L420">        } catch (ExecutionException ee) {</span>
<span class="nc" id="L421">            CompletableFuture&lt;T&gt; f = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L422">            f.completeExceptionally(ee.getCause());</span>
<span class="nc" id="L423">            return f;</span>
<span class="fc" id="L424">        }</span>

        // Set up the timer and context to measure request
<span class="fc" id="L427">        final Timer roundTripMsgTimer = CorfuRuntime.getDefaultMetrics()</span>
<span class="fc" id="L428">                .timer(timerNameCache.get(message.getMsgType()));</span>

<span class="fc" id="L430">        final Timer.Context roundTripMsgContext = MetricsUtils</span>
<span class="fc" id="L431">                .getConditionalContext(isEnabled, roundTripMsgTimer);</span>

        // Get the next request ID.
<span class="fc" id="L434">        final long thisRequest = requestID.getAndIncrement();</span>

        // Set the message fields.
<span class="fc" id="L437">        message.setClientID(parameters.getClientId());</span>
<span class="fc" id="L438">        message.setRequestID(thisRequest);</span>

        // Generate a future and put it in the completion table.
<span class="fc" id="L441">        final CompletableFuture&lt;T&gt; cf = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L442">        outstandingRequests.put(thisRequest, cf);</span>

        // Write the message out to the channel.
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="fc" id="L446">            channel.writeAndFlush(message, channel.voidPromise());</span>
        } else {
<span class="nc" id="L448">            ctx.writeAndFlush(message, ctx.voidPromise());</span>
        }
<span class="fc" id="L450">        log.trace(&quot;Sent message: {}&quot;, message);</span>

        // Generate a benchmarked future to measure the underlying request
<span class="fc" id="L453">        final CompletableFuture&lt;T&gt; cfBenchmarked = cf.thenApply(x -&gt; {</span>
<span class="fc" id="L454">            MetricsUtils.stopConditionalContext(roundTripMsgContext);</span>
<span class="fc" id="L455">            return x;</span>
        });

        // Generate a timeout future, which will complete exceptionally
        // if the main future is not completed.
<span class="fc" id="L460">        final CompletableFuture&lt;T&gt; cfTimeout =</span>
<span class="fc" id="L461">            CFUtils.within(cfBenchmarked, Duration.ofMillis(timeoutResponse));</span>
<span class="fc" id="L462">        cfTimeout.exceptionally(e -&gt; {</span>
            // CFUtils.within() can wrap different kinds of exceptions in
            // CompletionException, just dealing with TimeoutException here since
            // the router is not aware of it and this::completeExceptionally()
            // takes care of others. This avoids handling same exception twice.
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (e.getCause() instanceof TimeoutException) {</span>
<span class="nc" id="L468">                outstandingRequests.remove(thisRequest);</span>
<span class="nc" id="L469">                log.debug(&quot;sendMessageAndGetCompletable: Remove request {} to {} due to timeout! Message:{}&quot;,</span>
<span class="nc" id="L470">                        thisRequest, node, message);</span>
            }
<span class="nc" id="L472">            return null;</span>
        });
<span class="fc" id="L474">        return cfTimeout;</span>
    }

    /**
     * Send a one way message, without adding a completable future.
     *
     * @param ctx     The context to send the message under.
     * @param message The message to send.
     */
    public void sendMessage(ChannelHandlerContext ctx, CorfuMsg message) {
        // Get the next request ID.
<span class="nc" id="L485">        final long thisRequest = requestID.getAndIncrement();</span>
        // Set the base fields for this message.
<span class="nc" id="L487">        message.setClientID(parameters.getClientId());</span>
<span class="nc" id="L488">        message.setRequestID(thisRequest);</span>
        // Write this message out on the channel.
<span class="nc" id="L490">        channel.writeAndFlush(message, channel.voidPromise());</span>
<span class="nc" id="L491">        log.trace(&quot;Sent one-way message: {}&quot;, message);</span>
<span class="nc" id="L492">    }</span>


    /**
     * Send a netty message through this router, setting the fields in the outgoing message.
     *
     * @param ctx    Channel handler context to use.
     * @param inMsg  Incoming message to respond to.
     * @param outMsg Outgoing message.
     */
    public void sendResponseToServer(ChannelHandlerContext ctx, CorfuMsg inMsg, CorfuMsg outMsg) {
<span class="nc" id="L503">        outMsg.copyBaseFields(inMsg);</span>
<span class="nc" id="L504">        ctx.writeAndFlush(outMsg, ctx.voidPromise());</span>
<span class="nc" id="L505">        log.trace(&quot;Sent response: {}&quot;, outMsg);</span>
<span class="nc" id="L506">    }</span>

    /**
     * Complete a given outstanding request with a completion value.
     *
     * @param requestId  The request to complete.
     * @param completion The value to complete the request with
     * @param &lt;T&gt;        The type of the completion.
     */
    public &lt;T&gt; void completeRequest(long requestId, T completion) {
        CompletableFuture&lt;T&gt; cf;
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">        if ((cf = (CompletableFuture&lt;T&gt;) outstandingRequests.remove(requestId)) != null) {</span>
<span class="fc" id="L518">            cf.complete(completion);</span>
        } else {
<span class="nc" id="L520">            log.warn(&quot;Attempted to complete request {}, but request not outstanding!&quot;, requestId);</span>
        }
<span class="fc" id="L522">    }</span>

    /**
     * Exceptionally complete a request with a given cause.
     *
     * @param requestID The request to complete.
     * @param cause     The cause to give for the exceptional completion.
     */
    public void completeExceptionally(long requestID, @Nonnull Throwable cause) {
        CompletableFuture cf;
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if ((cf = outstandingRequests.remove(requestID)) != null) {</span>
<span class="nc" id="L533">            cf.completeExceptionally(cause);</span>
<span class="nc" id="L534">            log.debug(&quot;completeExceptionally: Remove request {} to {} due to {}.&quot;, requestID, node,</span>
<span class="nc" id="L535">                    cause.getClass().getSimpleName(), cause);</span>
        } else {
<span class="nc" id="L537">            log.warn(&quot;Attempted to exceptionally complete request {}, but request not outstanding!&quot;,</span>
<span class="nc" id="L538">                requestID);</span>
        }
<span class="nc" id="L540">    }</span>

    /**
     * Validate the clientID of a CorfuMsg.
     *
     * @param msg The incoming message to validate.
     * @return True, if the clientID is correct, but false otherwise.
     */
    private boolean validateClientId(CorfuMsg msg) {
        // Check if the message is intended for us. If not, drop the message.
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (!msg.getClientID().equals(parameters.getClientId())) {</span>
<span class="nc" id="L551">            log.warn(&quot;Incoming message intended for client {}, our id is {}, dropping!&quot;,</span>
<span class="nc" id="L552">                    msg.getClientID(), parameters.getClientId());</span>
<span class="nc" id="L553">            return false;</span>
        }
<span class="fc" id="L555">        return true;</span>
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, CorfuMsg m) throws Exception {
        try {
            // We get the handler for this message from the map
<span class="fc" id="L562">            IClient handler = handlerMap.get(m.getMsgType());</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (handler == null) {</span>
                // The message was unregistered, we are dropping it.
<span class="nc" id="L565">                log.warn(&quot;Received unregistered message {}, dropping&quot;, m);</span>
            } else {
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">                if (validateClientId(m)) {</span>
                    // Route the message to the handler.
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">                    if (log.isTraceEnabled()) {</span>
<span class="nc" id="L570">                        log.trace(&quot;Message routed to {}: {}&quot;,</span>
<span class="nc" id="L571">                                handler.getClass().getSimpleName(), m);</span>
                    }
<span class="fc" id="L573">                    handler.handleMessage(m, ctx);</span>
                }
            }
<span class="nc" id="L576">        } catch (Exception e) {</span>
<span class="nc" id="L577">            log.error(&quot;Exception during read!&quot;, e);</span>
<span class="fc" id="L578">        }</span>
<span class="fc" id="L579">    }</span>

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
<span class="nc" id="L583">        log.error(&quot;Exception during channel handling.&quot;, cause);</span>
<span class="nc" id="L584">        ctx.close();</span>
<span class="nc" id="L585">    }</span>

    /**
     * Sends a keep alive message to the server so that the response will keep
     * the channel active in order to avoid a ReadTimeout exception that will
     * close the channel.
     */
    private void keepAlive() {
<span class="pc bpc" id="L593" title="3 of 4 branches missed.">        if (channel == null || !channel.isOpen()) {</span>
<span class="fc" id="L594">            log.info(&quot;keepAlive: channel not established or not open, skipping sending keep alive.&quot;);</span>
<span class="fc" id="L595">            return;</span>
        }
        // Send a keep alive message to server which ignores epoch
<span class="nc" id="L598">        sendMessageAndGetCompletable(null, CorfuMsgType.KEEP_ALIVE.msg());</span>
<span class="nc" id="L599">        log.trace(&quot;keepAlive: sent keep alive to {}&quot;, this.channel.remoteAddress());</span>
<span class="nc" id="L600">    }</span>

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (evt.equals(ClientHandshakeEvent.CONNECTED)) {</span>
            // Handshake successful. Complete the connection future to allow
            // clients to proceed.
<span class="fc" id="L607">            channel = ctx.channel();</span>
<span class="fc" id="L608">            connectionFuture.complete(null);</span>
<span class="fc bfc" id="L609" title="All 4 branches covered.">        } else if (evt.equals(ClientHandshakeEvent.FAILED) &amp;&amp; connectionFuture.isDone()) {</span>
            // Handshake failed. If the current completion future is complete,
            // create a new one to unset it, causing future requests
            // to wait.
<span class="fc" id="L613">            connectionFuture = new CompletableFuture&lt;&gt;();</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        } else if (evt instanceof IdleStateEvent) {</span>
<span class="fc" id="L615">            IdleStateEvent e = (IdleStateEvent) evt;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            if (e.state() == IdleState.READER_IDLE) {</span>
<span class="fc" id="L617">                ctx.close();</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">            } else if (e.state() == IdleState.WRITER_IDLE) {</span>
<span class="fc" id="L619">                keepAlive();</span>
            }
<span class="fc" id="L621">        } else {</span>
<span class="fc" id="L622">            log.warn(&quot;userEventTriggered: unhandled event {}&quot;, evt);</span>
        }
<span class="fc" id="L624">    }</span>

    // region Deprecated Methods
    // The methods below are deprecated and may be removed in a future release.
    /**
     * Creates a new NettyClientRouter connected to the specified endpoint.
     *
     * @param endpoint Endpoint to connectAsync to.
     * @deprecated Use {@link this#NettyClientRouter(NodeLocator, CorfuRuntimeParameters)}
     */
    @Deprecated
    public NettyClientRouter(String endpoint) {
<span class="nc" id="L636">        this(endpoint.split(&quot;:&quot;)[0], Integer.parseInt(endpoint.split(&quot;:&quot;)[1]));</span>
<span class="nc" id="L637">    }</span>

    /**
     * Creates a new NettyClientRouter connected to the specified host and port.
     *
     * @param host Host to connectAsync to.
     * @param port Port to connectAsync to.
     * @deprecated Use {@link this#NettyClientRouter(NodeLocator, CorfuRuntimeParameters)}
     */
    @Deprecated
    public NettyClientRouter(String host, Integer port) {
<span class="fc" id="L648">        this(NodeLocator.builder().host(host).port(port).build(),</span>
<span class="fc" id="L649">            CorfuRuntimeParameters.builder().build());</span>
<span class="fc" id="L650">    }</span>

    /**
     * Creates a new NettyClientRouter connected to the specified host and port.
     *
     * @param host Host to connectAsync to.
     * @param port Port to connectAsync to.
     * @deprecated Use {@link this#NettyClientRouter(NodeLocator, CorfuRuntimeParameters)}
     */
    @Deprecated
    public NettyClientRouter(String host, Integer port, Boolean tls,
        String keyStore, String ksPasswordFile, String trustStore,
        String tsPasswordFile, Boolean saslPlainText, String usernameFile,
        String passwordFile) {
<span class="nc" id="L664">        this(NodeLocator.builder().host(host).port(port).build(),</span>
<span class="nc" id="L665">            CorfuRuntimeParameters.builder()</span>
<span class="nc" id="L666">                .tlsEnabled(tls)</span>
<span class="nc" id="L667">                .keyStore(keyStore)</span>
<span class="nc" id="L668">                .ksPasswordFile(ksPasswordFile)</span>
<span class="nc" id="L669">                .trustStore(trustStore)</span>
<span class="nc" id="L670">                .tsPasswordFile(tsPasswordFile)</span>
<span class="nc" id="L671">                .saslPlainTextEnabled(saslPlainText)</span>
<span class="nc" id="L672">                .usernameFile(usernameFile)</span>
<span class="nc" id="L673">                .passwordFile(passwordFile)</span>
<span class="nc" id="L674">                .build());</span>
<span class="nc" id="L675">    }</span>

    public NettyClientRouter(@Nonnull NodeLocator node,
        @Nonnull CorfuRuntimeParameters parameters) {
<span class="fc" id="L679">        this(node, parameters.getSocketType()</span>
<span class="fc" id="L680">            .getGenerator().generate(Runtime.getRuntime().availableProcessors() * 2,</span>
                new ThreadFactoryBuilder()
<span class="fc" id="L682">                    .setDaemon(true)</span>
<span class="fc" id="L683">                    .setNameFormat(parameters.getNettyEventLoopThreadFormat())</span>
<span class="fc" id="L684">                    .build()), parameters);</span>
<span class="fc" id="L685">        shutdownEventLoop = true;</span>
<span class="fc" id="L686">    }</span>

    @Deprecated
    @Override
    public Integer getPort() {
<span class="nc" id="L691">        return node.getPort();</span>
    }

    @Deprecated
    public String getHost() {
<span class="nc" id="L696">        return node.getHost();</span>
    }
    // endregion
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>