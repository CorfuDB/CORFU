<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">samples</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.util</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">package org.corfudb.util;

import com.google.common.collect.Range;
import com.google.common.collect.RangeSet;
import io.netty.buffer.ByteBuf;
import jdk.internal.org.objectweb.asm.ClassReader;
import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;
import jdk.internal.org.objectweb.asm.tree.ClassNode;
import jdk.internal.org.objectweb.asm.tree.InsnList;
import jdk.internal.org.objectweb.asm.tree.MethodNode;
import jdk.internal.org.objectweb.asm.util.Printer;
import jdk.internal.org.objectweb.asm.util.Textifier;
import jdk.internal.org.objectweb.asm.util.TraceMethodVisitor;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.logprotocol.LogEntry;
import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;
import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.runtime.view.stream.StreamAddressSpace;
import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;
import org.corfudb.protocols.wireprotocol.TailsResponse;
import org.corfudb.recovery.RecoveryUtils;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.view.Address;
import org.corfudb.runtime.view.Layout;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by crossbach on 5/22/15.
 */
<span class="nc" id="L47">@Slf4j</span>
public class Utils {

    private static final int DEFAULT_LOGUNIT = 0;

<span class="nc" id="L52">    private Utils() {</span>
        // prevent instantiation of this class
<span class="nc" id="L54">    }</span>

<span class="nc" id="L56">    private static final Printer printer = new Textifier();</span>
<span class="nc" id="L57">    private static final TraceMethodVisitor mp = new TraceMethodVisitor(printer);</span>

<span class="nc" id="L59">    private static final char[] hexArray = &quot;0123456789ABCDEF&quot;.toCharArray();</span>

    /** Convert a byte array to a hex string.
     * Source:
     * https://stackoverflow.com/questions/9655181/
     * how-to-convert-a-byte-array-to-a-hex-string-in-java
     * @param bytes Byte array to convert
     * @return      Hex string representation.
     */
    public static String bytesToHex(byte[] bytes) {
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (bytes == null) {</span>
<span class="nc" id="L70">            return &quot;(null)&quot;;</span>
        }
<span class="nc" id="L72">        char[] hexChars = new char[bytes.length * 2];</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        for ( int j = 0; j &lt; bytes.length; j++ ) {</span>
<span class="nc" id="L74">            int v = bytes[j] &amp; 0xFF;</span>
<span class="nc" id="L75">            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];</span>
<span class="nc" id="L76">            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];</span>
        }
<span class="nc" id="L78">        return new String(hexChars);</span>
    }

    public static byte[] intToBigEndianByteArray(int in) {
<span class="nc" id="L82">        return new byte[] {</span>
                (byte) ((in &gt;&gt; 24) &amp; 0xFF),
                (byte) ((in &gt;&gt; 16) &amp; 0xFF),
                (byte) ((in &gt;&gt; 8) &amp; 0xFF),
                (byte) (in &amp; 0xFF)};
    }


    public static byte[] longToBigEndianByteArray(long in) {
<span class="nc" id="L91">        return new byte[] {</span>
                (byte) ((in &gt;&gt; 56) &amp; 0xFF),
                (byte) ((in &gt;&gt; 48) &amp; 0xFF),
                (byte) ((in &gt;&gt; 40) &amp; 0xFF),
                (byte) ((in &gt;&gt; 32) &amp; 0xFF),
                (byte) ((in &gt;&gt; 24) &amp; 0xFF),
                (byte) ((in &gt;&gt; 16) &amp; 0xFF),
                (byte) ((in &gt;&gt; 8) &amp; 0xFF),
                (byte) (in &amp; 0xFF)};
    }

    /**
     * Print byte code.
     * @param bytes Byte array that represents the byte code
     * @return String representation of the byte code
     */
    public static String printByteCode(byte[] bytes) {
<span class="nc" id="L108">        ClassReader cr = new ClassReader(bytes);</span>
<span class="nc" id="L109">        ClassNode cn = new ClassNode();</span>
<span class="nc" id="L110">        cr.accept(cn, 0);</span>
<span class="nc" id="L111">        final List&lt;MethodNode&gt; methods = cn.methods;</span>
<span class="nc" id="L112">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        for (MethodNode m : methods) {</span>
<span class="nc" id="L114">            InsnList inList = m.instructions;</span>
<span class="nc" id="L115">            sb.append(m.name);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            for (int i = 0; i &lt; inList.size(); i++) {</span>
<span class="nc" id="L117">                sb.append(insnToString(inList.get(i)));</span>
            }
<span class="nc" id="L119">        }</span>
<span class="nc" id="L120">        return sb.toString();</span>
    }

    public static String insnToString(AbstractInsnNode insn) {
<span class="nc" id="L124">        insn.accept(mp);</span>
<span class="nc" id="L125">        StringWriter sw = new StringWriter();</span>
<span class="nc" id="L126">        printer.print(new PrintWriter(sw));</span>
<span class="nc" id="L127">        printer.getText().clear();</span>
<span class="nc" id="L128">        return sw.toString();</span>
    }

    /**
     * A fancy parser which parses suffixes.
     *
     * @param toParseObj
     * @return
     */
    public static long parseLong(final Object toParseObj) {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (toParseObj == null) {</span>
<span class="nc" id="L139">            return 0;</span>
        }
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (toParseObj instanceof Long) {</span>
<span class="nc" id="L142">            return (Long) toParseObj;</span>
        }
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (toParseObj instanceof Integer) {</span>
<span class="nc" id="L145">            return (Integer) toParseObj;</span>
        }
<span class="nc" id="L147">        String toParse = (String) toParseObj;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (toParse.matches(&quot;[0-9]*[A-Za-z]$&quot;)) {</span>
            long multiplier;
<span class="nc" id="L150">            char suffix = toParse.toUpperCase().charAt(toParse.length() - 1);</span>
<span class="nc bnc" id="L151" title="All 7 branches missed.">            switch (suffix) {</span>
                case 'E':
<span class="nc" id="L153">                    multiplier = 1_000_000_000_000_000_000L;</span>
<span class="nc" id="L154">                    break;</span>
                case 'P':
<span class="nc" id="L156">                    multiplier = 1_000_000_000_000_000L;</span>
<span class="nc" id="L157">                    break;</span>
                case 'T':
<span class="nc" id="L159">                    multiplier = 1_000_000_000_000L;</span>
<span class="nc" id="L160">                    break;</span>
                case 'G':
<span class="nc" id="L162">                    multiplier = 1_000_000_000L;</span>
<span class="nc" id="L163">                    break;</span>
                case 'M':
<span class="nc" id="L165">                    multiplier = 1_000_000L;</span>
<span class="nc" id="L166">                    break;</span>
                case 'K':
<span class="nc" id="L168">                    multiplier = 1_000L;</span>
<span class="nc" id="L169">                    break;</span>
                default:
<span class="nc" id="L171">                    throw new NumberFormatException(&quot;Unknown suffix: '&quot; + suffix + &quot;'!&quot;);</span>
            }
<span class="nc" id="L173">            return Long.parseLong(toParse.substring(0, toParse.length() - 2)) * multiplier;</span>
        } else {
<span class="nc" id="L175">            return Long.parseLong(toParse);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T getOption(Map&lt;String, Object&gt; optionsMap, String option, Class&lt;T&gt; type,
                                  T defaultValue) {
<span class="nc" id="L182">        T obj = (T) optionsMap.get(option);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (type == Long.class) {</span>
<span class="nc bnc" id="L184" title="All 4 branches missed.">            if (obj == null &amp;&amp; defaultValue != null) {</span>
<span class="nc" id="L185">                return defaultValue;</span>
            }
<span class="nc" id="L187">            return (T) (Long) parseLong(obj);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        } else if (type == Integer.class) {</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">            if (obj == null &amp;&amp; defaultValue != null) {</span>
<span class="nc" id="L190">                return defaultValue;</span>
            }
<span class="nc" id="L192">            return (T) (Integer) ((Long) parseLong(obj)).intValue();</span>
        }
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L195">            return defaultValue;</span>
        }
<span class="nc" id="L197">        return obj;</span>
    }

    public static &lt;T&gt; T getOption(Map&lt;String, Object&gt; optionsMap, String option, Class&lt;T&gt; type) {
<span class="nc" id="L201">        return getOption(optionsMap, option, type, null);</span>
    }

    /**
     * Turn a range into a set of discrete longs.
     *
     * @param range The range to discretize.
     * @return A set containing all the longs in that range.
     */
    public static Set&lt;Long&gt; discretizeRange(Range&lt;Long&gt; range) {
<span class="nc" id="L211">        Set&lt;Long&gt; s = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (long l = range.lowerEndpoint(); l &lt;= range.upperEndpoint(); l++) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (range.contains(l)) {</span>
<span class="nc" id="L214">                s.add(l);</span>
            }
        }
<span class="nc" id="L217">        return s;</span>
    }

    /**
     * Turn a set of ranges into a discrete set.
     *
     * @param ranges A set of ranges to discretize.
     * @return A set containing all the longs in that rangeset.
     */
    public static Set&lt;Long&gt; discretizeRangeSet(RangeSet&lt;Long&gt; ranges) {
<span class="nc" id="L227">        Set&lt;Long&gt; total = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        for (Range&lt;Long&gt; r : ranges.asRanges()) {</span>
<span class="nc" id="L229">            total.addAll(Utils.discretizeRange(r));</span>
<span class="nc" id="L230">        }</span>
<span class="nc" id="L231">        return total;</span>
    }

    /**
     * Convert to byte string representation.
     * from http://stackoverflow.com/questions/3758606/how-to-convert-byte-size-into-human-readable-format-in-java
     *
     * @param value The value to convert.
     * @return A string for bytes (i.e, 10GB).
     */
    public static String convertToByteStringRepresentation(final long value) {
<span class="nc" id="L242">        final long[] dividers = new long[]{1_000_000_000_000L, 1_000_000_000, 1_000_000, 1_000, 1};</span>
<span class="nc" id="L243">        final String[] units = new String[]{&quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot;};</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (value &lt; 1) {</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);</span>
        }
<span class="nc" id="L247">        String result = null;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        for (int i = 0; i &lt; dividers.length; i++) {</span>
<span class="nc" id="L249">            final long divider = dividers[i];</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (value &gt;= divider) {</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">                final double cresult =</span>
                        divider &gt; 1 ? (double) value / (double) divider : (double) value;
<span class="nc" id="L253">                result = new DecimalFormat(&quot;#,##0.#&quot;).format(cresult) + &quot; &quot; + units[i];</span>
<span class="nc" id="L254">                break;</span>
            }
        }
<span class="nc" id="L257">        return result;</span>
    }

    /**
     * Serialize an object into a ByteBuffer.
     * @param obj Object to serialize
     * @return Buffer of the serialized object
     */
    public static ByteBuffer serialize(Object obj) {
        try {
            //todo: make serialization less clunky!
<span class="nc" id="L268">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L269">            ObjectOutputStream oos = new ObjectOutputStream(baos);</span>
<span class="nc" id="L270">            oos.writeObject(obj);</span>
<span class="nc" id="L271">            byte[] b = baos.toByteArray();</span>
<span class="nc" id="L272">            oos.close();</span>
<span class="nc" id="L273">            return ByteBuffer.wrap(b);</span>
<span class="nc" id="L274">        } catch (IOException e) {</span>
<span class="nc" id="L275">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Deserialize an object from a ByteBuffer.
     * @param b Buffer
     * @return Deserialized object
     */
    public static Object deserialize(ByteBuffer b) {
        try {
            //todo: make serialization less clunky!
<span class="nc" id="L287">            ByteArrayInputStream bais = new ByteArrayInputStream(b.array());</span>
<span class="nc" id="L288">            ObjectInputStream ois = new ObjectInputStream(bais);</span>
<span class="nc" id="L289">            return ois.readObject();</span>
<span class="nc" id="L290">        } catch (IOException e) {</span>
<span class="nc" id="L291">            throw new RuntimeException(e);</span>
<span class="nc" id="L292">        } catch (ClassNotFoundException ce) {</span>
<span class="nc" id="L293">            throw new RuntimeException(ce);</span>
        }
    }

    /**
     * Hex dump readable contents of ByteBuf to stdout.
     *
     * @param b ByteBuf with readable bytes available.
     */
    public static void hexdump(ByteBuf b) {
<span class="nc" id="L303">        byte[] bulk = new byte[b.readableBytes()];</span>
<span class="nc" id="L304">        int oldReaderIndex = b.readerIndex();</span>
<span class="nc" id="L305">        b.readBytes(bulk, 0, b.readableBytes() - 1);</span>
<span class="nc" id="L306">        b.readerIndex(oldReaderIndex);</span>
<span class="nc" id="L307">        hexdump(bulk);</span>
<span class="nc" id="L308">    }</span>

    /**
     * Hex dump contents of byte[] to stdout.
     *
     * @param bulk Bytes.
     */
    public static void hexdump(byte[] bulk) {
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (bulk != null) {</span>
<span class="nc" id="L317">            System.out.printf(&quot;Bulk(%d): &quot;, bulk.length);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            for (int i = 0; i &lt; bulk.length; i++) {</span>
<span class="nc" id="L319">                System.out.printf(&quot;%x,&quot;, bulk[i]);</span>
            }
<span class="nc" id="L321">            System.out.printf(&quot;\n&quot;);</span>
        }
<span class="nc" id="L323">    }</span>


    static long rotl64(long x, int r) {
<span class="nc" id="L327">        return (x &lt;&lt; r) | (x &gt;&gt; (64 - r));</span>
    }

    static long fmix64(long k) {
<span class="nc" id="L331">        k ^= k &gt;&gt; 33;</span>
<span class="nc" id="L332">        k *= 0xff51afd7ed558ccdL;</span>
<span class="nc" id="L333">        k ^= k &gt;&gt; 33;</span>
<span class="nc" id="L334">        k *= 0xc4ceb9fe1a85ec53L;</span>
<span class="nc" id="L335">        k ^= k &gt;&gt; 33;</span>
<span class="nc" id="L336">        return k;</span>
    }

    /**
     * murmer hash 3 implementation specialized for UUIDs,
     * based on googlecode C implementation from:
     * http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
     *
     * @param key key to hash
     * @param seed hash seed
     * @return hash of the key
     */
    public static UUID murmerhash3(UUID key, long seed) {
<span class="nc" id="L349">        final long msb = key.getMostSignificantBits();</span>
<span class="nc" id="L350">        final long lsb = key.getLeastSignificantBits();</span>
<span class="nc" id="L351">        byte[] data = new byte[8];</span>
<span class="nc" id="L352">        data[7] = (byte) (lsb &amp; 0xFF);</span>
<span class="nc" id="L353">        data[6] = (byte) ((lsb &gt;&gt; 8) &amp; 0xFF);</span>
<span class="nc" id="L354">        data[5] = (byte) ((lsb &gt;&gt; 16) &amp; 0xFF);</span>
<span class="nc" id="L355">        data[4] = (byte) ((lsb &gt;&gt; 24) &amp; 0xFF);</span>
<span class="nc" id="L356">        data[3] = (byte) (msb &amp; 0xFF);</span>
<span class="nc" id="L357">        data[2] = (byte) ((msb &gt;&gt; 8) &amp; 0xFF);</span>
<span class="nc" id="L358">        data[1] = (byte) ((msb &gt;&gt; 16) &amp; 0xFF);</span>
<span class="nc" id="L359">        data[0] = (byte) ((msb &gt;&gt; 24) &amp; 0xFF);</span>

<span class="nc" id="L361">        int nblocks = 2;</span>
<span class="nc" id="L362">        long h1 = seed;</span>
<span class="nc" id="L363">        long h2 = seed;</span>
<span class="nc" id="L364">        long c1 = 0x87c37b91114253d5L;</span>
<span class="nc" id="L365">        long c2 = 0x4cf5ad432745937fL;</span>
<span class="nc" id="L366">        long[] blocks = new long[nblocks];</span>
<span class="nc" id="L367">        blocks[0] = msb;</span>
<span class="nc" id="L368">        blocks[1] = lsb;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        for (int i = 0; i &lt; nblocks; i++) {</span>
<span class="nc" id="L370">            long k1 = blocks[i * 2 + 0];</span>
<span class="nc" id="L371">            k1 *= c1;</span>
<span class="nc" id="L372">            k1 = rotl64(k1, 31);</span>
<span class="nc" id="L373">            k1 *= c2;</span>
<span class="nc" id="L374">            h1 ^= k1;</span>
<span class="nc" id="L375">            h1 = rotl64(h1, 27);</span>
<span class="nc" id="L376">            h1 += h2;</span>
<span class="nc" id="L377">            h1 = h1 * 5 + 0x52dce729;</span>
<span class="nc" id="L378">            long k2 = blocks[i * 2 + 1];</span>
<span class="nc" id="L379">            k2 *= c2;</span>
<span class="nc" id="L380">            k2 = rotl64(k2, 33);</span>
<span class="nc" id="L381">            k2 *= c1;</span>
<span class="nc" id="L382">            h2 ^= k2;</span>
<span class="nc" id="L383">            h2 = rotl64(h2, 31);</span>
<span class="nc" id="L384">            h2 += h1;</span>
<span class="nc" id="L385">            h2 = h2 * 5 + 0x38495ab5;</span>
        }
<span class="nc" id="L387">        h1 ^= 2;</span>
<span class="nc" id="L388">        h2 ^= 2;</span>
<span class="nc" id="L389">        h1 += h2;</span>
<span class="nc" id="L390">        h2 += h1;</span>
<span class="nc" id="L391">        h1 = fmix64(h1);</span>
<span class="nc" id="L392">        h2 = fmix64(h2);</span>
<span class="nc" id="L393">        h1 += h2;</span>
<span class="nc" id="L394">        h2 += h1;</span>
<span class="nc" id="L395">        return new UUID(h2, h1);</span>
    }

    /**
     * simple UUID hashing, which is *not* hashing, and is effectively
     * customized to the task of deterministically allocating new UUIDs
     * based on a given UUID (which is necessary in the assignment of stream
     * IDs in ICOrfuDBObjects that contain others, since syncing the log in
     * multiple clients needs allocators to produce the same streamID/object
     * every time).
     *
     * @param key key to hash
     * @param seed seed
     * @return hash value
     */
    public static UUID simpleUUIDHash(UUID key, long seed) {
<span class="nc" id="L411">        return new UUID(key.getMostSignificantBits(),</span>
<span class="nc" id="L412">                key.getLeastSignificantBits() + seed);</span>
    }

    public static UUID nextDeterministicUuid(UUID uuid, long seed) {
<span class="nc" id="L416">        return simpleUUIDHash(uuid, seed);</span>
    }


    /** restart the JVM - borrowed from https://dzone.com/articles/programmatically-restart-java */
    /**
     * Sun property pointing the main class and its arguments.
     * Might not be defined on non Hotspot VM implementations.
     */
    public static final String SUN_JAVA_COMMAND = &quot;sun.java.command&quot;;

    /** Generates a human readable UUID string (4 hex chars) using time_mid.
     * @param id    The UUID to parse
     * @return      A human readable UUID string
     */
    public static String toReadableId(UUID id) {
<span class="nc" id="L432">        return Long.toHexString((id.getLeastSignificantBits()) &amp; 0xFFFF);</span>
    }

    /** Print the anatomy of a LogData
     *
     * &lt;p&gt;Print how many streams are contained in the Metadata and
     * how many entries per stream.
     *
     * &lt;p&gt;Pretty useful for understanding how the the db is being used
     * from the application perspective.
     *
     * @param logData Data entry to print
     */
    public static void printLogAnatomy(CorfuRuntime runtime, ILogData logData) {
        try {
<span class="nc" id="L447">            LogEntry le = RecoveryUtils.deserializeLogData(runtime, logData);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (le.getType() == LogEntry.LogEntryType.SMR) {</span>
<span class="nc" id="L449">                log.info(&quot;printLogAnatomy: Number of Streams: 1&quot;);</span>
<span class="nc" id="L450">                log.info(&quot;printLogAnatomy: Number of Entries: 1&quot;);</span>
<span class="nc" id="L451">                log.info(&quot;--------------------------&quot;);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            } else if (le.getType() == LogEntry.LogEntryType.MULTIOBJSMR) {</span>
<span class="nc" id="L453">                log.info(&quot;printLogAnatomy: Number of Streams: {}&quot;, logData.getStreams().size());</span>
<span class="nc" id="L454">                ((MultiObjectSMREntry)le).getEntryMap().forEach((stream, multiSmrEntry) -&gt; {</span>
<span class="nc" id="L455">                    log.info(&quot;printLogAnatomy: Number of Entries: {}&quot;,</span>
<span class="nc" id="L456">                            multiSmrEntry.getSMRUpdates(stream).size());</span>
<span class="nc" id="L457">                });</span>
<span class="nc" id="L458">                log.info(&quot;--------------------------&quot;);</span>
            }

<span class="nc" id="L461">        } catch (Exception e) {</span>
<span class="nc" id="L462">            log.warn(&quot;printLogAnatomy [logAddress={}] cannot be deserialized &quot;,</span>
<span class="nc" id="L463">                    logData.getGlobalAddress());</span>
<span class="nc" id="L464">        }</span>
<span class="nc" id="L465">    }</span>

    /**
     * Get global log tail.
     *
     * @param layout Latest layout to query log tail from Log Unit
     * @param runtime Runtime
     *
     * @return Log global tail
     */
    public static long getLogTail(Layout layout, CorfuRuntime runtime) {
<span class="nc" id="L476">        long globalLogTail = Address.NON_EXIST;</span>

<span class="nc" id="L478">        Layout.LayoutSegment segment = layout.getLatestSegment();</span>

        // Query the head log unit in every stripe.
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (Layout.LayoutStripe stripe : segment.getStripes()) {</span>

<span class="nc" id="L484">                TailsResponse response = CFUtils.getUninterruptibly(</span>
<span class="nc" id="L485">                        runtime.getLayoutView().getRuntimeLayout(layout)</span>
<span class="nc" id="L486">                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))</span>
<span class="nc" id="L487">                                .getLogTail());</span>
<span class="nc" id="L488">                globalLogTail = Long.max(globalLogTail, response.getLogTail());</span>
<span class="nc" id="L489">            }</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {</span>
<span class="nc" id="L491">            throw new UnsupportedOperationException();</span>
        }

<span class="nc" id="L494">        return globalLogTail;</span>
    }

    /**
     * Fetches the max global log tail and all stream tails from the log unit cluster. This depends on the mode of
     * replication being used.
     * CHAIN: Block on fetch of global log tail from the head log unit in every stripe.
     * QUORUM: Block on fetch of global log tail from a majority in every stripe.
     *
     * @param layout  Latest layout to get clients to fetch tails.
     * @return The max global log tail obtained from the log unit servers.
     */
    public static TailsResponse getAllTails(Layout layout, CorfuRuntime runtime) {
<span class="nc" id="L507">        Set&lt;TailsResponse&gt; luResponses = new HashSet&lt;&gt;();</span>

<span class="nc" id="L509">        Layout.LayoutSegment segment = layout.getLatestSegment();</span>

        // Query the tail of the head log unit in every stripe.
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            for (Layout.LayoutStripe stripe : segment.getStripes()) {</span>

<span class="nc" id="L515">                TailsResponse res = CFUtils.getUninterruptibly(</span>
<span class="nc" id="L516">                        runtime.getLayoutView().getRuntimeLayout(layout)</span>
<span class="nc" id="L517">                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))</span>
<span class="nc" id="L518">                                .getAllTails());</span>
<span class="nc" id="L519">                luResponses.add(res);</span>
<span class="nc" id="L520">            }</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {</span>
<span class="nc" id="L522">            throw new UnsupportedOperationException();</span>
        }

<span class="nc" id="L525">        return aggregateLogUnitTails(luResponses);</span>
    }

    /**
     * Given a set of request tails, we aggregate them and maintain
     * the greatest address per stream and the greatest tail over
     * all responses.
     * @param responses a set of tail responses
     * @return An max-aggregation of all tails
     */
    static TailsResponse aggregateLogUnitTails(Set&lt;TailsResponse&gt; responses) {
<span class="nc" id="L536">        long globalTail = Address.NON_ADDRESS;</span>
<span class="nc" id="L537">        Map&lt;UUID, Long&gt; globalStreamTails = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">        for (TailsResponse res : responses) {</span>
<span class="nc" id="L540">            globalTail = Math.max(globalTail, res.getLogTail());</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">            for (Map.Entry&lt;UUID, Long&gt; stream : res.getStreamTails().entrySet()) {</span>
<span class="nc" id="L543">                long streamTail = globalStreamTails.getOrDefault(stream.getKey(), Address.NON_ADDRESS);</span>
<span class="nc" id="L544">                globalStreamTails.put(stream.getKey(), Math.max(streamTail, stream.getValue()));</span>
<span class="nc" id="L545">            }</span>
<span class="nc" id="L546">        }</span>
        // All epochs should be equal as all the tails are queried using a single runtime layout.
<span class="nc" id="L548">        return new TailsResponse(globalTail, globalStreamTails);</span>
    }

    static Map&lt;UUID, StreamAddressSpace&gt; aggregateStreamAddressMap(Map&lt;UUID, StreamAddressSpace&gt; streamAddressSpaceMap,
                                                                   Map&lt;UUID, StreamAddressSpace&gt; aggregated) {
<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (Map.Entry&lt;UUID, StreamAddressSpace&gt; stream : streamAddressSpaceMap.entrySet()) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (aggregated.containsKey(stream.getKey())) {</span>
<span class="nc" id="L555">                long currentTrimMark = aggregated.get(stream.getKey()).getTrimMark();</span>
<span class="nc" id="L556">                aggregated.get(stream.getKey()).getAddressMap().or(stream.getValue().getAddressMap());</span>
<span class="nc" id="L557">                aggregated.get(stream.getKey()).setTrimMark(Math.max(currentTrimMark, stream.getValue().getTrimMark()));</span>
<span class="nc" id="L558">            } else {</span>
<span class="nc" id="L559">                aggregated.put(stream.getKey(), stream.getValue());</span>
            }
<span class="nc" id="L561">        }</span>

<span class="nc" id="L563">        return aggregated;</span>
    }

    /**
     * Retrieve the space of addresses of the log, i.e., for all streams in the log.
     * This is typically used for sequencer recovery.
     *
     * @param layout latest layout.
     * @param runtime current runtime.
     * @return response with all streams addresses and global log tail.
     */
    public static StreamsAddressResponse getLogAddressSpace(Layout layout, CorfuRuntime runtime) {
<span class="nc" id="L575">        Set&lt;StreamsAddressResponse&gt; luResponses = new HashSet&lt;&gt;();</span>

<span class="nc" id="L577">        Layout.LayoutSegment segment = layout.getLatestSegment();</span>

        // Query the tail of the head log unit in every stripe.
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            for (Layout.LayoutStripe stripe : segment.getStripes()) {</span>

<span class="nc" id="L583">                StreamsAddressResponse res = CFUtils.getUninterruptibly(</span>
<span class="nc" id="L584">                        runtime.getLayoutView().getRuntimeLayout(layout)</span>
<span class="nc" id="L585">                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))</span>
<span class="nc" id="L586">                                .getLogAddressSpace());</span>
<span class="nc" id="L587">                luResponses.add(res);</span>
<span class="nc" id="L588">            }</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {</span>
<span class="nc" id="L590">            throw new UnsupportedOperationException();</span>
        }

<span class="nc" id="L593">        return aggregateLogAddressSpace(luResponses);</span>
    }

    static StreamsAddressResponse aggregateLogAddressSpace(Set&lt;StreamsAddressResponse&gt; responses) {
<span class="nc" id="L597">        Map&lt;UUID, StreamAddressSpace&gt; globalStreamTails = new HashMap&lt;&gt;();</span>
<span class="nc" id="L598">        long logTail = Address.NON_ADDRESS;</span>

<span class="nc bnc" id="L600" title="All 2 branches missed.">        for (StreamsAddressResponse res : responses) {</span>
<span class="nc" id="L601">            logTail = Math.max(logTail, res.getLogTail());</span>
<span class="nc" id="L602">            globalStreamTails = aggregateStreamAddressMap(res.getAddressMap(), globalStreamTails);</span>
<span class="nc" id="L603">        }</span>
<span class="nc" id="L604">        return new StreamsAddressResponse(logTail, globalStreamTails);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>